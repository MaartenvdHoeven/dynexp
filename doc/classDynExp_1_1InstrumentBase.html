<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynExp: DynExp::InstrumentBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DynExp.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynExp
   </div>
   <div id="projectbrief">Highly flexible laboratory automation for dynamically changing experiments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classDynExp_1_1InstrumentBase.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDynExp_1_1InstrumentBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DynExp::InstrumentBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devices (instruments). While meta instruments are used by modules (<code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>) as an abstraction layer, physical instruments derive from meta instruments and make usually use of one hardware adapter (<code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code>) to communicate with the underlying hardware.  
 <a href="classDynExp_1_1InstrumentBase.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DynExp::InstrumentBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDynExp_1_1InstrumentBase__inherit__graph.svg" width="2150" height="656"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase_1_1InstrumenThreadOnlyType.html">InstrumenThreadOnlyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a>'s</code> private methods to the instrument thread <code><a class="el" href="classDynExp_1_1InstrumentBase_1_1InstrumenThreadOnlyType.html#acfae0e364389e4ec5258f2228c0dfa16" title="Instruments run in their own thread. This is the instrument thread&#39;s main function.">InstrumentThreadMain()</a></code>.  <a href="classDynExp_1_1InstrumentBase_1_1InstrumenThreadOnlyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c274377b625b68ffbe58afcb11267b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a3c274377b625b68ffbe58afcb11267b2">ParamsType</a> = <a class="el" href="classDynExp_1_1InstrumentParamsBase.html">InstrumentParamsBase</a></td></tr>
<tr class="memdesc:a3c274377b625b68ffbe58afcb11267b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1InstrumentBase.html#a3c274377b625b68ffbe58afcb11267b2">More...</a><br /></td></tr>
<tr class="separator:a3c274377b625b68ffbe58afcb11267b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07cbb563d629d268b51c5eae3fefef6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab07cbb563d629d268b51c5eae3fefef6">ConfigType</a> = <a class="el" href="classDynExp_1_1InstrumentConfiguratorBase.html">InstrumentConfiguratorBase</a></td></tr>
<tr class="memdesc:ab07cbb563d629d268b51c5eae3fefef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1InstrumentBase.html#ab07cbb563d629d268b51c5eae3fefef6">More...</a><br /></td></tr>
<tr class="separator:ab07cbb563d629d268b51c5eae3fefef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39ddd8504937d372dedf01dfcda27cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a> = <a class="el" href="classDynExp_1_1InstrumentDataBase.html">InstrumentDataBase</a></td></tr>
<tr class="memdesc:aa39ddd8504937d372dedf01dfcda27cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the data class belonging to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> type. Declare this alias in every derived class with the respective data class accompanying the derived <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>.  <a href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">More...</a><br /></td></tr>
<tr class="separator:aa39ddd8504937d372dedf01dfcda27cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cfe7c8a66f8184e7063977a8e4a836"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentDataTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a> &gt;</td></tr>
<tr class="memdesc:ab1cfe7c8a66f8184e7063977a8e4a836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of <a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">InstrumentBase::GetInstrumentData()</a>. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">More...</a><br /></td></tr>
<tr class="separator:ab1cfe7c8a66f8184e7063977a8e4a836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0557a21acb8ff50786d3addc5a1fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">InstrumentDataTypeSyncPtrConstType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; const <a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a> &gt;</td></tr>
<tr class="memdesc:a1af0557a21acb8ff50786d3addc5a1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of InstrumentBase::GetInstrumentData() const. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">More...</a><br /></td></tr>
<tr class="separator:a1af0557a21acb8ff50786d3addc5a1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">gRPC aliases</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Redefine in derived meta instrument classes to use them in <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html" title="Meta instrument template for transforming meta instruments into network instruments,...">DynExpInstr::gRPCInstrument</a>. </p>
</div></td></tr>
<tr class="memitem:af2e1afbc083245efdb4c87a9a0670639"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#af2e1afbc083245efdb4c87a9a0670639">InitTaskType</a> = <a class="el" href="classDynExp_1_1InitTaskBase.html">InitTaskBase</a></td></tr>
<tr class="memdesc:af2e1afbc083245efdb4c87a9a0670639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task for initializing an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by an initialization task class derived from <code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1InitTaskBase.html#a1b2737990a3c0ecc97b9a8a2bef6cf65" title="Initializes the respective instrument within the instrument inheritance hierarchy....">InitTaskBase::InitFuncImpl()</a> of the derived instrument's initialization task class.  <a href="classDynExp_1_1InstrumentBase.html#af2e1afbc083245efdb4c87a9a0670639">More...</a><br /></td></tr>
<tr class="separator:af2e1afbc083245efdb4c87a9a0670639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a47c49a7d2700525e413dbfa149974"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a66a47c49a7d2700525e413dbfa149974">ExitTaskType</a> = <a class="el" href="classDynExp_1_1ExitTaskBase.html">ExitTaskBase</a></td></tr>
<tr class="memdesc:a66a47c49a7d2700525e413dbfa149974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task for deinitializing an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by a deinitialization task class derived from <code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1ExitTaskBase.html#ade32a093ce314c193622d5b36c68a826" title="Deinitializes the respective instrument within the instrument inheritance hierarchy....">ExitTaskBase::ExitFuncImpl()</a> of the derived instrument's deinitialization task class.  <a href="classDynExp_1_1InstrumentBase.html#a66a47c49a7d2700525e413dbfa149974">More...</a><br /></td></tr>
<tr class="separator:a66a47c49a7d2700525e413dbfa149974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba18030aa4a0fcd0eeafadbef629d34c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#aba18030aa4a0fcd0eeafadbef629d34c">UpdateTaskType</a> = <a class="el" href="classDynExp_1_1UpdateTaskBase.html">UpdateTaskBase</a></td></tr>
<tr class="memdesc:aba18030aa4a0fcd0eeafadbef629d34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task for updating an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by an update task class derived from <code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1UpdateTaskBase.html#af23c4a712115c7b2375257a279c6efdb" title="Updates the respective instrument within the instrument inheritance hierarchy. Call UpdateFuncImpl() ...">UpdateTaskBase::UpdateFuncImpl()</a> of the derived instrument's update task class.  <a href="classDynExp_1_1InstrumentBase.html#aba18030aa4a0fcd0eeafadbef629d34c">More...</a><br /></td></tr>
<tr class="separator:aba18030aa4a0fcd0eeafadbef629d34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a0c2032af7cd592f2333234b2f5b854eb inherit pub_types_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a0c2032af7cd592f2333234b2f5b854eb">ParamsType</a> = <a class="el" href="classDynExp_1_1RunnableObjectParams.html">RunnableObjectParams</a></td></tr>
<tr class="memdesc:a0c2032af7cd592f2333234b2f5b854eb inherit pub_types_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1RunnableObject.html#a0c2032af7cd592f2333234b2f5b854eb">More...</a><br /></td></tr>
<tr class="separator:a0c2032af7cd592f2333234b2f5b854eb inherit pub_types_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5466b09b2bf0fb4d5ca625629b5d797 inherit pub_types_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#ac5466b09b2bf0fb4d5ca625629b5d797">ConfigType</a> = <a class="el" href="classDynExp_1_1RunnableObjectConfigurator.html">RunnableObjectConfigurator</a></td></tr>
<tr class="memdesc:ac5466b09b2bf0fb4d5ca625629b5d797 inherit pub_types_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1RunnableObject.html#ac5466b09b2bf0fb4d5ca625629b5d797">More...</a><br /></td></tr>
<tr class="separator:ac5466b09b2bf0fb4d5ca625629b5d797 inherit pub_types_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> = <a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a></td></tr>
<tr class="memdesc:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">More...</a><br /></td></tr>
<tr class="separator:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; <a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> &gt;</td></tr>
<tr class="memdesc:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a>. Parameters wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">More...</a><br /></td></tr>
<tr class="separator:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">ParamsConstTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; const <a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> &gt;</td></tr>
<tr class="memdesc:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of Object::GetParams() const. Parameters wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">More...</a><br /></td></tr>
<tr class="separator:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1e4cd6bac98bce47b148e267079f21e9">ConfigType</a> = <a class="el" href="classDynExp_1_1ConfiguratorBase.html">ConfiguratorBase</a></td></tr>
<tr class="memdesc:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1Object.html#a1e4cd6bac98bce47b148e267079f21e9">More...</a><br /></td></tr>
<tr class="separator:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a935874e227bc5bcb039052df45cad956">ParamsGetterType</a> = <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, decltype(&amp;<a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">Object::GetParams</a>)&gt;</td></tr>
<tr class="memdesc:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with.  <a href="classDynExp_1_1Object.html#a935874e227bc5bcb039052df45cad956">More...</a><br /></td></tr>
<tr class="separator:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a426093fafaf12e96a612dc9afc7b5b9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a426093fafaf12e96a612dc9afc7b5b9a">InstrumentBase</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a426093fafaf12e96a612dc9afc7b5b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instrument instance.  <a href="classDynExp_1_1InstrumentBase.html#a426093fafaf12e96a612dc9afc7b5b9a">More...</a><br /></td></tr>
<tr class="separator:a426093fafaf12e96a612dc9afc7b5b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b31ed302dc6e962d85d7a5bcbc8b7d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ad0b31ed302dc6e962d85d7a5bcbc8b7d">~InstrumentBase</a> ()=0</td></tr>
<tr class="separator:ad0b31ed302dc6e962d85d7a5bcbc8b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86e1f4f45de725995b3f0ecbcd2dca3"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ae86e1f4f45de725995b3f0ecbcd2dca3">GetCategory</a> () const override</td></tr>
<tr class="memdesc:ae86e1f4f45de725995b3f0ecbcd2dca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the category of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type.  <a href="classDynExp_1_1InstrumentBase.html#ae86e1f4f45de725995b3f0ecbcd2dca3">More...</a><br /></td></tr>
<tr class="separator:ae86e1f4f45de725995b3f0ecbcd2dca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e876c26afcccb0d8f3555f7b7b9b5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedInstrT , typename... TaskFuncArgTs, typename... ArgTs&gt; </td></tr>
<tr class="memitem:ab98e876c26afcccb0d8f3555f7b7b9b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1ExceptionContainer.html">ExceptionContainer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5">AsSyncTask</a> (void(DerivedInstrT::*TaskFunc)(TaskFuncArgTs...) const, ArgTs &amp;&amp;...Args) const</td></tr>
<tr class="memdesc:ab98e876c26afcccb0d8f3555f7b7b9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a (derived) instrument's function which inserts a task into the instrument's task queue synchronously. This means that <code><a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5" title="Calls a (derived) instrument&#39;s function which inserts a task into the instrument&#39;s task queue synchro...">AsSyncTask()</a></code> blocks until the task has been executed or aborted. This is achieved by passing a callback function to the task which in turn sets a flag after the task execution. The thread calling <code><a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5" title="Calls a (derived) instrument&#39;s function which inserts a task into the instrument&#39;s task queue synchro...">AsSyncTask()</a></code> blocks (via <code>std::this_thread::yield()</code>) until this flag is set.  <a href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5">More...</a><br /></td></tr>
<tr class="separator:ab98e876c26afcccb0d8f3555f7b7b9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a5e3f33a83b1a9b1d2c8fea2ebe18d8f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a5e3f33a83b1a9b1d2c8fea2ebe18d8f1">RunnableObject</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a5e3f33a83b1a9b1d2c8fea2ebe18d8f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1RunnableObject.html#a5e3f33a83b1a9b1d2c8fea2ebe18d8f1">More...</a><br /></td></tr>
<tr class="separator:a5e3f33a83b1a9b1d2c8fea2ebe18d8f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee536858f410d08629c44493fe840a inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a75ee536858f410d08629c44493fe840a">~RunnableObject</a> ()=0</td></tr>
<tr class="separator:a75ee536858f410d08629c44493fe840a inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4736ee64946008136525afe5f7250eb inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#af4736ee64946008136525afe5f7250eb">SetPaused</a> (bool Pause, std::string Description=&quot;&quot;)</td></tr>
<tr class="memdesc:af4736ee64946008136525afe5f7250eb inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses or resumes a <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance. Its thread stays running, but the instance does not perform any action while it is paused.  <a href="classDynExp_1_1RunnableObject.html#af4736ee64946008136525afe5f7250eb">More...</a><br /></td></tr>
<tr class="separator:af4736ee64946008136525afe5f7250eb inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af963d89b1f862ec1487243b582e4292b inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#af963d89b1f862ec1487243b582e4292b">IsRunning</a> () const noexcept</td></tr>
<tr class="memdesc:af963d89b1f862ec1487243b582e4292b inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#a14503e0c26947af03db4d24dbd90630f" title="Indicates whether the RunnableObject instance is running.">Running</a>.  <a href="classDynExp_1_1RunnableObject.html#af963d89b1f862ec1487243b582e4292b">More...</a><br /></td></tr>
<tr class="separator:af963d89b1f862ec1487243b582e4292b inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdc273407c6b72ff8f44b3420d1bd4e inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aabdc273407c6b72ff8f44b3420d1bd4e">IsPaused</a> () const noexcept</td></tr>
<tr class="memdesc:aabdc273407c6b72ff8f44b3420d1bd4e inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#a9d31acb25204f3e22bac761e9a8cd645" title="Indicates whether the RunnableObject instance is paused.">Paused</a>.  <a href="classDynExp_1_1RunnableObject.html#aabdc273407c6b72ff8f44b3420d1bd4e">More...</a><br /></td></tr>
<tr class="separator:aabdc273407c6b72ff8f44b3420d1bd4e inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa68571b91bbfa501c2a571ef0945d03 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aaa68571b91bbfa501c2a571ef0945d03">IsExiting</a> () const noexcept</td></tr>
<tr class="memdesc:aaa68571b91bbfa501c2a571ef0945d03 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#aa2e7e86495da4f938eaaca0774b21abd" title="Indicates whether this RunnableObject instance&#39;s thread should terminate.">ShouldExit</a>.  <a href="classDynExp_1_1RunnableObject.html#aaa68571b91bbfa501c2a571ef0945d03">More...</a><br /></td></tr>
<tr class="separator:aaa68571b91bbfa501c2a571ef0945d03 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e529b916c8fd4b2a1b89d888bd134c inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a43e529b916c8fd4b2a1b89d888bd134c">GetStartupType</a> () const noexcept</td></tr>
<tr class="memdesc:a43e529b916c8fd4b2a1b89d888bd134c inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#a90c4c0e78078946252ade4c3f0fc088a" title="Reflects the value of RunnableObjectParams::Startup. This variable is only updated when Run() is call...">Startup</a>.  <a href="classDynExp_1_1RunnableObject.html#a43e529b916c8fd4b2a1b89d888bd134c">More...</a><br /></td></tr>
<tr class="separator:a43e529b916c8fd4b2a1b89d888bd134c inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb2e71639fdcab42c9c6c299e4cf2b8 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#adbb2e71639fdcab42c9c6c299e4cf2b8">GetReasonWhyPaused</a> () const</td></tr>
<tr class="memdesc:adbb2e71639fdcab42c9c6c299e4cf2b8 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#aacef09883d7d4462fc014330663d9f4f" title="Holds information about why the RunnableObject instance is paused.">ReasonWhyPaused</a>.  <a href="classDynExp_1_1RunnableObject.html#adbb2e71639fdcab42c9c6c299e4cf2b8">More...</a><br /></td></tr>
<tr class="separator:adbb2e71639fdcab42c9c6c299e4cf2b8 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416b8000830913b11eaf02d1f1af49d6 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6">Run</a> (QWidget *ParentWidget=nullptr)</td></tr>
<tr class="memdesc:a416b8000830913b11eaf02d1f1af49d6 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread and ensures that all <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instances linked to this instance via <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> parameters are in a ready state. Calls <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a></code> which is to be overridden by derived classes to start a thread and to pass this thread back by calling <code><a class="el" href="classDynExp_1_1RunnableObject.html#aac70e1485923ee8c78ed5732099b4c90" title="Stores a thread constructed by a derived class overriding RunChild() in Thread taking ownership of th...">StoreThread()</a></code>.  <a href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6">More...</a><br /></td></tr>
<tr class="separator:a416b8000830913b11eaf02d1f1af49d6 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8275b7f99072059d5608a4201ed579af inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a8275b7f99072059d5608a4201ed579af">RunIfRunAutomatic</a> ()</td></tr>
<tr class="memdesc:a8275b7f99072059d5608a4201ed579af inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> if <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a1ef775df6c01b554f3c102024646c0dd" title="Determines when the runnable object is started. Refer to RunnableObjectParams::StartupType.">RunnableObjectParams::Startup</a> is set to <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a33b475bb5737bca9bf78ce6a6a7c41f4af69add31b7e16e98b1fa4642036b1bfc">RunnableObjectParams::Automatic</a>.  <a href="classDynExp_1_1RunnableObject.html#a8275b7f99072059d5608a4201ed579af">More...</a><br /></td></tr>
<tr class="separator:a8275b7f99072059d5608a4201ed579af inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4a5c01c205de78aaf9269f07b87f97 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#afa4a5c01c205de78aaf9269f07b87f97">RunIfRunOnCreation</a> ()</td></tr>
<tr class="memdesc:afa4a5c01c205de78aaf9269f07b87f97 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> if <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a1ef775df6c01b554f3c102024646c0dd" title="Determines when the runnable object is started. Refer to RunnableObjectParams::StartupType.">RunnableObjectParams::Startup</a> is set to <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a33b475bb5737bca9bf78ce6a6a7c41f4ad34691b5a53a925e88d07542d5cadf8f">RunnableObjectParams::OnCreation</a>.  <a href="classDynExp_1_1RunnableObject.html#afa4a5c01c205de78aaf9269f07b87f97">More...</a><br /></td></tr>
<tr class="separator:afa4a5c01c205de78aaf9269f07b87f97 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae3d704e86c69825835ba35399d87f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1">Terminate</a> (bool Force=false, const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1RunnableObject.html#a0a4195a66ff3a00a8d9d523d5783e5ad">TerminateTimeoutDefault</a>)</td></tr>
<tr class="memdesc:afae3d704e86c69825835ba35399d87f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread to terminate and waits until it has ended. Calls <a class="el" href="classDynExp_1_1RunnableObject.html#a9bc1c98af72a500c1e916c65c33b5464" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">TerminateImpl()</a>.  <a href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1">More...</a><br /></td></tr>
<tr class="separator:afae3d704e86c69825835ba35399d87f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classUtil_1_1INonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classUtil_1_1INonCopyable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memitem:ad1604a205a9a18f20c51f04327079243 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#ad1604a205a9a18f20c51f04327079243">INonCopyable</a> (const <a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:ad1604a205a9a18f20c51f04327079243 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fdb9f2928ae66d61f51499bc893e78 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a66fdb9f2928ae66d61f51499bc893e78">operator=</a> (const <a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:a66fdb9f2928ae66d61f51499bc893e78 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a3d16fbb9394b595905e28ba9291ac402">GetID</a> () const noexcept</td></tr>
<tr class="memdesc:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. Thread-safe since ID is const.  <a href="classDynExp_1_1Object.html#a3d16fbb9394b595905e28ba9291ac402">More...</a><br /></td></tr>
<tr class="separator:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1a9d46583b415dabe8a41b774f5e0db9">GetCategoryAndName</a> () const</td></tr>
<tr class="memdesc:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string from an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> category and name to allow the user to identify an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> type.  <a href="classDynExp_1_1Object.html#a1a9d46583b415dabe8a41b774f5e0db9">More...</a><br /></td></tr>
<tr class="separator:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5061381dd74b8278624d6f004021db8">EnsureReadyState</a> (bool IsAutomaticStartup)</td></tr>
<tr class="memdesc:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready by possibly starting its worker thread or by opening connections to hardware devices.  <a href="classDynExp_1_1Object.html#ac5061381dd74b8278624d6f004021db8">More...</a><br /></td></tr>
<tr class="separator:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#afd2469a30700f322ae28374cf48a8ba7">CheckLinkedObjectStates</a> () const</td></tr>
<tr class="memdesc:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instances this instance uses are in a ready state. Override <code><a class="el" href="classDynExp_1_1Object.html#a8a0fd11d2dc276253b9ec9d710acb864" title="Override to implement a check whether linked objects are in a ready state.">CheckLinkedObjectStatesChild()</a></code> to implement this behavior.  <a href="classDynExp_1_1Object.html#afd2469a30700f322ae28374cf48a8ba7">More...</a><br /></td></tr>
<tr class="separator:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46">Reset</a> ()</td></tr>
<tr class="memdesc:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance (including all its derived classes) by calling <code><a class="el" href="classDynExp_1_1Object.html#a53b82dbe7ee6bb4e9b948c462fffc964" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code>. A reset implies that the derived classes reload all their parameters from <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> and that all <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instances owned by this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance become invalidated.  <a href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46">More...</a><br /></td></tr>
<tr class="separator:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a5ad8b51f8e38c57a48a408b0ee813143">BlockIfUnused</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>)</td></tr>
<tr class="memdesc:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance setting <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a> to true. Refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a> for the consequences.  <a href="classDynExp_1_1Object.html#a5ad8b51f8e38c57a48a408b0ee813143">More...</a><br /></td></tr>
<tr class="separator:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">ParamsConstTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">GetParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the parameter class instance <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a>.  <a href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">More...</a><br /></td></tr>
<tr class="separator:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a96ef443e2da7a0c95eccbdf0a5d4d0c1">GetParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>)</td></tr>
<tr class="memdesc:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the parameter class instance <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a>.  <a href="classDynExp_1_1Object.html#a96ef443e2da7a0c95eccbdf0a5d4d0c1">More...</a><br /></td></tr>
<tr class="separator:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ad525cf93f649e6edc5c31c5f16476a43">GetObjectName</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1Object.html#ad525cf93f649e6edc5c31c5f16476a43">More...</a><br /></td></tr>
<tr class="separator:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#acc8cf73407e49b40b7429bf9ad018235">IsSharedUsageEnabled</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether shared usage has been enabled for this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. Refer to <a class="el" href="classDynExp_1_1ParamsBase.html#abad5385ae3558b535ee831ca37e16616" title="Determines whether an Object can be linked to only one (unique) or multiple (shared) other objects.">ParamsBase::UsageType</a>.  <a href="classDynExp_1_1Object.html#acc8cf73407e49b40b7429bf9ad018235">More...</a><br /></td></tr>
<tr class="separator:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1244d53367db00489c98b06d1c3cf221">SetWarning</a> (std::string Description, int ErrorCode) const</td></tr>
<tr class="memdesc:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>. Sets the warning by a description and an error code.  <a href="classDynExp_1_1Object.html#a1244d53367db00489c98b06d1c3cf221">More...</a><br /></td></tr>
<tr class="separator:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af8005025d4b226d97490c0a0581a610f">SetWarning</a> (const <a class="el" href="classUtil_1_1Exception.html">Util::Exception</a> &amp;e) const</td></tr>
<tr class="memdesc:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>. Sets the warning by retrieving the warning data from an exception <code>e</code>.  <a href="classDynExp_1_1Object.html#af8005025d4b226d97490c0a0581a610f">More...</a><br /></td></tr>
<tr class="separator:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a7584b53df46340e83301d76e5ca85ba3">ClearWarning</a> () const</td></tr>
<tr class="memdesc:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>.  <a href="classDynExp_1_1Object.html#a7584b53df46340e83301d76e5ca85ba3">More...</a><br /></td></tr>
<tr class="separator:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#aa696a7ed149a758d7ba5943834ca19f1">GetWarning</a> () const</td></tr>
<tr class="memdesc:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a> in a thread-safe way by copying its internal data.  <a href="classDynExp_1_1Object.html#aa696a7ed149a758d7ba5943834ca19f1">More...</a><br /></td></tr>
<tr class="separator:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5f18675231275acf933b5989b8811cc">GetException</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the exception which has caused this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to fail.  <a href="classDynExp_1_1Object.html#ac5f18675231275acf933b5989b8811cc">More...</a><br /></td></tr>
<tr class="separator:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#aab58ec8b7377ac5082e376bd9d82dba1">IsReady</a> () const</td></tr>
<tr class="memdesc:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>).  <a href="classDynExp_1_1Object.html#aab58ec8b7377ac5082e376bd9d82dba1">More...</a><br /></td></tr>
<tr class="separator:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a41b950acea065c13b4899d7c9a12048d">GetUseCount</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the registered useres in a thread-safe way.  <a href="classDynExp_1_1Object.html#a41b950acea065c13b4899d7c9a12048d">More...</a><br /></td></tr>
<tr class="separator:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a73f9e22dafdeab31ebeb6859c51da546">IsUnused</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is used by other instances.  <a href="classDynExp_1_1Object.html#a73f9e22dafdeab31ebeb6859c51da546">More...</a><br /></td></tr>
<tr class="separator:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a393f14bb1759eef2fe956a792243dc8b">GetUserIDs</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the IDs of the registered users in a thread-safe way.  <a href="classDynExp_1_1Object.html#a393f14bb1759eef2fe956a792243dc8b">More...</a><br /></td></tr>
<tr class="separator:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a542639f48d6826b0546362fb4078256b">GetUserNamesString</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string describing which users are registered containing their object names, categories and type names in a thread-safe way.  <a href="classDynExp_1_1Object.html#a542639f48d6826b0546362fb4078256b">More...</a><br /></td></tr>
<tr class="separator:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057f86e9ceec0f7e709e720f66cbb7fb inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a057f86e9ceec0f7e709e720f66cbb7fb">GetName</a> () const =0</td></tr>
<tr class="memdesc:a057f86e9ceec0f7e709e720f66cbb7fb inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type.  <a href="classDynExp_1_1Object.html#a057f86e9ceec0f7e709e720f66cbb7fb">More...</a><br /></td></tr>
<tr class="separator:a057f86e9ceec0f7e709e720f66cbb7fb inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a42e8b5062372e04c6b2aa66e3d9ad3e9"><td class="memItemLeft" align="right" valign="top">constexpr static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a42e8b5062372e04c6b2aa66e3d9ad3e9">Category</a> () noexcept</td></tr>
<tr class="memdesc:a42e8b5062372e04c6b2aa66e3d9ad3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every derived class has to redefine this function.  <a href="classDynExp_1_1InstrumentBase.html#a42e8b5062372e04c6b2aa66e3d9ad3e9">More...</a><br /></td></tr>
<tr class="separator:a42e8b5062372e04c6b2aa66e3d9ad3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af55298b0589b9239ff3076d540c97449">CategoryAndNameToStr</a> (const std::string &amp;Category, const std::string &amp;Name)</td></tr>
<tr class="memdesc:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string from an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> category and name to allow the user to identify an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> type.  <a href="classDynExp_1_1Object.html#af55298b0589b9239ff3076d540c97449">More...</a><br /></td></tr>
<tr class="separator:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab356af07c76602059ea91367c4b36a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1InstrumentBase_1_1InstrumenThreadOnlyType.html">InstrumenThreadOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab356af07c76602059ea91367c4b36a76">InstrumentThreadOnly</a></td></tr>
<tr class="memdesc:ab356af07c76602059ea91367c4b36a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a>'s</code> private methods to the instrument thread <code><a class="el" href="namespaceDynExp.html#a6985987f0ba5cd7ab42caef76ac995c9" title="Instruments run in their own thread. This is the instrument thread&#39;s main function.">InstrumentThreadMain()</a></code>.  <a href="classDynExp_1_1InstrumentBase.html#ab356af07c76602059ea91367c4b36a76">More...</a><br /></td></tr>
<tr class="separator:ab356af07c76602059ea91367c4b36a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:acb2919ca14c007ca6bb3d7fe02ef02a4 inherit pub_attribs_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1RunnableObject_1_1RunnableInstanceOnlyType.html">RunnableInstanceOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#acb2919ca14c007ca6bb3d7fe02ef02a4">RunnableInstanceOnly</a></td></tr>
<tr class="memdesc:acb2919ca14c007ca6bb3d7fe02ef02a4 inherit pub_attribs_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a>'s</code> private methods to class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>.  <a href="classDynExp_1_1RunnableObject.html#acb2919ca14c007ca6bb3d7fe02ef02a4">More...</a><br /></td></tr>
<tr class="separator:acb2919ca14c007ca6bb3d7fe02ef02a4 inherit pub_attribs_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object_1_1LinkedObjectWrapperOnlyType.html">LinkedObjectWrapperOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a4428d406d0477fc605a2d27dc4ac409c">LinkedObjectWrapperOnly</a></td></tr>
<tr class="memdesc:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> private methods to any LinkedObjectWrapper&lt;T&gt;.  <a href="classDynExp_1_1Object.html#a4428d406d0477fc605a2d27dc4ac409c">More...</a><br /></td></tr>
<tr class="separator:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8b9520a15e9c675fa6c9740d7713700b"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a> = std::chrono::milliseconds(1000)</td></tr>
<tr class="memdesc:a8b9520a15e9c675fa6c9740d7713700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the default timeout for <code><a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">GetInstrumentData()</a></code> to lock the mutex synchronizing the instrument's data <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>.  <a href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">More...</a><br /></td></tr>
<tr class="separator:a8b9520a15e9c675fa6c9740d7713700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a8755819fc4e5d8c91ad03ba043c93414 inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a8755819fc4e5d8c91ad03ba043c93414">ShortTimeoutDefault</a> = std::chrono::milliseconds(50)</td></tr>
<tr class="memdesc:a8755819fc4e5d8c91ad03ba043c93414 inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout e.g. used as a default for calls to <a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">InstrumentBase::GetInstrumentData</a> or <a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">ModuleBase::GetModuleData</a>.  <a href="classDynExp_1_1RunnableObject.html#a8755819fc4e5d8c91ad03ba043c93414">More...</a><br /></td></tr>
<tr class="separator:a8755819fc4e5d8c91ad03ba043c93414 inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4195a66ff3a00a8d9d523d5783e5ad inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a0a4195a66ff3a00a8d9d523d5783e5ad">TerminateTimeoutDefault</a> = std::chrono::milliseconds(3000)</td></tr>
<tr class="memdesc:a0a4195a66ff3a00a8d9d523d5783e5ad inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout used as a default for calls to <a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">RunnableObject::Terminate</a>.  <a href="classDynExp_1_1RunnableObject.html#a0a4195a66ff3a00a8d9d523d5783e5ad">More...</a><br /></td></tr>
<tr class="separator:a0a4195a66ff3a00a8d9d523d5783e5ad inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a> = std::chrono::milliseconds(100)</td></tr>
<tr class="memdesc:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout used by <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a> to lock the mutex of the parameter instance assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">More...</a><br /></td></tr>
<tr class="separator:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a79720764a29399e353ab328ea3586bd6"><td class="memTemplParams" colspan="2">template&lt;typename TaskT , typename... ArgTs&gt; </td></tr>
<tr class="memitem:a79720764a29399e353ab328ea3586bd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a79720764a29399e353ab328ea3586bd6">MakeAndEnqueueTask</a> (ArgTs &amp;&amp;...Args) const</td></tr>
<tr class="memdesc:a79720764a29399e353ab328ea3586bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="namespaceDynExp.html#a55081837e3f131e681effbd762886ca8" title="Factory function to create a task to be enqueued in an instrument&#39;s task queue.">MakeTask()</a></code> to construct a new task and subsequently enqueues the task into the instrument's task queue. Logical const-ness: this is a const member function to allow pointers to <code>const</code> <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> inserting tasks into the instrument's task queue. These kind of pointers are e.g. returned by <a class="el" href="classDynExp_1_1RunnableInstance.html#af58777edf59b61db1049e096383ee392" title="Returns Owner.">RunnableInstance::GetOwner()</a> which can be called by tasks' <a class="el" href="classDynExp_1_1TaskBase.html#a3d10e90516b0e6f26ef5b5a20d8322be" title="Runs the task. Override RunChild() to define a derived task&#39;s action(s). Any exception leaving RunChi...">TaskBase::RunChild()</a> functions. For <code>const</code> <code>InstrumentBase*</code>, it is possible to insert tasks into the task queue, but not to change the <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> object itself (e.g. calling <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a>).  <a href="classDynExp_1_1InstrumentBase.html#a79720764a29399e353ab328ea3586bd6">More...</a><br /></td></tr>
<tr class="separator:a79720764a29399e353ab328ea3586bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a39ef8e00794211e897f2d50905639772 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a39ef8e00794211e897f2d50905639772">Init</a> ()</td></tr>
<tr class="memdesc:a39ef8e00794211e897f2d50905639772 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes member variables in case of a reset.  <a href="classDynExp_1_1RunnableObject.html#a39ef8e00794211e897f2d50905639772">More...</a><br /></td></tr>
<tr class="separator:a39ef8e00794211e897f2d50905639772 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a89773cf56f3c229dd9c141de12ab3 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">std::promise&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a28a89773cf56f3c229dd9c141de12ab3">MakeThreadExitedPromise</a> ()</td></tr>
<tr class="memdesc:a28a89773cf56f3c229dd9c141de12ab3 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to be used by overridden <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a></code> functions in derived classes to (re)initialize the <a class="el" href="classDynExp_1_1RunnableObject.html#a45a818a181d16129dfb43080152527c4" title="Future which signals that Thread has terminated. Refer to OnThreadHasExited().">ThreadExitedSignal</a> future and to provide the derived class a promise to signal the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance that its thread has terminated.  <a href="classDynExp_1_1RunnableObject.html#a28a89773cf56f3c229dd9c141de12ab3">More...</a><br /></td></tr>
<tr class="separator:a28a89773cf56f3c229dd9c141de12ab3 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac70e1485923ee8c78ed5732099b4c90 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aac70e1485923ee8c78ed5732099b4c90">StoreThread</a> (std::thread &amp;&amp;<a class="el" href="classDynExp_1_1RunnableObject.html#a7f653f6a7407d6a69dd9d75858d6b363">Thread</a>) noexcept</td></tr>
<tr class="memdesc:aac70e1485923ee8c78ed5732099b4c90 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a thread constructed by a derived class overriding <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a></code> in <code>Thread</code> taking ownership of the thread. Only call this function within <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a>!</code>  <a href="classDynExp_1_1RunnableObject.html#aac70e1485923ee8c78ed5732099b4c90">More...</a><br /></td></tr>
<tr class="separator:aac70e1485923ee8c78ed5732099b4c90 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fc682e09f7e23e2a65fc8b8eef7106 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a21fc682e09f7e23e2a65fc8b8eef7106">IsCallFromRunnableThread</a> () const</td></tr>
<tr class="memdesc:a21fc682e09f7e23e2a65fc8b8eef7106 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>Thread's</code> id matches the id of the calling thread. This is thread-safe if the function is called by the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread since <code><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">Terminate()</a></code> joins the threads before changing the <code>Thread</code> member. It is also thread-safe if the function is called by the thread owning the the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance since <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> and <code><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">Terminate()</a></code> can only be called by this thread. Only <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> and <code><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">Terminate()</a></code> (indirectly) modify <code>Thread</code>.  <a href="classDynExp_1_1RunnableObject.html#a21fc682e09f7e23e2a65fc8b8eef7106">More...</a><br /></td></tr>
<tr class="separator:a21fc682e09f7e23e2a65fc8b8eef7106 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb143a7fd58432e344ab53a2f8f41ae2 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aeb143a7fd58432e344ab53a2f8f41ae2">EnsureCallFromRunnableThread</a> () const</td></tr>
<tr class="memdesc:aeb143a7fd58432e344ab53a2f8f41ae2 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the call to this function is performed from the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread by calling <a class="el" href="classDynExp_1_1RunnableObject.html#a21fc682e09f7e23e2a65fc8b8eef7106" title="Checks whether Thread&#39;s id matches the id of the calling thread. This is thread-safe if the function ...">IsCallFromRunnableThread()</a>.  <a href="classDynExp_1_1RunnableObject.html#aeb143a7fd58432e344ab53a2f8f41ae2">More...</a><br /></td></tr>
<tr class="separator:aeb143a7fd58432e344ab53a2f8f41ae2 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4faad6fc3ff1e9b398b61a5d3a7f586 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#ae4faad6fc3ff1e9b398b61a5d3a7f586">SetReasonWhyPaused</a> (std::string Description)</td></tr>
<tr class="memdesc:ae4faad6fc3ff1e9b398b61a5d3a7f586 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason why this <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance has been paused.  <a href="classDynExp_1_1RunnableObject.html#ae4faad6fc3ff1e9b398b61a5d3a7f586">More...</a><br /></td></tr>
<tr class="separator:ae4faad6fc3ff1e9b398b61a5d3a7f586 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505a71aea1cac9f7625784095f8ff7f inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a5505a71aea1cac9f7625784095f8ff7f">SetReasonWhyPaused</a> (const <a class="el" href="classUtil_1_1Exception.html">Util::Exception</a> &amp;e)</td></tr>
<tr class="memdesc:a5505a71aea1cac9f7625784095f8ff7f inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason why this <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance has been paused.  <a href="classDynExp_1_1RunnableObject.html#a5505a71aea1cac9f7625784095f8ff7f">More...</a><br /></td></tr>
<tr class="separator:a5505a71aea1cac9f7625784095f8ff7f inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cadbf7dbaff94692a73ddbf1ab8c28 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#ae0cadbf7dbaff94692a73ddbf1ab8c28">ClearReasonWhyPaused</a> ()</td></tr>
<tr class="memdesc:ae0cadbf7dbaff94692a73ddbf1ab8c28 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the reason why this <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance has been paused (since it is resumed).  <a href="classDynExp_1_1RunnableObject.html#ae0cadbf7dbaff94692a73ddbf1ab8c28">More...</a><br /></td></tr>
<tr class="separator:ae0cadbf7dbaff94692a73ddbf1ab8c28 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classUtil_1_1INonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classUtil_1_1INonCopyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memitem:a4442a7fe15262e3ad291220b0af2cd0b inherit pro_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a4442a7fe15262e3ad291220b0af2cd0b">INonCopyable</a> ()=default</td></tr>
<tr class="separator:a4442a7fe15262e3ad291220b0af2cd0b inherit pro_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f837dbc82c4bbf3905900ed59d30152 inherit pro_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a8f837dbc82c4bbf3905900ed59d30152">~INonCopyable</a> ()=default</td></tr>
<tr class="separator:a8f837dbc82c4bbf3905900ed59d30152 inherit pro_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a10164159ffa218cb580e98cbdc1d49a2">Object</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1Object.html#a10164159ffa218cb580e98cbdc1d49a2">More...</a><br /></td></tr>
<tr class="separator:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477148f8a4a1b829edbb96ca03bfaaa2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a477148f8a4a1b829edbb96ca03bfaaa2">~Object</a> ()=0</td></tr>
<tr class="separator:a477148f8a4a1b829edbb96ca03bfaaa2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af6fde3f79ccf7e596889176af39ab6b2">EnsureCallFromOwningThread</a> () const</td></tr>
<tr class="memdesc:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the call to this function is performed from the thread which constructed this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance (the thread with the id stored in <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd" title="Thread id of the thread which has constructed (and owns) this Object instance.">Object::OwnerThreadID</a>).  <a href="classDynExp_1_1Object.html#af6fde3f79ccf7e596889176af39ab6b2">More...</a><br /></td></tr>
<tr class="separator:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a98a7bb1553e393adbc62d28911d82f42">GetNonConstParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows derived <code>Objects</code> to edit their own parameters - even in const task functions (for instruments) or event functions (for modules).  <a href="classDynExp_1_1Object.html#a98a7bb1553e393adbc62d28911d82f42">More...</a><br /></td></tr>
<tr class="separator:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af6f3ec1d9b22c4699e344d58ab7a873c">LockUserList</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>)</td></tr>
<tr class="memdesc:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the user list for thread-safe manipulation.  <a href="classDynExp_1_1Object.html#af6f3ec1d9b22c4699e344d58ab7a873c">More...</a><br /></td></tr>
<tr class="separator:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5f51f73ef153e261856790b5a9e8870">DeregisterAllUnsafe</a> ()</td></tr>
<tr class="memdesc:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregisters all users and notifies them that they need to check the states of their used linked objects.  <a href="classDynExp_1_1Object.html#ac5f51f73ef153e261856790b5a9e8870">More...</a><br /></td></tr>
<tr class="separator:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0517857d7390e4a40c0bfbf47ac85e2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ab0517857d7390e4a40c0bfbf47ac85e2">GetUseCountUnsafe</a> ()</td></tr>
<tr class="separator:ab0517857d7390e4a40c0bfbf47ac85e2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b2f15f8129c30d4d3525b187e7ed2b inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a76b2f15f8129c30d4d3525b187e7ed2b">GetUserNamesStringUnsafe</a> () const</td></tr>
<tr class="separator:a76b2f15f8129c30d4d3525b187e7ed2b inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a61de80a7326bf7bf35700e9e76d7ea45">IsUnusedUnsafe</a> ()</td></tr>
<tr class="memdesc:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is used by other instances (not thread-safe).  <a href="classDynExp_1_1Object.html#a61de80a7326bf7bf35700e9e76d7ea45">More...</a><br /></td></tr>
<tr class="separator:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a02203d17d10533482296eda9dae7be52"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a02203d17d10533482296eda9dae7be52">GetExceptionUnsafe</a> (const <a class="el" href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">InstrumentDataTypeSyncPtrConstType</a> &amp;InstrumentDataPtr)</td></tr>
<tr class="memdesc:a02203d17d10533482296eda9dae7be52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="classDynExp_1_1InstrumentDataBase.html#addd7549bebc1fe974bf367cfdc01645e" title="Used to transfer exceptions from the instrument thread to the main thread. Stores the exception respo...">InstrumentDataBase::InstrumentException</a>.  <a href="classDynExp_1_1InstrumentBase.html#a02203d17d10533482296eda9dae7be52">More...</a><br /></td></tr>
<tr class="separator:a02203d17d10533482296eda9dae7be52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a202de6f18f2336f9c45d69773e059d2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a202de6f18f2336f9c45d69773e059d2c">ResetImpl</a> (<a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1RunnableObject.html">RunnableObject</a> &gt;) override final</td></tr>
<tr class="memdesc:a202de6f18f2336f9c45d69773e059d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a202de6f18f2336f9c45d69773e059d2c" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.  <a href="classDynExp_1_1InstrumentBase.html#a202de6f18f2336f9c45d69773e059d2c">More...</a><br /></td></tr>
<tr class="separator:a202de6f18f2336f9c45d69773e059d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551688a0c7b3dea13a2509f397a1ae78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a551688a0c7b3dea13a2509f397a1ae78">ResetImpl</a> (<a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a> &gt;)=0</td></tr>
<tr class="memdesc:a551688a0c7b3dea13a2509f397a1ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a202de6f18f2336f9c45d69773e059d2c" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.  <a href="classDynExp_1_1InstrumentBase.html#a551688a0c7b3dea13a2509f397a1ae78">More...</a><br /></td></tr>
<tr class="separator:a551688a0c7b3dea13a2509f397a1ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9676a5048d4b1cd98253f72868f51f2f"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a9676a5048d4b1cd98253f72868f51f2f">GetExceptionChild</a> ([[maybe_unused]] const std::chrono::milliseconds Timeout) const override final</td></tr>
<tr class="separator:a9676a5048d4b1cd98253f72868f51f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f46e3837646e83f55b5254793166f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a17f46e3837646e83f55b5254793166f6">IsReadyChild</a> () const override final</td></tr>
<tr class="memdesc:a17f46e3837646e83f55b5254793166f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>).  <a href="classDynExp_1_1InstrumentBase.html#a17f46e3837646e83f55b5254793166f6">More...</a><br /></td></tr>
<tr class="separator:a17f46e3837646e83f55b5254793166f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Private functions for logical const-ness</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Logical const-ness: refer to <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a79720764a29399e353ab328ea3586bd6" title="Calls MakeTask() to construct a new task and subsequently enqueues the task into the instrument&#39;s tas...">MakeAndEnqueueTask()</a></code>. </p>
</div></td></tr>
<tr class="memitem:acbe43c9b044e7a5161260701b2863a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentDataTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#acbe43c9b044e7a5161260701b2863a61">GetNonConstInstrumentData</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:acbe43c9b044e7a5161260701b2863a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always allows <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> to obtain a non-const pointer to the instrument's data - even in const task functions.  <a href="classDynExp_1_1InstrumentBase.html#acbe43c9b044e7a5161260701b2863a61">More...</a><br /></td></tr>
<tr class="separator:acbe43c9b044e7a5161260701b2863a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Instrument thread only</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions must be called by instrument thread only. </p>
</div></td></tr>
<tr class="memitem:a4ad80da03411380354706d04e3777419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a4ad80da03411380354706d04e3777419">HandleTask</a> (<a class="el" href="classDynExp_1_1InstrumentInstance.html">InstrumentInstance</a> &amp;Instance)</td></tr>
<tr class="memdesc:a4ad80da03411380354706d04e3777419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes and removes the next pending task from the instrument's task queue.  <a href="classDynExp_1_1InstrumentBase.html#a4ad80da03411380354706d04e3777419">More...</a><br /></td></tr>
<tr class="separator:a4ad80da03411380354706d04e3777419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5e9ba9091d6b31b8f186844fb87fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a82f5e9ba9091d6b31b8f186844fb87fc">UpdateDataInternal</a> ()</td></tr>
<tr class="memdesc:a82f5e9ba9091d6b31b8f186844fb87fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an update task (<code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>) into the instrument's task queue. Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a3a5b07e95873c660065bc75f07f51aed" title="Determines whether to enqueue update tasks (UpdateTaskBase).">UpdateAdditionalData()</a></code> to adjust behavior.  <a href="classDynExp_1_1InstrumentBase.html#a82f5e9ba9091d6b31b8f186844fb87fc">More...</a><br /></td></tr>
<tr class="separator:a82f5e9ba9091d6b31b8f186844fb87fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc11939b3a769744cb35e0c791d5ceeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#acc11939b3a769744cb35e0c791d5ceeb">OnError</a> ()</td></tr>
<tr class="memdesc:acc11939b3a769744cb35e0c791d5ceeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can perform critical shutdown actions after an error has occurred. Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a90b1ec6ab7fe93f77b06f37ae8bf8341" title="Derived classes can perform critical shutdown actions after an error has occurred....">OnErrorChild()</a></code> to adjust behavior.  <a href="classDynExp_1_1InstrumentBase.html#acc11939b3a769744cb35e0c791d5ceeb">More...</a><br /></td></tr>
<tr class="separator:acc11939b3a769744cb35e0c791d5ceeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Main thread only</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions must not be called by instrument thread. </p>
</div></td></tr>
<tr class="memitem:a9213b6b08ae5dcba30c4bc660f2ce930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a9213b6b08ae5dcba30c4bc660f2ce930">RunChild</a> () override final</td></tr>
<tr class="memdesc:a9213b6b08ae5dcba30c4bc660f2ce930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code>.  <a href="classDynExp_1_1InstrumentBase.html#a9213b6b08ae5dcba30c4bc660f2ce930">More...</a><br /></td></tr>
<tr class="separator:a9213b6b08ae5dcba30c4bc660f2ce930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af174ed78a803e2761c40a66591f21c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#af174ed78a803e2761c40a66591f21c33">NotifyChild</a> () override final</td></tr>
<tr class="memdesc:af174ed78a803e2761c40a66591f21c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify derived classes that some state has changed (e.g. the termination of <code>Thread</code> is requested) and that the child's event/task queue should run now.  <a href="classDynExp_1_1InstrumentBase.html#af174ed78a803e2761c40a66591f21c33">More...</a><br /></td></tr>
<tr class="separator:af174ed78a803e2761c40a66591f21c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0f729f7385a04160c0911c8d31b507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a8f0f729f7385a04160c0911c8d31b507">TerminateChild</a> (const std::chrono::milliseconds Timeout) override final</td></tr>
<tr class="memdesc:a8f0f729f7385a04160c0911c8d31b507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals derived classes that terminating the <a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a> instance's thread is about to be requested. Derived classes might now enqueue respective exit tasks/events into their task/event queues. Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a61aa6890ad8bc345563a8119fb7297d0" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">TerminateUnsafe()</a></code>.  <a href="classDynExp_1_1InstrumentBase.html#a8f0f729f7385a04160c0911c8d31b507">More...</a><br /></td></tr>
<tr class="separator:a8f0f729f7385a04160c0911c8d31b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5811a8a99ab7b997bfda03f85f1864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a6a5811a8a99ab7b997bfda03f85f1864">OnPrepareExit</a> ()</td></tr>
<tr class="memdesc:a6a5811a8a99ab7b997bfda03f85f1864"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables derived classes to enqueue tasks to be executed directly before the final exit task (<code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>). Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a80b0f1009ed687424cd03db7dc385d65" title="This function enables derived classes to enqueue tasks to be executed directly before the final exit ...">OnPrepareExitChild()</a></code> to adjust behavior.  <a href="classDynExp_1_1InstrumentBase.html#a6a5811a8a99ab7b997bfda03f85f1864">More...</a><br /></td></tr>
<tr class="separator:a6a5811a8a99ab7b997bfda03f85f1864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aec018b9e2e65cf41072baa4a5515c3af"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af">InstrumentData</a></td></tr>
<tr class="memdesc:aec018b9e2e65cf41072baa4a5515c3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instrument data belonging to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance.  <a href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af">More...</a><br /></td></tr>
<tr class="separator:aec018b9e2e65cf41072baa4a5515c3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4aa47314f1057959e45bf307c70b49"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a6a4aa47314f1057959e45bf307c70b49">Initialized</a> = false</td></tr>
<tr class="memdesc:a6a4aa47314f1057959e45bf307c70b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the init task (<code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>) has run.  <a href="classDynExp_1_1InstrumentBase.html#a6a4aa47314f1057959e45bf307c70b49">More...</a><br /></td></tr>
<tr class="separator:a6a4aa47314f1057959e45bf307c70b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Thread-safe public functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp39b7ba668c5986b4f7e555621172ccac"></a>Methods can be called from any thread. </p>
</td></tr>
<tr class="memitem:ab370e0dabf3a5de8295a6e19948a111e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab370e0dabf3a5de8295a6e19948a111e">InstrumentDataGetterType</a> = <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a>, <a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentDataTypeSyncPtrType</a>(InstrumentBase::*)(const std::chrono::milliseconds)&gt;</td></tr>
<tr class="memdesc:ab370e0dabf3a5de8295a6e19948a111e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">InstrumentBase::GetInstrumentData()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with.  <a href="classDynExp_1_1InstrumentBase.html#ab370e0dabf3a5de8295a6e19948a111e">More...</a><br /></td></tr>
<tr class="separator:ab370e0dabf3a5de8295a6e19948a111e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31383861ecdb9c418666562c1fb7fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentDataTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8">GetInstrumentData</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a>)</td></tr>
<tr class="memdesc:aa31383861ecdb9c418666562c1fb7fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the instrument data class instance <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a> assigned to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. Instrument data should not be locked by having called this function while subsequently calling a derived instrument's method which also makes use of the instrument's data by locking it. If this happens (e.g. in a module thread), the instrument data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice.  <a href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8">More...</a><br /></td></tr>
<tr class="separator:aa31383861ecdb9c418666562c1fb7fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1584784ce43bb9f73a95615681adc596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">InstrumentDataTypeSyncPtrConstType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a1584784ce43bb9f73a95615681adc596">GetInstrumentData</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a1584784ce43bb9f73a95615681adc596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the instrument data class instance <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a> assigned to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. Instrument data should not be locked by having called this function while subsequently calling a derived instrument's method which also makes use of the instrument's data by locking it. If this happens (e.g. in a module thread), the instrument data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice.  <a href="classDynExp_1_1InstrumentBase.html#a1584784ce43bb9f73a95615681adc596">More...</a><br /></td></tr>
<tr class="separator:a1584784ce43bb9f73a95615681adc596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe93763f0cd7d258554bf6e1f0065b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a5fe93763f0cd7d258554bf6e1f0065b8">UpdateData</a> () const</td></tr>
<tr class="memdesc:a5fe93763f0cd7d258554bf6e1f0065b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues an update task (instance of class <code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>).  <a href="classDynExp_1_1InstrumentBase.html#a5fe93763f0cd7d258554bf6e1f0065b8">More...</a><br /></td></tr>
<tr class="separator:a5fe93763f0cd7d258554bf6e1f0065b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bde85aa6b39370a739d38394e52f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a78bde85aa6b39370a739d38394e52f38">EnqueueArriveAtLatchTask</a> (std::latch &amp;Latch) const</td></tr>
<tr class="memdesc:a78bde85aa6b39370a739d38394e52f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a task which arrives at a latch when executed (instance of class <code><a class="el" href="classDynExp_1_1ArriveAtLatchTask.html" title="Defines a task which arrives at a std::latch when it is executed. This is useful to synchronize multi...">ArriveAtLatchTask</a></code>).  <a href="classDynExp_1_1InstrumentBase.html#a78bde85aa6b39370a739d38394e52f38">More...</a><br /></td></tr>
<tr class="separator:a78bde85aa6b39370a739d38394e52f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae596e932c3c205823df5436b13393"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#af0ae596e932c3c205823df5436b13393">IsInitialized</a> () const</td></tr>
<tr class="memdesc:af0ae596e932c3c205823df5436b13393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="classDynExp_1_1InstrumentBase.html#a6a4aa47314f1057959e45bf307c70b49" title="Determines whether the init task (InitTaskBase) has run.">Initialized</a>.  <a href="classDynExp_1_1InstrumentBase.html#af0ae596e932c3c205823df5436b13393">More...</a><br /></td></tr>
<tr class="separator:af0ae596e932c3c205823df5436b13393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Override</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6da8e67225fdcfa78c3ea5dc3154b849"></a>Override by derived classes. </p>
</td></tr>
<tr class="memitem:a7a6bf7866631c2f3879efaced4c7e21b"><td class="memItemLeft" align="right" valign="top">virtual std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a7a6bf7866631c2f3879efaced4c7e21b">GetTaskQueueDelay</a> () const</td></tr>
<tr class="memdesc:a7a6bf7866631c2f3879efaced4c7e21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies in which time intervals the instrument's task queue runs to handle pending tasks.  <a href="classDynExp_1_1InstrumentBase.html#a7a6bf7866631c2f3879efaced4c7e21b">More...</a><br /></td></tr>
<tr class="separator:a7a6bf7866631c2f3879efaced4c7e21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b1ec6ab7fe93f77b06f37ae8bf8341"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a90b1ec6ab7fe93f77b06f37ae8bf8341">OnErrorChild</a> () const</td></tr>
<tr class="memdesc:a90b1ec6ab7fe93f77b06f37ae8bf8341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can perform critical shutdown actions after an error has occurred. Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a90b1ec6ab7fe93f77b06f37ae8bf8341" title="Derived classes can perform critical shutdown actions after an error has occurred....">OnErrorChild()</a></code> to adjust behavior.  <a href="classDynExp_1_1InstrumentBase.html#a90b1ec6ab7fe93f77b06f37ae8bf8341">More...</a><br /></td></tr>
<tr class="separator:a90b1ec6ab7fe93f77b06f37ae8bf8341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b0f1009ed687424cd03db7dc385d65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a80b0f1009ed687424cd03db7dc385d65">OnPrepareExitChild</a> () const</td></tr>
<tr class="memdesc:a80b0f1009ed687424cd03db7dc385d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables derived classes to enqueue tasks to be executed directly before the final exit task (<code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>). Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a80b0f1009ed687424cd03db7dc385d65" title="This function enables derived classes to enqueue tasks to be executed directly before the final exit ...">OnPrepareExitChild()</a></code> to adjust behavior.  <a href="classDynExp_1_1InstrumentBase.html#a80b0f1009ed687424cd03db7dc385d65">More...</a><br /></td></tr>
<tr class="separator:a80b0f1009ed687424cd03db7dc385d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67c66aae74febbb0ce7cbbf464f71ec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab67c66aae74febbb0ce7cbbf464f71ec">HandleAdditionalTask</a> ()</td></tr>
<tr class="memdesc:ab67c66aae74febbb0ce7cbbf464f71ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether task handling should continue.  <a href="classDynExp_1_1InstrumentBase.html#ab67c66aae74febbb0ce7cbbf464f71ec">More...</a><br /></td></tr>
<tr class="separator:ab67c66aae74febbb0ce7cbbf464f71ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5b07e95873c660065bc75f07f51aed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a3a5b07e95873c660065bc75f07f51aed">UpdateAdditionalData</a> ()</td></tr>
<tr class="memdesc:a3a5b07e95873c660065bc75f07f51aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to enqueue update tasks (<code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>).  <a href="classDynExp_1_1InstrumentBase.html#a3a5b07e95873c660065bc75f07f51aed">More...</a><br /></td></tr>
<tr class="separator:a3a5b07e95873c660065bc75f07f51aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552d423a1fba6d4b2006b8d71bd4b2ed"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classDynExp_1_1InitTaskBase.html">InitTaskBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a552d423a1fba6d4b2006b8d71bd4b2ed">MakeInitTask</a> () const</td></tr>
<tr class="memdesc:a552d423a1fba6d4b2006b8d71bd4b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for an init task (<code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>). Override to define the desired initialization task in derived classes only if the respective task really does something and if it has no pure virtual function.  <a href="classDynExp_1_1InstrumentBase.html#a552d423a1fba6d4b2006b8d71bd4b2ed">More...</a><br /></td></tr>
<tr class="separator:a552d423a1fba6d4b2006b8d71bd4b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f3555c98b7662f3f778ca6695143fa"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classDynExp_1_1ExitTaskBase.html">ExitTaskBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#a78f3555c98b7662f3f778ca6695143fa">MakeExitTask</a> () const</td></tr>
<tr class="memdesc:a78f3555c98b7662f3f778ca6695143fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for an exit task (<code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>). Override to define the desired deinitialization task in derived classes only if the respective task really does something and if it has no pure virtual function.  <a href="classDynExp_1_1InstrumentBase.html#a78f3555c98b7662f3f778ca6695143fa">More...</a><br /></td></tr>
<tr class="separator:a78f3555c98b7662f3f778ca6695143fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa949725021cfe7919e01c54428f56ea8"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classDynExp_1_1UpdateTaskBase.html">UpdateTaskBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html#aa949725021cfe7919e01c54428f56ea8">MakeUpdateTask</a> () const</td></tr>
<tr class="memdesc:aa949725021cfe7919e01c54428f56ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for an update task (<code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>). Override to define the desired update task in derived classes only if the respective task really does something and if it has no pure virtual function.  <a href="classDynExp_1_1InstrumentBase.html#aa949725021cfe7919e01c54428f56ea8">More...</a><br /></td></tr>
<tr class="separator:aa949725021cfe7919e01c54428f56ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devices (instruments). While meta instruments are used by modules (<code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>) as an abstraction layer, physical instruments derive from meta instruments and make usually use of one hardware adapter (<code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code>) to communicate with the underlying hardware. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00450">450</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab07cbb563d629d268b51c5eae3fefef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07cbb563d629d268b51c5eae3fefef6">&#9670;&nbsp;</a></span>ConfigType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#ab07cbb563d629d268b51c5eae3fefef6">DynExp::InstrumentBase::ConfigType</a> =  <a class="el" href="classDynExp_1_1InstrumentConfiguratorBase.html">InstrumentConfiguratorBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00477">477</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a66a47c49a7d2700525e413dbfa149974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a47c49a7d2700525e413dbfa149974">&#9670;&nbsp;</a></span>ExitTaskType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#a66a47c49a7d2700525e413dbfa149974">DynExp::InstrumentBase::ExitTaskType</a> =  <a class="el" href="classDynExp_1_1ExitTaskBase.html">ExitTaskBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a task for deinitializing an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by a deinitialization task class derived from <code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1ExitTaskBase.html#ade32a093ce314c193622d5b36c68a826" title="Deinitializes the respective instrument within the instrument inheritance hierarchy....">ExitTaskBase::ExitFuncImpl()</a> of the derived instrument's deinitialization task class. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00503">503</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="af2e1afbc083245efdb4c87a9a0670639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e1afbc083245efdb4c87a9a0670639">&#9670;&nbsp;</a></span>InitTaskType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#af2e1afbc083245efdb4c87a9a0670639">DynExp::InstrumentBase::InitTaskType</a> =  <a class="el" href="classDynExp_1_1InitTaskBase.html">InitTaskBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a task for initializing an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by an initialization task class derived from <code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1InitTaskBase.html#a1b2737990a3c0ecc97b9a8a2bef6cf65" title="Initializes the respective instrument within the instrument inheritance hierarchy....">InitTaskBase::InitFuncImpl()</a> of the derived instrument's initialization task class. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00502">502</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="ab370e0dabf3a5de8295a6e19948a111e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab370e0dabf3a5de8295a6e19948a111e">&#9670;&nbsp;</a></span>InstrumentDataGetterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#ab370e0dabf3a5de8295a6e19948a111e">DynExp::InstrumentBase::InstrumentDataGetterType</a> =  <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt;<a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a>, <a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentDataTypeSyncPtrType</a> (InstrumentBase::*)(const std::chrono::milliseconds)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">InstrumentBase::GetInstrumentData()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00572">572</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="aa39ddd8504937d372dedf01dfcda27cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39ddd8504937d372dedf01dfcda27cf">&#9670;&nbsp;</a></span>InstrumentDataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">DynExp::InstrumentBase::InstrumentDataType</a> =  <a class="el" href="classDynExp_1_1InstrumentDataBase.html">InstrumentDataBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the data class belonging to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> type. Declare this alias in every derived class with the respective data class accompanying the derived <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00483">483</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a1af0557a21acb8ff50786d3addc5a1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af0557a21acb8ff50786d3addc5a1fa">&#9670;&nbsp;</a></span>InstrumentDataTypeSyncPtrConstType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">DynExp::InstrumentBase::InstrumentDataTypeSyncPtrConstType</a> =  <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt;const <a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the return type of InstrumentBase::GetInstrumentData() const. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00495">495</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="ab1cfe7c8a66f8184e7063977a8e4a836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cfe7c8a66f8184e7063977a8e4a836">&#9670;&nbsp;</a></span>InstrumentDataTypeSyncPtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">DynExp::InstrumentBase::InstrumentDataTypeSyncPtrType</a> =  <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt;<a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the return type of <a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">InstrumentBase::GetInstrumentData()</a>. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00489">489</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a3c274377b625b68ffbe58afcb11267b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c274377b625b68ffbe58afcb11267b2">&#9670;&nbsp;</a></span>ParamsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#a3c274377b625b68ffbe58afcb11267b2">DynExp::InstrumentBase::ParamsType</a> =  <a class="el" href="classDynExp_1_1InstrumentParamsBase.html">InstrumentParamsBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00476">476</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="aba18030aa4a0fcd0eeafadbef629d34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba18030aa4a0fcd0eeafadbef629d34c">&#9670;&nbsp;</a></span>UpdateTaskType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1InstrumentBase.html#aba18030aa4a0fcd0eeafadbef629d34c">DynExp::InstrumentBase::UpdateTaskType</a> =  <a class="el" href="classDynExp_1_1UpdateTaskBase.html">UpdateTaskBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a task for updating an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by an update task class derived from <code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1UpdateTaskBase.html#af23c4a712115c7b2375257a279c6efdb" title="Updates the respective instrument within the instrument inheritance hierarchy. Call UpdateFuncImpl() ...">UpdateTaskBase::UpdateFuncImpl()</a> of the derived instrument's update task class. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00504">504</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a426093fafaf12e96a612dc9afc7b5b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426093fafaf12e96a612dc9afc7b5b9a">&#9670;&nbsp;</a></span>InstrumentBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynExp::InstrumentBase::InstrumentBase </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id&#160;</td>
          <td class="paramname"><em>OwnerThreadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instrument instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OwnerThreadID</td><td>Thread id of the thread owning the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to be constructed. </td></tr>
    <tr><td class="paramname">Params</td><td>Parameter class instance to be assigned to the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>OwnerThreadID</code> is an invalid thread id or if <code>Params</code> is nullptr. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <a class="el" href="classDynExp_1_1InstrumentParamsBase.html#a56d8ed51f7d49cc7eb0ff46364982b86" title="Just used temporarily during the construction of an instrument. Refer to MakeInstrument() and to Inst...">InstrumentParamsBase::InstrumentData</a> of <code>Params</code> is nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00210">210</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="ad0b31ed302dc6e962d85d7a5bcbc8b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b31ed302dc6e962d85d7a5bcbc8b7d">&#9670;&nbsp;</a></span>~InstrumentBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynExp::InstrumentBase::~InstrumentBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00218">218</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab98e876c26afcccb0d8f3555f7b7b9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98e876c26afcccb0d8f3555f7b7b9b5">&#9670;&nbsp;</a></span>AsSyncTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedInstrT , typename... TaskFuncArgTs, typename... ArgTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1ExceptionContainer.html">ExceptionContainer</a> DynExp::InstrumentBase::AsSyncTask </td>
          <td>(</td>
          <td class="paramtype">void(DerivedInstrT::*)(TaskFuncArgTs...) const&#160;</td>
          <td class="paramname"><em>TaskFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a (derived) instrument's function which inserts a task into the instrument's task queue synchronously. This means that <code><a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5" title="Calls a (derived) instrument&#39;s function which inserts a task into the instrument&#39;s task queue synchro...">AsSyncTask()</a></code> blocks until the task has been executed or aborted. This is achieved by passing a callback function to the task which in turn sets a flag after the task execution. The thread calling <code><a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5" title="Calls a (derived) instrument&#39;s function which inserts a task into the instrument&#39;s task queue synchro...">AsSyncTask()</a></code> blocks (via <code>std::this_thread::yield()</code>) until this flag is set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedInstrT</td><td>Instrument type (derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>). </td></tr>
    <tr><td class="paramname">...TaskFuncArgTs</td><td>Types the task inserting function expects as arguments. </td></tr>
    <tr><td class="paramname">...ArgTs</td><td>Types of the arguments passed to <code><a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5" title="Calls a (derived) instrument&#39;s function which inserts a task into the instrument&#39;s task queue synchro...">AsSyncTask()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TaskFunc</td><td>Member function pointer to (derived) instrument's task-inserting function. </td></tr>
    <tr><td class="paramname">...Args</td><td>Arguments to be perfectly forwarded to the task function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the exception possibly thrown by the task. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00649">649</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a42e8b5062372e04c6b2aa66e3d9ad3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e8b5062372e04c6b2aa66e3d9ad3e9">&#9670;&nbsp;</a></span>Category()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static auto DynExp::InstrumentBase::Category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Every derived class has to redefine this function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the category of this instrument type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00511">511</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a78bde85aa6b39370a739d38394e52f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bde85aa6b39370a739d38394e52f38">&#9670;&nbsp;</a></span>EnqueueArriveAtLatchTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::EnqueueArriveAtLatchTask </td>
          <td>(</td>
          <td class="paramtype">std::latch &amp;&#160;</td>
          <td class="paramname"><em>Latch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a task which arrives at a latch when executed (instance of class <code><a class="el" href="classDynExp_1_1ArriveAtLatchTask.html" title="Defines a task which arrives at a std::latch when it is executed. This is useful to synchronize multi...">ArriveAtLatchTask</a></code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Latch</td><td>Latch to arrive at. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00247">247</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="ae86e1f4f45de725995b3f0ecbcd2dca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86e1f4f45de725995b3f0ecbcd2dca3">&#9670;&nbsp;</a></span>GetCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string DynExp::InstrumentBase::GetCategory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the category of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. </p>

<p>Implements <a class="el" href="classDynExp_1_1Object.html#a378599da58153d446bd382e89be2203c">DynExp::Object</a>.</p>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1TimeTagger.html#a31b62966adaef6aafb26b8efaf772e00">DynExpInstr::TimeTagger</a>, <a class="el" href="classDynExpInstr_1_1PositionerStage.html#a39ee08dd70a1a206880a70ac5b0e10f1">DynExpInstr::PositionerStage</a>, <a class="el" href="classDynExpInstr_1_1Spectrometer.html#ae1921038b7fe75fee98582090624dc21">DynExpInstr::Spectrometer</a>, <a class="el" href="classDynExpInstr_1_1OutputPort.html#aa79a116c6044a90feae80bb2f81ecc21">DynExpInstr::OutputPort</a>, <a class="el" href="classDynExpInstr_1_1LockinAmplifier.html#a5184e32111d0946520512db444727d62">DynExpInstr::LockinAmplifier</a>, <a class="el" href="classDynExpInstr_1_1InputPort.html#a5869622d7f6cac3fb7c46c0f27954a8a">DynExpInstr::InputPort</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a6ee87dcf3ed17651d0e5c392499bd10a">DynExpInstr::gRPCInstrument&lt; Spectrometer, 0, DynExpProto::NetworkSpectrometer::NetworkSpectrometer &gt;</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a6ee87dcf3ed17651d0e5c392499bd10a">DynExpInstr::gRPCInstrument&lt; DynExp::InstrumentBase, 0, DynExpProto::WidefieldLocalization::WidefieldLocalization &gt;</a>, <a class="el" href="classDynExpInstr_1_1FunctionGenerator.html#a1fc1881d05feb5154fc123d1638a2967">DynExpInstr::FunctionGenerator</a>, <a class="el" href="classDynExpInstr_1_1DigitalOut.html#ac13467fc1e97ac14171578e025bc8df9">DynExpInstr::DigitalOut</a>, <a class="el" href="classDynExpInstr_1_1DigitalIn.html#a1a92a2dcd0e60e0be95d35b1ce7091dc">DynExpInstr::DigitalIn</a>, <a class="el" href="classDynExpInstr_1_1DataStreamInstrument.html#a97b2132be4fe72fc8829a680eeae0806">DynExpInstr::DataStreamInstrument</a>, <a class="el" href="classDynExpInstr_1_1Camera.html#a615a1782db4e6090f50650abab4d441c">DynExpInstr::Camera</a>, <a class="el" href="classDynExpInstr_1_1AnalogOut.html#a25342de38bfbd2be2824b46e2724c38a">DynExpInstr::AnalogOut</a>, and <a class="el" href="classDynExpInstr_1_1AnalogIn.html#ab2190a40b592fe4b86726956cbbf193e">DynExpInstr::AnalogIn</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00522">522</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a9676a5048d4b1cd98253f72868f51f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9676a5048d4b1cd98253f72868f51f2f">&#9670;&nbsp;</a></span>GetExceptionChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr DynExp::InstrumentBase::GetExceptionChild </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00409">409</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a02203d17d10533482296eda9dae7be52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02203d17d10533482296eda9dae7be52">&#9670;&nbsp;</a></span>GetExceptionUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto DynExp::InstrumentBase::GetExceptionUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">InstrumentDataTypeSyncPtrConstType</a> &amp;&#160;</td>
          <td class="paramname"><em>InstrumentDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for <a class="el" href="classDynExp_1_1InstrumentDataBase.html#addd7549bebc1fe974bf367cfdc01645e" title="Used to transfer exceptions from the instrument thread to the main thread. Stores the exception respo...">InstrumentDataBase::InstrumentException</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the exception being responsible for the instrument's current state. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstrumentDataPtr</td><td>Reference to a pointer to the locked instrument data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00612">612</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="aa31383861ecdb9c418666562c1fb7fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31383861ecdb9c418666562c1fb7fb8">&#9670;&nbsp;</a></span>GetInstrumentData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentBase::InstrumentDataTypeSyncPtrType</a> DynExp::InstrumentBase::GetInstrumentData </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em> = <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex of the instrument data class instance <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a> assigned to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. Instrument data should not be locked by having called this function while subsequently calling a derived instrument's method which also makes use of the instrument's data by locking it. If this happens (e.g. in a module thread), the instrument data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait for locking the mutex of <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code>InstrumentDataType</code> (non-const) to allow access all of its members. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00222">222</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a1584784ce43bb9f73a95615681adc596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1584784ce43bb9f73a95615681adc596">&#9670;&nbsp;</a></span>GetInstrumentData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1InstrumentBase.html#a1af0557a21acb8ff50786d3addc5a1fa">InstrumentBase::InstrumentDataTypeSyncPtrConstType</a> DynExp::InstrumentBase::GetInstrumentData </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em> = <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex of the instrument data class instance <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a> assigned to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. Instrument data should not be locked by having called this function while subsequently calling a derived instrument's method which also makes use of the instrument's data by locking it. If this happens (e.g. in a module thread), the instrument data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait for locking the mutex of <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to const <code>InstrumentDataType</code>, since users of this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance are not allowed to access non-const members of <code>InstrumentDataType</code>. These are only to be accessed by the main thread! </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00227">227</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="acbe43c9b044e7a5161260701b2863a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe43c9b044e7a5161260701b2863a61">&#9670;&nbsp;</a></span>GetNonConstInstrumentData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1InstrumentBase.html#ab1cfe7c8a66f8184e7063977a8e4a836">InstrumentBase::InstrumentDataTypeSyncPtrType</a> DynExp::InstrumentBase::GetNonConstInstrumentData </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em> = <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a8b9520a15e9c675fa6c9740d7713700b">GetInstrumentDataTimeoutDefault</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Always allows <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> to obtain a non-const pointer to the instrument's data - even in const task functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait for locking the mutex of <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code>InstrumentDataType</code> (non-const) to allow access all of its members. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00232">232</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a7a6bf7866631c2f3879efaced4c7e21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6bf7866631c2f3879efaced4c7e21b">&#9670;&nbsp;</a></span>GetTaskQueueDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::chrono::milliseconds DynExp::InstrumentBase::GetTaskQueueDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies in which time intervals the instrument's task queue runs to handle pending tasks. </p>
<dl class="section return"><dt>Returns</dt><dd>Delay time in between task queue executions. Return <code>std::chrono::milliseconds::max()</code> to make the instrument thread only wake up (to handle tasks and to update data) when a task is enqueued. Return 0 to make the task queue delay as small as as possible. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1TimeTagger.html#abdf777b753a4d34b42cccb8ec3aeab65">DynExpInstr::TimeTagger</a>, <a class="el" href="classDynExpInstr_1_1PositionerStage.html#a8a62a3d2ea0dd5eb928595ffa3828539">DynExpInstr::PositionerStage</a>, <a class="el" href="classDynExpInstr_1_1Spectrometer.html#a89c88ae2f70fcf7efb3fefe3b2adc563">DynExpInstr::Spectrometer</a>, <a class="el" href="classDynExpInstr_1_1LockinAmplifier.html#a2784bcd683baa6bfa0408303a2db267c">DynExpInstr::LockinAmplifier</a>, <a class="el" href="classDynExpInstr_1_1Camera.html#ac3524ff1afe5a3473eeb1b2c66a340ce">DynExpInstr::Camera</a>, <a class="el" href="classDynExpInstr_1_1ZI__MFLI.html#a39ace3b4bbfe5ed14efc63628c013c24">DynExpInstr::ZI_MFLI</a>, <a class="el" href="classDynExpInstr_1_1SwabianInstrumentsPulseStreamer.html#acb56e2665b5ac5aa64a6ed7887c17d8c">DynExpInstr::SwabianInstrumentsPulseStreamer</a>, <a class="el" href="classDynExpInstr_1_1RS__SMC100A.html#a447e2e0158cede7440baef3e363861ab">DynExpInstr::RS_SMC100A</a>, <a class="el" href="classDynExpInstr_1_1RS__SMB100B.html#adc26fea57525d90450349b6e82c7569b">DynExpInstr::RS_SMB100B</a>, and <a class="el" href="classDynExpInstr_1_1NenionLeakvalveF3.html#a495f5498bed3ee82a827d3283e49cbc5">DynExpInstr::NenionLeakvalveF3</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00536">536</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="ab67c66aae74febbb0ce7cbbf464f71ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67c66aae74febbb0ce7cbbf464f71ec">&#9670;&nbsp;</a></span>HandleAdditionalTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DynExp::InstrumentBase::HandleAdditionalTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether task handling should continue. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns false if task handling (the instrument) should stop, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00726">726</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a4ad80da03411380354706d04e3777419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad80da03411380354706d04e3777419">&#9670;&nbsp;</a></span>HandleTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DynExp::InstrumentBase::HandleTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1InstrumentInstance.html">InstrumentInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes and removes the next pending task from the instrument's task queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the instrument thread's data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if task handling (the instrument) should stop, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00254">254</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="af0ae596e932c3c205823df5436b13393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ae596e932c3c205823df5436b13393">&#9670;&nbsp;</a></span>IsInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DynExp::InstrumentBase::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for <a class="el" href="classDynExp_1_1InstrumentBase.html#a6a4aa47314f1057959e45bf307c70b49" title="Determines whether the init task (InitTaskBase) has run.">Initialized</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the instrument is initialized and ready to handle tasks, false othweise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00590">590</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a17f46e3837646e83f55b5254793166f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f46e3837646e83f55b5254793166f6">&#9670;&nbsp;</a></span>IsReadyChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DynExp::InstrumentBase::IsReadyChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classDynExp_1_1Object.html#a4dc92bcd4b24ce2242b323f6ebac070a">DynExp::Object</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00419">419</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a79720764a29399e353ab328ea3586bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79720764a29399e353ab328ea3586bd6">&#9670;&nbsp;</a></span>MakeAndEnqueueTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TaskT , typename... ArgTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::MakeAndEnqueueTask </td>
          <td>(</td>
          <td class="paramtype">ArgTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="namespaceDynExp.html#a55081837e3f131e681effbd762886ca8" title="Factory function to create a task to be enqueued in an instrument&#39;s task queue.">MakeTask()</a></code> to construct a new task and subsequently enqueues the task into the instrument's task queue. Logical const-ness: this is a const member function to allow pointers to <code>const</code> <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> inserting tasks into the instrument's task queue. These kind of pointers are e.g. returned by <a class="el" href="classDynExp_1_1RunnableInstance.html#af58777edf59b61db1049e096383ee392" title="Returns Owner.">RunnableInstance::GetOwner()</a> which can be called by tasks' <a class="el" href="classDynExp_1_1TaskBase.html#a3d10e90516b0e6f26ef5b5a20d8322be" title="Runs the task. Override RunChild() to define a derived task&#39;s action(s). Any exception leaving RunChi...">TaskBase::RunChild()</a> functions. For <code>const</code> <code>InstrumentBase*</code>, it is possible to insert tasks into the task queue, but not to change the <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> object itself (e.g. calling <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskT</td><td>Type of a task derived from class <code><a class="el" href="classDynExp_1_1TaskBase.html" title="Base class for all tasks being processed by instruments. The class must not contain public virtual fu...">TaskBase</a></code> </td></tr>
    <tr><td class="paramname">...ArgTs</td><td>Types of the arguments to forward to the task's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...Args</td><td>Arguments to forward to the task's constructor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00627">627</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a78f3555c98b7662f3f778ca6695143fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f3555c98b7662f3f778ca6695143fa">&#9670;&nbsp;</a></span>MakeExitTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classDynExp_1_1ExitTaskBase.html">ExitTaskBase</a>&gt; DynExp::InstrumentBase::MakeExitTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function for an exit task (<code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>). Override to define the desired deinitialization task in derived classes only if the respective task really does something and if it has no pure virtual function. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the task (transferring ownership) or nullptr if no exit task is required. A task can be created with <code><a class="el" href="namespaceDynExp.html#a55081837e3f131e681effbd762886ca8" title="Factory function to create a task to be enqueued in an instrument&#39;s task queue.">MakeTask()</a></code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1TimeTagger.html#afd8f52e7ede911c3e813fda844a0bd52">DynExpInstr::TimeTagger</a>, <a class="el" href="classDynExpInstr_1_1OutputPort.html#a4cfa9875c54797943e2fca94eeaa8a62">DynExpInstr::OutputPort</a>, <a class="el" href="classDynExpInstr_1_1LockinAmplifier.html#abdec836651b92f2a34c2511dcafe13f7">DynExpInstr::LockinAmplifier</a>, <a class="el" href="classDynExpInstr_1_1InputPort.html#ae91b0a2764d6f6d4ba3fa21606075ed6">DynExpInstr::InputPort</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a882c8b6311abe196e75317bf811401d7">DynExpInstr::gRPCInstrument&lt; Spectrometer, 0, DynExpProto::NetworkSpectrometer::NetworkSpectrometer &gt;</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a882c8b6311abe196e75317bf811401d7">DynExpInstr::gRPCInstrument&lt; DynExp::InstrumentBase, 0, DynExpProto::WidefieldLocalization::WidefieldLocalization &gt;</a>, <a class="el" href="classDynExpInstr_1_1FunctionGenerator.html#a4f4ad1baed84145f52538a9a0e1da038">DynExpInstr::FunctionGenerator</a>, <a class="el" href="classDynExpInstr_1_1DigitalOut.html#acc1e2f001a8eb23a30b1ecf7c4ecafdb">DynExpInstr::DigitalOut</a>, <a class="el" href="classDynExpInstr_1_1DigitalIn.html#a40edf20cdb99dacd135328a9cd88f0cf">DynExpInstr::DigitalIn</a>, <a class="el" href="classDynExpInstr_1_1DataStreamInstrument.html#aef9a39069f6fe3499a5df878d4ea8223">DynExpInstr::DataStreamInstrument</a>, <a class="el" href="classDynExpInstr_1_1AnalogOut.html#a009610c06ba8ea3c8d0cdaf5fd58ffa1">DynExpInstr::AnalogOut</a>, <a class="el" href="classDynExpInstr_1_1AnalogIn.html#ac5425ae1a944b7128be90abe9ebaf94d">DynExpInstr::AnalogIn</a>, <a class="el" href="classDynExpInstr_1_1ZI__MFLI.html#a987758a832a8f540abbf960f24f5e1e8">DynExpInstr::ZI_MFLI</a>, <a class="el" href="classDynExpInstr_1_1WidefieldLocalization.html#ae16bdf37d284ec0530d9e14688dc52b5">DynExpInstr::WidefieldLocalization</a>, <a class="el" href="classDynExpInstr_1_1SwabianInstrumentsPulseStreamer.html#a6047c46e5077690e7351cd3b4c4ceede">DynExpInstr::SwabianInstrumentsPulseStreamer</a>, <a class="el" href="classDynExpInstr_1_1SmarAct.html#a0ef80d97782114f62647e9bbc8b95888">DynExpInstr::SmarAct</a>, <a class="el" href="classDynExpInstr_1_1RS__SMC100A.html#acf8f6bcb7e1020e146dcfbbc0776e8db">DynExpInstr::RS_SMC100A</a>, <a class="el" href="classDynExpInstr_1_1RS__SMB100B.html#ab5a0835fdc29e068cc67aac1f87f0034">DynExpInstr::RS_SMB100B</a>, <a class="el" href="classDynExpInstr_1_1QutoolsQuTAG.html#a7b81a95574fab9ca920913580435589a">DynExpInstr::QutoolsQuTAG</a>, <a class="el" href="classDynExpInstr_1_1PVCam.html#ad8c9ea0d4a3161cbeaf9a0697dfeb126">DynExpInstr::PVCam</a>, <a class="el" href="classDynExpInstr_1_1PI__C__862.html#a7caa7f679e4d138e42d324560fe83b73">DynExpInstr::PI_C_862</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalOut.html#a9b2c5a17ef0e93b093ac4f72fdb66827">DynExpInstr::NIDAQDigitalOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalIn.html#abe80f542caf70ad595fe72e55ee2eefb">DynExpInstr::NIDAQDigitalIn</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogOut.html#adf1f6022eae870f414dc86ca3095b3f7">DynExpInstr::NIDAQAnalogOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogIn.html#ae41f1ee0a54319899e69ea27a1f48edc">DynExpInstr::NIDAQAnalogIn</a>, <a class="el" href="classDynExpInstr_1_1NetworkSpectrometer.html#a04633391f3bfed2d5c3ba74fa870592b">DynExpInstr::NetworkSpectrometer</a>, <a class="el" href="classDynExpInstr_1_1NenionLeakvalveF3.html#a1199a8547c81460883750679ba020ef2">DynExpInstr::NenionLeakvalveF3</a>, and <a class="el" href="classDynExpInstr_1_1DummyDataStreamInstrument.html#a643e75032717d9a6f5632580d2f9c5f3">DynExpInstr::DummyDataStreamInstrument</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00751">751</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a552d423a1fba6d4b2006b8d71bd4b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552d423a1fba6d4b2006b8d71bd4b2ed">&#9670;&nbsp;</a></span>MakeInitTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classDynExp_1_1InitTaskBase.html">InitTaskBase</a>&gt; DynExp::InstrumentBase::MakeInitTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function for an init task (<code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>). Override to define the desired initialization task in derived classes only if the respective task really does something and if it has no pure virtual function. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the task (transferring ownership) or nullptr if no init task is required. A task can be created with <code><a class="el" href="namespaceDynExp.html#a55081837e3f131e681effbd762886ca8" title="Factory function to create a task to be enqueued in an instrument&#39;s task queue.">MakeTask()</a></code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1TimeTagger.html#af4ce9c47b9c17f6a8c5e67adb21c4cdc">DynExpInstr::TimeTagger</a>, <a class="el" href="classDynExpInstr_1_1OutputPort.html#a64937522b6bee68b22534ad9a9f66fba">DynExpInstr::OutputPort</a>, <a class="el" href="classDynExpInstr_1_1LockinAmplifier.html#a324b7cb384ad88e9411abf8daf960ede">DynExpInstr::LockinAmplifier</a>, <a class="el" href="classDynExpInstr_1_1InputPort.html#a6f05e9402c5510dbccf96a9a6ba36970">DynExpInstr::InputPort</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a71573612c934f4591374084dad9810d1">DynExpInstr::gRPCInstrument&lt; Spectrometer, 0, DynExpProto::NetworkSpectrometer::NetworkSpectrometer &gt;</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a71573612c934f4591374084dad9810d1">DynExpInstr::gRPCInstrument&lt; DynExp::InstrumentBase, 0, DynExpProto::WidefieldLocalization::WidefieldLocalization &gt;</a>, <a class="el" href="classDynExpInstr_1_1FunctionGenerator.html#abaf7202d17c4e07495afb376b3c303c0">DynExpInstr::FunctionGenerator</a>, <a class="el" href="classDynExpInstr_1_1DigitalOut.html#ace8f799be15890cc6ad6fd1ca55ff6f4">DynExpInstr::DigitalOut</a>, <a class="el" href="classDynExpInstr_1_1DigitalIn.html#ae844bcc82f62ccf3f4b9bd1497e45184">DynExpInstr::DigitalIn</a>, <a class="el" href="classDynExpInstr_1_1DataStreamInstrument.html#a3120b03cc40a4da91a6922a2bae6a4a9">DynExpInstr::DataStreamInstrument</a>, <a class="el" href="classDynExpInstr_1_1AnalogOut.html#ab5ea7d59bb0082ee608d85d0df4abdf2">DynExpInstr::AnalogOut</a>, <a class="el" href="classDynExpInstr_1_1AnalogIn.html#a7e9dc3edcf98fbd41534f11b37808725">DynExpInstr::AnalogIn</a>, <a class="el" href="classDynExpInstr_1_1ZI__MFLI.html#a335038c650277f57390a435a627bcd66">DynExpInstr::ZI_MFLI</a>, <a class="el" href="classDynExpInstr_1_1WidefieldLocalization.html#a3765a7a70459171e8dde66a7f850882e">DynExpInstr::WidefieldLocalization</a>, <a class="el" href="classDynExpInstr_1_1SwabianInstrumentsPulseStreamer.html#a93200eaa76a792bda4f3b0387e65198f">DynExpInstr::SwabianInstrumentsPulseStreamer</a>, <a class="el" href="classDynExpInstr_1_1SmarAct.html#a9750a6b3b248f1a1fe42cbfc980d23f2">DynExpInstr::SmarAct</a>, <a class="el" href="classDynExpInstr_1_1RS__SMC100A.html#a293f7140171377c013133b5688b7cd1b">DynExpInstr::RS_SMC100A</a>, <a class="el" href="classDynExpInstr_1_1RS__SMB100B.html#af2284ab5476f485ba67ac0a8e9b1ff3a">DynExpInstr::RS_SMB100B</a>, <a class="el" href="classDynExpInstr_1_1QutoolsQuTAG.html#a97442b63cceb4a3599cc853534197a93">DynExpInstr::QutoolsQuTAG</a>, <a class="el" href="classDynExpInstr_1_1PVCam.html#a8b96bdcf6457a67a0d1c02f3a0355016">DynExpInstr::PVCam</a>, <a class="el" href="classDynExpInstr_1_1PI__C__862.html#a345b2b353e6cad8ca47554252683142b">DynExpInstr::PI_C_862</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalOut.html#a70007ec9a6bc1bf339642bea0ebc8e5f">DynExpInstr::NIDAQDigitalOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalIn.html#aee52e28a3b52f832dccb93f35dd16b8e">DynExpInstr::NIDAQDigitalIn</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogOut.html#a903be3df2f9b3cd22812059bc3a77a3b">DynExpInstr::NIDAQAnalogOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogIn.html#a4714cf74214cb4c9e6f57fa30ae11bdd">DynExpInstr::NIDAQAnalogIn</a>, <a class="el" href="classDynExpInstr_1_1NetworkSpectrometer.html#a755845992d86428250b869d29e2f7e73">DynExpInstr::NetworkSpectrometer</a>, <a class="el" href="classDynExpInstr_1_1NenionLeakvalveF3.html#aced72c54bb56d285db08d239ba9e2f0c">DynExpInstr::NenionLeakvalveF3</a>, <a class="el" href="classDynExpInstr_1_1DummyDataStreamInstrument.html#a6648b1f4352723128877c47a2337ede1">DynExpInstr::DummyDataStreamInstrument</a>, and <a class="el" href="classDynExpInstr_1_1DummyCamera.html#a59404be07d6149d40e69e477405a804a">DynExpInstr::DummyCamera</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00742">742</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="aa949725021cfe7919e01c54428f56ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa949725021cfe7919e01c54428f56ea8">&#9670;&nbsp;</a></span>MakeUpdateTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classDynExp_1_1UpdateTaskBase.html">UpdateTaskBase</a>&gt; DynExp::InstrumentBase::MakeUpdateTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function for an update task (<code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>). Override to define the desired update task in derived classes only if the respective task really does something and if it has no pure virtual function. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the task (transferring ownership) or nullptr if no update task is required. A task can be created with <code><a class="el" href="namespaceDynExp.html#a55081837e3f131e681effbd762886ca8" title="Factory function to create a task to be enqueued in an instrument&#39;s task queue.">MakeTask()</a></code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1TimeTagger.html#a02949cb3d720ed41f0dc262ce4af5f8a">DynExpInstr::TimeTagger</a>, <a class="el" href="classDynExpInstr_1_1OutputPort.html#a792a2a88c4aa6a592e35cd51c168189b">DynExpInstr::OutputPort</a>, <a class="el" href="classDynExpInstr_1_1LockinAmplifier.html#aa7c141af92676d977b5718a0ac2b719a">DynExpInstr::LockinAmplifier</a>, <a class="el" href="classDynExpInstr_1_1InputPort.html#a195804cea55a99a48b89c36dffc72139">DynExpInstr::InputPort</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a0a40f1c98a9ccb648b45d5a985533c5e">DynExpInstr::gRPCInstrument&lt; Spectrometer, 0, DynExpProto::NetworkSpectrometer::NetworkSpectrometer &gt;</a>, <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a0a40f1c98a9ccb648b45d5a985533c5e">DynExpInstr::gRPCInstrument&lt; DynExp::InstrumentBase, 0, DynExpProto::WidefieldLocalization::WidefieldLocalization &gt;</a>, <a class="el" href="classDynExpInstr_1_1FunctionGenerator.html#a6d267b83a046d1b5773d49abfe50349a">DynExpInstr::FunctionGenerator</a>, <a class="el" href="classDynExpInstr_1_1DigitalOut.html#a2741af688810ec3988affea72a7f4ab0">DynExpInstr::DigitalOut</a>, <a class="el" href="classDynExpInstr_1_1DigitalIn.html#a539f343e29e3a75cdddad216cbd93ebc">DynExpInstr::DigitalIn</a>, <a class="el" href="classDynExpInstr_1_1DataStreamInstrument.html#a6da67829c958fd9a4b453d137b7f30e5">DynExpInstr::DataStreamInstrument</a>, <a class="el" href="classDynExpInstr_1_1AnalogOut.html#a9d37659834cbd509033f89aa9cb20197">DynExpInstr::AnalogOut</a>, <a class="el" href="classDynExpInstr_1_1AnalogIn.html#a45289c5dae05ec0f120c3e2ddd74af73">DynExpInstr::AnalogIn</a>, <a class="el" href="classDynExpInstr_1_1ZI__MFLI.html#a1ea8eeb8080f78712df2a4f544dc6898">DynExpInstr::ZI_MFLI</a>, <a class="el" href="classDynExpInstr_1_1WidefieldLocalization.html#aae73758bffa5c7c1484a2928a0de045e">DynExpInstr::WidefieldLocalization</a>, <a class="el" href="classDynExpInstr_1_1SwabianInstrumentsPulseStreamer.html#ac06c1b9455c9317eb3dfc9cc0323e072">DynExpInstr::SwabianInstrumentsPulseStreamer</a>, <a class="el" href="classDynExpInstr_1_1SmarAct.html#ad9d1db332dbea1312a3f905f61147ba3">DynExpInstr::SmarAct</a>, <a class="el" href="classDynExpInstr_1_1RS__SMC100A.html#aba8a527488ec0b1173d85ccca875788f">DynExpInstr::RS_SMC100A</a>, <a class="el" href="classDynExpInstr_1_1RS__SMB100B.html#a88b50ef92d806ef232db8fb705f95200">DynExpInstr::RS_SMB100B</a>, <a class="el" href="classDynExpInstr_1_1QutoolsQuTAG.html#a042da52184b0db3be3b9cb1e3c4776d2">DynExpInstr::QutoolsQuTAG</a>, <a class="el" href="classDynExpInstr_1_1PVCam.html#a4d3aa090c3269fe3281b9f2875827a5b">DynExpInstr::PVCam</a>, <a class="el" href="classDynExpInstr_1_1PI__C__862.html#a1a70db34532427945fe1835e6fd4e4f6">DynExpInstr::PI_C_862</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalOut.html#aa6d56df5a4116dd308c7285419dc6096">DynExpInstr::NIDAQDigitalOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalIn.html#ad214e967fafd0c6e9b19deb0684c4115">DynExpInstr::NIDAQDigitalIn</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogOut.html#a469f73a571c64871ba76b8fa91b5cf83">DynExpInstr::NIDAQAnalogOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogIn.html#a9028d486658d161cfecd2dd0843c5a7b">DynExpInstr::NIDAQAnalogIn</a>, <a class="el" href="classDynExpInstr_1_1NetworkSpectrometer.html#a53923330781807b5b02e3c220bd75881">DynExpInstr::NetworkSpectrometer</a>, <a class="el" href="classDynExpInstr_1_1NenionLeakvalveF3.html#a5b7ce811d1e04950507f9be9f8adca6b">DynExpInstr::NenionLeakvalveF3</a>, <a class="el" href="classDynExpInstr_1_1DummyDataStreamInstrument.html#a916c01e678a3e3750c668bc2105a20ee">DynExpInstr::DummyDataStreamInstrument</a>, and <a class="el" href="classDynExpInstr_1_1DummyCamera.html#a6faeb57166075eb6859888f037285842">DynExpInstr::DummyCamera</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00760">760</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="af174ed78a803e2761c40a66591f21c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af174ed78a803e2761c40a66591f21c33">&#9670;&nbsp;</a></span>NotifyChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::NotifyChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify derived classes that some state has changed (e.g. the termination of <code>Thread</code> is requested) and that the child's event/task queue should run now. </p>

<p>Reimplemented from <a class="el" href="classDynExp_1_1RunnableObject.html#a4af7d2755ba134d284e9cfc6ab99b509">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00340">340</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="acc11939b3a769744cb35e0c791d5ceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc11939b3a769744cb35e0c791d5ceeb">&#9670;&nbsp;</a></span>OnError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::OnError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can perform critical shutdown actions after an error has occurred. Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a90b1ec6ab7fe93f77b06f37ae8bf8341" title="Derived classes can perform critical shutdown actions after an error has occurred....">OnErrorChild()</a></code> to adjust behavior. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00290">290</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a90b1ec6ab7fe93f77b06f37ae8bf8341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b1ec6ab7fe93f77b06f37ae8bf8341">&#9670;&nbsp;</a></span>OnErrorChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::InstrumentBase::OnErrorChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can perform critical shutdown actions after an error has occurred. Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a90b1ec6ab7fe93f77b06f37ae8bf8341" title="Derived classes can perform critical shutdown actions after an error has occurred....">OnErrorChild()</a></code> to adjust behavior. </p>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1SmarAct.html#a463bcae721372d4f5be5ac4e5b5df4c8">DynExpInstr::SmarAct</a>, <a class="el" href="classDynExpInstr_1_1PI__C__862.html#a14fe287467a162b1f220af139b3d9e0d">DynExpInstr::PI_C_862</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalOut.html#a0afa76cc4b14a1c2b8f6131ff962a6cc">DynExpInstr::NIDAQDigitalOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQDigitalIn.html#af4c34de6949f488aa2920c5c461f4eaa">DynExpInstr::NIDAQDigitalIn</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogOut.html#a4232968fd9f2b5282c0007aaf600dfff">DynExpInstr::NIDAQAnalogOut</a>, <a class="el" href="classDynExpInstr_1_1NIDAQAnalogIn.html#a253bf404ff97ee3c382d67c87436fd2d">DynExpInstr::NIDAQAnalogIn</a>, and <a class="el" href="classDynExpInstr_1_1NenionLeakvalveF3.html#a8f13ab0d963539a8b1bcb6681401f5f2">DynExpInstr::NenionLeakvalveF3</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00719">719</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a6a5811a8a99ab7b997bfda03f85f1864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5811a8a99ab7b997bfda03f85f1864">&#9670;&nbsp;</a></span>OnPrepareExit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::OnPrepareExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables derived classes to enqueue tasks to be executed directly before the final exit task (<code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>). Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a80b0f1009ed687424cd03db7dc385d65" title="This function enables derived classes to enqueue tasks to be executed directly before the final exit ...">OnPrepareExitChild()</a></code> to adjust behavior. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00385">385</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a80b0f1009ed687424cd03db7dc385d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b0f1009ed687424cd03db7dc385d65">&#9670;&nbsp;</a></span>OnPrepareExitChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::InstrumentBase::OnPrepareExitChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables derived classes to enqueue tasks to be executed directly before the final exit task (<code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>). Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a80b0f1009ed687424cd03db7dc385d65" title="This function enables derived classes to enqueue tasks to be executed directly before the final exit ...">OnPrepareExitChild()</a></code> to adjust behavior. </p>

<p>Reimplemented in <a class="el" href="classDynExpInstr_1_1DigitalOut.html#a19843499b639f2d483ffdd5cd7d520e7">DynExpInstr::DigitalOut</a>, and <a class="el" href="classDynExpInstr_1_1AnalogOut.html#a08194cda8d15c6213768dc52dcef4125">DynExpInstr::AnalogOut</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00720">720</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a551688a0c7b3dea13a2509f397a1ae78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551688a0c7b3dea13a2509f397a1ae78">&#9670;&nbsp;</a></span>ResetImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::InstrumentBase::ResetImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a202de6f18f2336f9c45d69773e059d2c" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy. </p>

<p>Implemented in <a class="el" href="classDynExpInstr_1_1gRPCInstrument.html#a02952398a7898f72e5c18ef2bd3f814e">DynExpInstr::gRPCInstrument&lt; DynExp::InstrumentBase, 0, DynExpProto::WidefieldLocalization::WidefieldLocalization &gt;</a>, and <a class="el" href="classDynExpInstr_1_1InterModuleCommunicator.html#affa8eec75b64d5511a8c963ab926eed3">DynExpInstr::InterModuleCommunicator</a>.</p>

</div>
</div>
<a id="a202de6f18f2336f9c45d69773e059d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202de6f18f2336f9c45d69773e059d2c">&#9670;&nbsp;</a></span>ResetImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::ResetImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1RunnableObject.html">RunnableObject</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a202de6f18f2336f9c45d69773e059d2c" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy. </p>

<p>Implements <a class="el" href="classDynExp_1_1RunnableObject.html#ac90bb7c8a28c813a7f4fd79c081a7aa1">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00317">317</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a9213b6b08ae5dcba30c4bc660f2ce930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9213b6b08ae5dcba30c4bc660f2ce930">&#9670;&nbsp;</a></span>RunChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::RunChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code>. </p>

<p>Implements <a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00327">327</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a8f0f729f7385a04160c0911c8d31b507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0f729f7385a04160c0911c8d31b507">&#9670;&nbsp;</a></span>TerminateChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::TerminateChild </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals derived classes that terminating the <a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a> instance's thread is about to be requested. Derived classes might now enqueue respective exit tasks/events into their task/event queues. Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a61aa6890ad8bc345563a8119fb7297d0" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">TerminateUnsafe()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait until the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a>'s</code> thread has ended. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classDynExp_1_1RunnableObject.html#afcbabd17804369f574cd8433b36d4339">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00347">347</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a3a5b07e95873c660065bc75f07f51aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5b07e95873c660065bc75f07f51aed">&#9670;&nbsp;</a></span>UpdateAdditionalData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DynExp::InstrumentBase::UpdateAdditionalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether to enqueue update tasks (<code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if update tasks should be appended to the instrument's task queue periodically after handling all pending tasks, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00733">733</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a5fe93763f0cd7d258554bf6e1f0065b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe93763f0cd7d258554bf6e1f0065b8">&#9670;&nbsp;</a></span>UpdateData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::UpdateData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues an update task (instance of class <code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>). </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00237">237</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a82f5e9ba9091d6b31b8f186844fb87fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5e9ba9091d6b31b8f186844fb87fc">&#9670;&nbsp;</a></span>UpdateDataInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::InstrumentBase::UpdateDataInternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an update task (<code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>) into the instrument's task queue. Override <code><a class="el" href="classDynExp_1_1InstrumentBase.html#a3a5b07e95873c660065bc75f07f51aed" title="Determines whether to enqueue update tasks (UpdateTaskBase).">UpdateAdditionalData()</a></code> to adjust behavior. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00280">280</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b9520a15e9c675fa6c9740d7713700b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9520a15e9c675fa6c9740d7713700b">&#9670;&nbsp;</a></span>GetInstrumentDataTimeoutDefault</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto DynExp::InstrumentBase::GetInstrumentDataTimeoutDefault = std::chrono::milliseconds(1000)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the default timeout for <code><a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">GetInstrumentData()</a></code> to lock the mutex synchronizing the instrument's data <a class="el" href="classDynExp_1_1InstrumentBase.html#aec018b9e2e65cf41072baa4a5515c3af" title="Instrument data belonging to this InstrumentBase instance.">InstrumentData</a>. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00543">543</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a6a4aa47314f1057959e45bf307c70b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4aa47314f1057959e45bf307c70b49">&#9670;&nbsp;</a></span>Initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; DynExp::InstrumentBase::Initialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the init task (<code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>) has run. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00764">764</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="aec018b9e2e65cf41072baa4a5515c3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec018b9e2e65cf41072baa4a5515c3af">&#9670;&nbsp;</a></span>InstrumentData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;<a class="el" href="classDynExp_1_1InstrumentBase.html#aa39ddd8504937d372dedf01dfcda27cf">InstrumentDataType</a>&gt; DynExp::InstrumentBase::InstrumentData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instrument data belonging to this <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00763">763</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="ab356af07c76602059ea91367c4b36a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab356af07c76602059ea91367c4b36a76">&#9670;&nbsp;</a></span>InstrumentThreadOnly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1InstrumentBase_1_1InstrumenThreadOnlyType.html">InstrumenThreadOnlyType</a> DynExp::InstrumentBase::InstrumentThreadOnly</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a>'s</code> private methods to the instrument thread <code><a class="el" href="namespaceDynExp.html#a6985987f0ba5cd7ab42caef76ac995c9" title="Instruments run in their own thread. This is the instrument thread&#39;s main function.">InstrumentThreadMain()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00524">524</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Instrument_8h_source.html">Instrument.h</a></li>
<li><a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDynExp.html">DynExp</a></li><li class="navelem"><a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
