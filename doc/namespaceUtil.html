<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynExp: Util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DynExp.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynExp
   </div>
   <div id="projectbrief">Highly flexible laboratory automation for dynamically changing experiments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceUtil.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>DynExp's Util namespace contains commonly used functions and templates as well as extensions to Qt and its widgets.  
<a href="namespaceUtil.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtil_1_1DynExpErrorCodes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html">DynExpErrorCodes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1circularbuf.html">circularbuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular stream buffer to be used with the standard library's stream classes. Reading from or writing behind the buffer's end continues at the buffer's beginning.  <a href="classUtil_1_1circularbuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp exceptions are derived from this class. It contains basic information about the cause of the exception as well as a stacktrace.  <a href="classUtil_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ForwardedException.html">ForwardedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to forward an <code><a class="el" href="classUtil_1_1Exception.html" title="DynExp exceptions are derived from this class. It contains basic information about the cause of the e...">Exception</a></code> instance from one <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a></code> instance to another <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a></code> instance. Refer to class <code><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html" title="This class holds a pointer (LinkedObjectWrapperPointer) to a LinkedObjectWrapper. Intances of this cl...">DynExp::LinkedObjectWrapperContainer</a></code>.  <a href="classUtil_1_1ForwardedException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1InvalidArgException.html">InvalidArgException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid argument like a null pointer has been passed to a function.  <a href="classUtil_1_1InvalidArgException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1InvalidStateException.html">InvalidStateException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operation cannot be performed currently since the related object is in an invalid state like an error state.  <a href="classUtil_1_1InvalidStateException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1InvalidDataException.html">InvalidDataException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or function calls not returning data in the expected format.  <a href="classUtil_1_1InvalidDataException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1InvalidCallException.html">InvalidCallException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a function call is not allowed to a specific thread in a multi-threading context.  <a href="classUtil_1_1InvalidCallException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1UnderflowException.html">UnderflowException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a numeric operation would result in an underflow (e.g. due to incompatible data types)  <a href="classUtil_1_1UnderflowException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OverflowException.html">OverflowException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a numeric operation would result in an overflow (e.g. due to incompatible data types)  <a href="classUtil_1_1OverflowException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OutOfRangeException.html">OutOfRangeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when an argument passed to a function exceeds the valid range.  <a href="classUtil_1_1OutOfRangeException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1EmptyException.html">EmptyException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a list is expected to contain entries and when a query results in an empty answer or an empty argument has been passed to a function, or a stored list is empty.  <a href="classUtil_1_1EmptyException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1NotFoundException.html">NotFoundException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a requested ressource does not exist.  <a href="classUtil_1_1NotFoundException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1TypeErrorException.html">TypeErrorException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when an attempt was made to convert two incompatible types into each other.  <a href="classUtil_1_1TypeErrorException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1TimeoutException.html">TimeoutException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when an operation timed out before it could be completed, especially used for locking shared data in a multi-threading context.  <a href="classUtil_1_1TimeoutException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ThreadDidNotRespondException.html">ThreadDidNotRespondException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown in a multi-threading context when an answer is expected from another thread an when the communication timed out.  <a href="classUtil_1_1ThreadDidNotRespondException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1NotAvailableException.html">NotAvailableException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when some operation or feature is temporarily or permanently not available.  <a href="classUtil_1_1NotAvailableException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1NotImplementedException.html">NotImplementedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a requested feature is either under development and thus not implemented yet or when a specific instrument does not support certain operation.  <a href="classUtil_1_1NotImplementedException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1FileIOErrorException.html">FileIOErrorException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when reading from or writing to a file failed.  <a href="classUtil_1_1FileIOErrorException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1LinkedObjectNotLockedException.html">LinkedObjectNotLockedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when RunnableInstance::LockObject() has not been called on an object link parameter to establish the relation between the object using another object and the used object.  <a href="classUtil_1_1LinkedObjectNotLockedException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1InvalidObjectLinkException.html">InvalidObjectLinkException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when RunnableInstance cannot lock an object to be used by another object due to an invalid link between the objects. This happens when the used object the link points to has been removed from the project.  <a href="classUtil_1_1InvalidObjectLinkException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ServiceFailedException.html">ServiceFailedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes that e.g. a remote gRPC service failed.  <a href="classUtil_1_1ServiceFailedException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1PyStdoutLoggerWrapper.html">PyStdoutLoggerWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards Python's stdout to <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">Util::EventLogger</a> instance defined in <a class="el" href="namespaceUtil.html#a702d46b185233ad1fa56ee7033eabd41" title="This function holds a static EventLogger instance and returns a reference to it. DynExp uses only one...">Util::EventLog()</a>.  <a href="classUtil_1_1PyStdoutLoggerWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1PyGilReleasedInterpreter.html">PyGilReleasedInterpreter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Python interpreter and directly release the GIL after construction.  <a href="classUtil_1_1PyGilReleasedInterpreter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1PyObject.html">PyObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a class derived from pybind11::object and ensures that the GIL is acquired when the <a class="el" href="classUtil_1_1PyObject.html" title="Wraps a class derived from pybind11::object and ensures that the GIL is acquired when the PyObject is...">PyObject</a> is destroyed. For any other operation on this wrapper, the GIL still needs to be acquired manually before!  <a href="classUtil_1_1PyObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1QWorker.html">QWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a QObject belonging to a hardware adapter (derived from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">DynExp::HardwareAdapterBase</a>) that operates in DynExpCore's worker thread, not in the main user interface thread. This is useful to move e.g. ethernet/serial communication operations from the user interface thread to a worker thread. After construction, <a class="el" href="classUtil_1_1QWorker.html" title="Implements a QObject belonging to a hardware adapter (derived from DynExp::HardwareAdapterBase) that ...">QWorker</a> instances have to be moved to the worker thread calling <a class="el" href="classUtil_1_1QWorker.html#a3382866a1075477b1a1b8196486210b7" title="Moves the instance to DynExpCore&#39;s worker thread. Do not call from constructor since derived classes ...">QWorker::MoveToWorkerThread()</a>.  <a href="classUtil_1_1QWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1MarkerGraphicsView.html">MarkerGraphicsView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a QGraphicsView the user can interact with to insert graphical markers. Furthermore, the graphics view enables zooming into its content.  <a href="classUtil_1_1MarkerGraphicsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1QSortingListWidget.html">QSortingListWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a QListWidget that sorts its items after inserting an item by drag &amp; drop.  <a href="classUtil_1_1QSortingListWidget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1NumericSortingTableWidgetItem.html">NumericSortingTableWidgetItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a QTableWidgetItem which contains numeric content such that table widget items can be numerically compared with each other.  <a href="classUtil_1_1NumericSortingTableWidgetItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1NumericOnlyItemDelegate.html">NumericOnlyItemDelegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a QItemDelegate which forces e.g. a QTableWidgetItem's content to be numeric (double-precision).  <a href="classUtil_1_1NumericOnlyItemDelegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1DigitalOnlyItemDelegate.html">DigitalOnlyItemDelegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a QItemDelegate which forces e.g. a QTableWidgetItem's content to be boolean (0 or 1).  <a href="classUtil_1_1DigitalOnlyItemDelegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to delete copy constructor and copy assignment operator and thus make derived classes non-copyable.  <a href="classUtil_1_1INonCopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonMovable.html">INonMovable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to delete move constructor and move assignment operator and thus make derived classes non-movable.  <a href="classUtil_1_1INonMovable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html">ILockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to allow synchronizing the access to derived classes between different threads by providing a mutex and a method to lock that mutex. Recursive locking is <b>not</b> allowed.  <a href="classUtil_1_1ILockable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1SynchronizedPointer.html">SynchronizedPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to lock a class derived from <code><a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">ISynchronizedPointerLockable</a></code> for synchronizing between threads. Instances of this class are not intended to be stored somewhere since they make other threads block. Only use as temporary objects.  <a href="classUtil_1_1SynchronizedPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html">ISynchronizedPointerLockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to allow synchronizing the access to derived classes between different threads by making the class lockable by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">SynchronizedPointer</a> smart pointer objects. Recursive locking is allowed.  <a href="classUtil_1_1ISynchronizedPointerLockable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OneToOneNotifier.html">OneToOneNotifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to communicate flags between different threads based on a condition variable and a mutex. Two threads make use of the same instance of this class. One of the thread awaits a flag to be set by the other thread.  <a href="classUtil_1_1OneToOneNotifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1is__contained__in.html">is_contained_in</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type <code>T</code> is contained in a template parameter pack of types <code>ListTs</code>.  <a href="structUtil_1_1is__contained__in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.  <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4">member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.  <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4">member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.  <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4">member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.  <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4">member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.  <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1remove__first__from__tuple"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple">remove_first_from_tuple</a></td></tr>
<tr class="memdesc:structUtil_1_1remove__first__from__tuple"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes first type from a tuple of types <code>TupleT</code>.  <a href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1remove__first__from__tuple"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4">remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes first type from a tuple of types <code>TupleT</code>.  <a href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1OffsetIndexSequence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence">OffsetIndexSequence</a></td></tr>
<tr class="memdesc:structUtil_1_1OffsetIndexSequence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an alias for a std::index_sequence where all indices are shifted by an offset.  <a href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1OffsetIndexSequence"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4">OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an alias for a std::index_sequence where all indices are shifted by an offset.  <a href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1RangeIndexSequence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">RangeIndexSequence</a></td></tr>
<tr class="memdesc:structUtil_1_1RangeIndexSequence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an alias for a std::index_sequence spanning a certain range.  <a href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1RangeIndexSequence"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1CallableMemberWrapper.html">CallableMemberWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a member function of some object and stores its default arguments. Moving from <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">CallableMemberWrapper</a> does not work since this class holds const members and a reference to the object the member function is invoked on. Copy instead.  <a href="classUtil_1_1CallableMemberWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OnDestruction.html">OnDestruction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a <code><a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">CallableMemberWrapper</a></code> and invokes its callable when being destroyed.  <a href="classUtil_1_1OnDestruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1BlobDataType.html">BlobDataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type which manages a binary large object. The reserved memory is freed upon destruction.  <a href="classUtil_1_1BlobDataType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OptionalBool.html">OptionalBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type which stores an optional bool value (unknown, false, true). The type evaluates to bool while an unknown value is considered false.  <a href="classUtil_1_1OptionalBool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1VersionType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a></td></tr>
<tr class="memdesc:structUtil_1_1VersionType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type describing DynExp's program version in the form Major.Minor.Patch.  <a href="namespaceUtil.html#structUtil_1_1VersionType">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1VersionType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Warning.html">Warning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store information about warnings in a thread-safe manner (deriving from <code><a class="el" href="classUtil_1_1ILockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by providing...">ILockable</a></code>). All function calls are thread-safe.  <a href="classUtil_1_1Warning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1LogEntry.html">LogEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type of a single entry in DynExp's log.  <a href="structUtil_1_1LogEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1EventLogger.html">EventLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs events like errors and writes them immediately to a HTML file in a human-readable format. The logger also stores the events in an internal event log to be displayed within DynExp. The class is designed such that instances can be shared between different threads. Member function calls are synchronized.  <a href="classUtil_1_1EventLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1FeatureTester.html">FeatureTester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a bitset containing flags to indicate which features a certain instrument/ module etc. supports.  <a href="classUtil_1_1FeatureTester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1StateMachineState.html">StateMachineState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State machine state as used by class <a class="el" href="classUtil_1_1StateMachine.html" title="This class models a state machine. It keeps track of the current state and allows to invoke its assoc...">StateMachine</a>. A state mainly wraps a state function of the member function pointer type CallableT to be invoked by the state machine.  <a href="classUtil_1_1StateMachineState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1StateMachineContext.html">StateMachineContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State machine context as used by class <a class="el" href="classUtil_1_1StateMachine.html" title="This class models a state machine. It keeps track of the current state and allows to invoke its assoc...">StateMachine</a>. A state machine context holds a map with keys and values of unique state identifiers of type StateEnumType (refer to class <a class="el" href="classUtil_1_1StateMachineState.html" title="State machine state as used by class StateMachine. A state mainly wraps a state function of the membe...">StateMachineState</a>). Each map entry indicates a state (key) to be replaced by another state (value). <a class="el" href="classUtil_1_1StateMachine.html#a4362aa008a969e440e4585079c046d80" title="Invokes the state function associated with the current state machine state on an instance of the clas...">StateMachine::Invoke</a> checks the state identifiers returned by <a class="el" href="classUtil_1_1StateMachineState.html#a6ffe3a9eb4a56870df5c4f7016e26e5f" title="Invokes the state function associated with this state on an instance of the class the state function ...">StateMachineState::Invoke</a> and possibly replaces them according to the current context before setting the new state machine state. Contexts can be derived from base contexts unifying and including their replacement lists.  <a href="classUtil_1_1StateMachineContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1StateMachine.html">StateMachine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models a state machine. It keeps track of the current state and allows to invoke its associated state function. The return value of the state function determines the new state to transition into. Additionally, a context of type <a class="el" href="classUtil_1_1StateMachineContext.html" title="State machine context as used by class StateMachine. A state machine context holds a map with keys an...">StateMachineContext</a> can be assigned to the state machine. Contexts allow for replacing states with other states. This makes sense to write inner protocols BeginState -&gt; StateA -&gt; ... -&gt; StateN -&gt; EndState and to embed them into outer protocols. The outer protocol can transition into BeginState and take control back by replacing EndState with one of its own states by setting a respective context. All states (of type <a class="el" href="classUtil_1_1StateMachineState.html" title="State machine state as used by class StateMachine. A state mainly wraps a state function of the membe...">StateMachineState</a>) have to be registered upon construction of the <a class="el" href="classUtil_1_1StateMachine.html" title="This class models a state machine. It keeps track of the current state and allows to invoke its assoc...">StateMachine</a> instance.  <a href="classUtil_1_1StateMachine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae4e8f4a1305aa88e268e5042ba89ff32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">TextType</a> = std::string</td></tr>
<tr class="memdesc:ae4e8f4a1305aa88e268e5042ba89ff32"><td class="mdescLeft">&#160;</td><td class="mdescRight">String type of text-type parameters (<a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">DynExp::ParamsBase::Param</a>)  <a href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">More...</a><br /></td></tr>
<tr class="separator:ae4e8f4a1305aa88e268e5042ba89ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff0ca7e2d8ab44f604a60f2ab5b94fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a6ff0ca7e2d8ab44f604a60f2ab5b94fa">TextRefType</a> = std::string_view</td></tr>
<tr class="memdesc:a6ff0ca7e2d8ab44f604a60f2ab5b94fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-to-string type of text-type parameters (<a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">DynExp::ParamsBase::Param</a>)  <a href="namespaceUtil.html#a6ff0ca7e2d8ab44f604a60f2ab5b94fa">More...</a><br /></td></tr>
<tr class="separator:a6ff0ca7e2d8ab44f604a60f2ab5b94fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be935d029b0d65c176e549a5f4329d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a2be935d029b0d65c176e549a5f4329d4">TextListType</a> = std::vector&lt; <a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">TextType</a> &gt;</td></tr>
<tr class="memdesc:a2be935d029b0d65c176e549a5f4329d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">List type of text-type parameters.  <a href="namespaceUtil.html#a2be935d029b0d65c176e549a5f4329d4">More...</a><br /></td></tr>
<tr class="separator:a2be935d029b0d65c176e549a5f4329d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41705d4222604e87171ef1133477ac1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a41705d4222604e87171ef1133477ac1d">TextListIndexType</a> = size_t</td></tr>
<tr class="memdesc:a41705d4222604e87171ef1133477ac1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List index type of <code><a class="el" href="namespaceUtil.html#a2be935d029b0d65c176e549a5f4329d4" title="List type of text-type parameters.">Util::TextListType</a></code>.  <a href="namespaceUtil.html#a41705d4222604e87171ef1133477ac1d">More...</a><br /></td></tr>
<tr class="separator:a41705d4222604e87171ef1133477ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae830fe52c0bdb97fc86cb28f7882526a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ae830fe52c0bdb97fc86cb28f7882526a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ae830fe52c0bdb97fc86cb28f7882526a">TextValueListType</a> = std::vector&lt; std::pair&lt; <a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">TextType</a>, ValueType &gt; &gt;</td></tr>
<tr class="memdesc:ae830fe52c0bdb97fc86cb28f7882526a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a list containing key-value pairs where key is a text of type <code><a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32" title="String type of text-type parameters (DynExp::ParamsBase::Param)">Util::TextType</a></code>.  <a href="namespaceUtil.html#ae830fe52c0bdb97fc86cb28f7882526a">More...</a><br /></td></tr>
<tr class="separator:ae830fe52c0bdb97fc86cb28f7882526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f4ac72ff1d4ad593754196eead2565"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:a81f4ac72ff1d4ad593754196eead2565"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a81f4ac72ff1d4ad593754196eead2565">return_of_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt; CallableT &gt;::return_type</td></tr>
<tr class="memdesc:a81f4ac72ff1d4ad593754196eead2565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of a member function callable of type <code>CallableT</code>.  <a href="namespaceUtil.html#a81f4ac72ff1d4ad593754196eead2565">More...</a><br /></td></tr>
<tr class="separator:a81f4ac72ff1d4ad593754196eead2565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119ab45e422a49c79f58028ff1ed09d5"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:a119ab45e422a49c79f58028ff1ed09d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a119ab45e422a49c79f58028ff1ed09d5">instance_of_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt; CallableT &gt;::instance_type</td></tr>
<tr class="memdesc:a119ab45e422a49c79f58028ff1ed09d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the class type a member function callable of type <code>CallableT</code> is member of.  <a href="namespaceUtil.html#a119ab45e422a49c79f58028ff1ed09d5">More...</a><br /></td></tr>
<tr class="separator:a119ab45e422a49c79f58028ff1ed09d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9535f26f425537e00abc71ed6a3b7a"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:aee9535f26f425537e00abc71ed6a3b7a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aee9535f26f425537e00abc71ed6a3b7a">argument_of_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt; CallableT &gt;::argument_types</td></tr>
<tr class="memdesc:aee9535f26f425537e00abc71ed6a3b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a tuple of argument types the member function callable of type <code>CallableT</code> expects.  <a href="namespaceUtil.html#aee9535f26f425537e00abc71ed6a3b7a">More...</a><br /></td></tr>
<tr class="separator:aee9535f26f425537e00abc71ed6a3b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6567c7f10bb5d827f0df893e13698aee"><td class="memTemplParams" colspan="2">template&lt;typename TupleT &gt; </td></tr>
<tr class="memitem:a6567c7f10bb5d827f0df893e13698aee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a6567c7f10bb5d827f0df893e13698aee">remove_first_from_tuple_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple">remove_first_from_tuple</a>&lt; TupleT &gt;::type</td></tr>
<tr class="memdesc:a6567c7f10bb5d827f0df893e13698aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a tuple of types where the first type of the input tuple <code>TupleT</code> is removed.  <a href="namespaceUtil.html#a6567c7f10bb5d827f0df893e13698aee">More...</a><br /></td></tr>
<tr class="separator:a6567c7f10bb5d827f0df893e13698aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc4b7656b284a6b140d130326c384f"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, typename IndexSequence &gt; </td></tr>
<tr class="memitem:a6efc4b7656b284a6b140d130326c384f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a6efc4b7656b284a6b140d130326c384f">OffsetIndexSequence_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence">OffsetIndexSequence</a>&lt; Offset, IndexSequence &gt;::type</td></tr>
<tr class="memdesc:a6efc4b7656b284a6b140d130326c384f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for type contained in <code><a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence" title="Holds an alias for a std::index_sequence where all indices are shifted by an offset.">OffsetIndexSequence</a></code>.  <a href="namespaceUtil.html#a6efc4b7656b284a6b140d130326c384f">More...</a><br /></td></tr>
<tr class="separator:a6efc4b7656b284a6b140d130326c384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0533638c16abf01f66d3397a281f73"><td class="memTemplParams" colspan="2">template&lt;size_t From, size_t To&gt; </td></tr>
<tr class="memitem:abe0533638c16abf01f66d3397a281f73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#abe0533638c16abf01f66d3397a281f73">RangeIndexSequence_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">RangeIndexSequence</a>&lt; From, To &gt;::type</td></tr>
<tr class="memdesc:abe0533638c16abf01f66d3397a281f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for type contained in <code><a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence" title="Holds an alias for a std::index_sequence spanning a certain range.">RangeIndexSequence</a></code>.  <a href="namespaceUtil.html#abe0533638c16abf01f66d3397a281f73">More...</a><br /></td></tr>
<tr class="separator:abe0533638c16abf01f66d3397a281f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae3347e48d6767776339d0ccffe6f1041"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041">ErrorType</a> { <a class="el" href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041a4059b0251f66a18cb56f544728796875">Info</a>
, <a class="el" href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>
, <a class="el" href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
, <a class="el" href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041a882384ec38ce8d9582b57e70861730e4">Fatal</a>
 }</td></tr>
<tr class="memdesc:ae3347e48d6767776339d0ccffe6f1041"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp's error types  <a href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041">More...</a><br /></td></tr>
<tr class="separator:ae3347e48d6767776339d0ccffe6f1041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad4cd00e28ff76f7cff0a2d9c08c8f943"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ad4cd00e28ff76f7cff0a2d9c08c8f943">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classUtil_1_1Exception.html">Exception</a> &amp;e)</td></tr>
<tr class="memdesc:ad4cd00e28ff76f7cff0a2d9c08c8f943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a DynExp exception in a user-readable way to a stream.  <a href="namespaceUtil.html#ad4cd00e28ff76f7cff0a2d9c08c8f943">More...</a><br /></td></tr>
<tr class="separator:ad4cd00e28ff76f7cff0a2d9c08c8f943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9f0d5782cf60eccacaa216ea9d1fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a2a9f0d5782cf60eccacaa216ea9d1fa8">ForwardException</a> (std::exception_ptr e)</td></tr>
<tr class="memdesc:a2a9f0d5782cf60eccacaa216ea9d1fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the exception passed to the function in a <a class="el" href="classUtil_1_1ForwardedException.html" title="Class to forward an Exception instance from one DynExp::Object instance to another DynExp::Object ins...">ForwardedException</a> and throws the <a class="el" href="classUtil_1_1ForwardedException.html" title="Class to forward an Exception instance from one DynExp::Object instance to another DynExp::Object ins...">ForwardedException</a>. Does nothing if e is not an exception.  <a href="namespaceUtil.html#a2a9f0d5782cf60eccacaa216ea9d1fa8">More...</a><br /></td></tr>
<tr class="separator:a2a9f0d5782cf60eccacaa216ea9d1fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d6fb43e8d89b0aaf434700bd746349"><td class="memItemLeft" align="right" valign="top">const QLocale &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a62d6fb43e8d89b0aaf434700bd746349">GetDefaultQtLocale</a> ()</td></tr>
<tr class="memdesc:a62d6fb43e8d89b0aaf434700bd746349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default locale properties to be assigned to Qt widgets.  <a href="namespaceUtil.html#a62d6fb43e8d89b0aaf434700bd746349">More...</a><br /></td></tr>
<tr class="separator:a62d6fb43e8d89b0aaf434700bd746349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20a78ec763492c5acf6c685782fbfd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa20a78ec763492c5acf6c685782fbfd2">ActivateWindow</a> (QWidget &amp;Widget)</td></tr>
<tr class="memdesc:aa20a78ec763492c5acf6c685782fbfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a window active and brings it to the front.  <a href="namespaceUtil.html#aa20a78ec763492c5acf6c685782fbfd2">More...</a><br /></td></tr>
<tr class="separator:aa20a78ec763492c5acf6c685782fbfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3151e735e3f9712b7838f4fce34cfd1"><td class="memTemplParams" colspan="2">template&lt;typename EnumType &gt; </td></tr>
<tr class="memitem:aa3151e735e3f9712b7838f4fce34cfd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa3151e735e3f9712b7838f4fce34cfd1">QtEnumToTextValueList</a> (unsigned short SkipEntriesFront=0, unsigned short SkipEntriesEnd=0, unsigned short SkipCharsFront=0, unsigned short SkipCharsEnd=0)</td></tr>
<tr class="memdesc:aa3151e735e3f9712b7838f4fce34cfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a TextValueListType containing entries which reflect the items (names and values) of an enumeration registered to Qt's meta-object system.  <a href="namespaceUtil.html#aa3151e735e3f9712b7838f4fce34cfd1">More...</a><br /></td></tr>
<tr class="separator:aa3151e735e3f9712b7838f4fce34cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8491d385f4f8671067e17da06244a9"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a9e8491d385f4f8671067e17da06244a9">operator&lt;=&gt;</a> (const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;lhs, const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9e8491d385f4f8671067e17da06244a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two program version types with each other.  <a href="namespaceUtil.html#a9e8491d385f4f8671067e17da06244a9">More...</a><br /></td></tr>
<tr class="separator:a9e8491d385f4f8671067e17da06244a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b9b93456301284ca7d695c51a4001a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a68b9b93456301284ca7d695c51a4001a">VersionFromString</a> (std::string_view Str)</td></tr>
<tr class="memdesc:a68b9b93456301284ca7d695c51a4001a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a program version from a string.  <a href="namespaceUtil.html#a68b9b93456301284ca7d695c51a4001a">More...</a><br /></td></tr>
<tr class="separator:a68b9b93456301284ca7d695c51a4001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3214377992588c6e7eabe298496544af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a3214377992588c6e7eabe298496544af">ExceptionToStr</a> (const std::exception_ptr ExceptionPtr)</td></tr>
<tr class="memdesc:a3214377992588c6e7eabe298496544af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the what() information of an exception derived from std::exception and stored in an exception pointer.  <a href="namespaceUtil.html#a3214377992588c6e7eabe298496544af">More...</a><br /></td></tr>
<tr class="separator:a3214377992588c6e7eabe298496544af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c0b4a3ef36519bbcd9fe76cf68dde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aab8c0b4a3ef36519bbcd9fe76cf68dde">ToLower</a> (std::string_view Str)</td></tr>
<tr class="memdesc:aab8c0b4a3ef36519bbcd9fe76cf68dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a string into lower case.  <a href="namespaceUtil.html#aab8c0b4a3ef36519bbcd9fe76cf68dde">More...</a><br /></td></tr>
<tr class="separator:aab8c0b4a3ef36519bbcd9fe76cf68dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d8df62a6cca9d2e0e444f533501c8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa1d8df62a6cca9d2e0e444f533501c8d">FFT</a> (const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;Data, bool InverseTransform=false)</td></tr>
<tr class="memdesc:aa1d8df62a6cca9d2e0e444f533501c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Fast Fourier Transform (FFT) a vector of complex values.  <a href="namespaceUtil.html#aa1d8df62a6cca9d2e0e444f533501c8d">More...</a><br /></td></tr>
<tr class="separator:aa1d8df62a6cca9d2e0e444f533501c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702d46b185233ad1fa56ee7033eabd41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1EventLogger.html">EventLogger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a702d46b185233ad1fa56ee7033eabd41">EventLog</a> ()</td></tr>
<tr class="memdesc:a702d46b185233ad1fa56ee7033eabd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function holds a static <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance and returns a reference to it. DynExp uses only one <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance to log events from any thread. A local static object instead of a global object is employed to avoid initialization order problems.  <a href="namespaceUtil.html#a702d46b185233ad1fa56ee7033eabd41">More...</a><br /></td></tr>
<tr class="separator:a702d46b185233ad1fa56ee7033eabd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab963e59ba11ee8e43e8e1fe3482fa377"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ab963e59ba11ee8e43e8e1fe3482fa377">TrimTrailingZeros</a> (const std::string &amp;Str)</td></tr>
<tr class="memdesc:ab963e59ba11ee8e43e8e1fe3482fa377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes trailing zeros ('\0') from a string.  <a href="namespaceUtil.html#ab963e59ba11ee8e43e8e1fe3482fa377">More...</a><br /></td></tr>
<tr class="separator:ab963e59ba11ee8e43e8e1fe3482fa377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595e45049086b60cd1cc7ce79fff369b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a595e45049086b60cd1cc7ce79fff369b">CurrentTimeAndDateString</a> ()</td></tr>
<tr class="memdesc:a595e45049086b60cd1cc7ce79fff369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable string describing the current time and date in the current time zone.  <a href="namespaceUtil.html#a595e45049086b60cd1cc7ce79fff369b">More...</a><br /></td></tr>
<tr class="separator:a595e45049086b60cd1cc7ce79fff369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd61e68ce03cc8686779f38d354d40"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a25dd61e68ce03cc8686779f38d354d40">FilenameFromPath</a> (std::string Path)</td></tr>
<tr class="memdesc:a25dd61e68ce03cc8686779f38d354d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the filename from a path.  <a href="namespaceUtil.html#a25dd61e68ce03cc8686779f38d354d40">More...</a><br /></td></tr>
<tr class="separator:a25dd61e68ce03cc8686779f38d354d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f34c2470241f4648bf004d6b342005"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ab6f34c2470241f4648bf004d6b342005">RemoveExtFromPath</a> (std::string Path)</td></tr>
<tr class="memdesc:ab6f34c2470241f4648bf004d6b342005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the filename's extension from a path.  <a href="namespaceUtil.html#ab6f34c2470241f4648bf004d6b342005">More...</a><br /></td></tr>
<tr class="separator:ab6f34c2470241f4648bf004d6b342005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3da43074568850d2691bfa052f1e445"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ab3da43074568850d2691bfa052f1e445">ToStr</a> (const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;Version)</td></tr>
<tr class="memdesc:ab3da43074568850d2691bfa052f1e445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a program version to a string in the form specified by <code><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType" title="Data type describing DynExp&#39;s program version in the form Major.Minor.Patch.">VersionType</a></code>.  <a href="namespaceUtil.html#ab3da43074568850d2691bfa052f1e445">More...</a><br /></td></tr>
<tr class="separator:ab3da43074568850d2691bfa052f1e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b50c45e3e7042beb21d70af3678c42"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a45b50c45e3e7042beb21d70af3678c42"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; Ts... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a45b50c45e3e7042beb21d70af3678c42">ParseCSV</a> (const std::string &amp;CSVData, const char Delimiter=';', const size_t SkipLines=0)</td></tr>
<tr class="memdesc:a45b50c45e3e7042beb21d70af3678c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string containing comma-separated values (csv) and inserts each row as one tuple containing column data into a vector of tuples.  <a href="namespaceUtil.html#a45b50c45e3e7042beb21d70af3678c42">More...</a><br /></td></tr>
<tr class="separator:a45b50c45e3e7042beb21d70af3678c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DOM functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions can be used to walk through an (XML-)DOM tree. </p>
</div></td></tr>
<tr class="memitem:a80d8a5a00dfbbdff8c6085a1db67c639"><td class="memItemLeft" align="right" valign="top">std::vector&lt; QDomNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a80d8a5a00dfbbdff8c6085a1db67c639">GetChildDOMNodes</a> (const QDomElement &amp;Parent, const QString &amp;ChildTagName)</td></tr>
<tr class="memdesc:a80d8a5a00dfbbdff8c6085a1db67c639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds child nodes with a certain tag name.  <a href="namespaceUtil.html#a80d8a5a00dfbbdff8c6085a1db67c639">More...</a><br /></td></tr>
<tr class="separator:a80d8a5a00dfbbdff8c6085a1db67c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5019de5098e712affed41aac58a0475"><td class="memItemLeft" align="right" valign="top">QDomNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475">GetSingleChildDOMNode</a> (const QDomElement &amp;Parent, const QString &amp;ChildTagName)</td></tr>
<tr class="memdesc:ad5019de5098e712affed41aac58a0475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a single child node with a certain tag name.  <a href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475">More...</a><br /></td></tr>
<tr class="separator:ad5019de5098e712affed41aac58a0475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7ae9eba3886578c2aae78591b68a28"><td class="memItemLeft" align="right" valign="top">QDomElement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a3a7ae9eba3886578c2aae78591b68a28">GetSingleChildDOMElement</a> (const QDomElement &amp;Parent, const QString &amp;ChildTagName)</td></tr>
<tr class="memdesc:a3a7ae9eba3886578c2aae78591b68a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaves like <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a> but returns the node converted to a DOM element.  <a href="namespaceUtil.html#a3a7ae9eba3886578c2aae78591b68a28">More...</a><br /></td></tr>
<tr class="separator:a3a7ae9eba3886578c2aae78591b68a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52828c76c1701c77645aa0dcfc8b8ad7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a52828c76c1701c77645aa0dcfc8b8ad7">GetStringFromDOMElement</a> (const QDomElement &amp;Parent, const QString &amp;ChildTagName)</td></tr>
<tr class="memdesc:a52828c76c1701c77645aa0dcfc8b8ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaves like <a class="el" href="namespaceUtil.html#a3a7ae9eba3886578c2aae78591b68a28" title="Behaves like GetSingleChildDOMNode() but returns the node converted to a DOM element.">GetSingleChildDOMElement()</a> but returns the text from a DOM element.  <a href="namespaceUtil.html#a52828c76c1701c77645aa0dcfc8b8ad7">More...</a><br /></td></tr>
<tr class="separator:a52828c76c1701c77645aa0dcfc8b8ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41076795aaafcffc06df4a8b3807f1e1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a41076795aaafcffc06df4a8b3807f1e1"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a41076795aaafcffc06df4a8b3807f1e1">GetTFromDOMElement</a> (const QDomElement &amp;Parent, const QString &amp;ChildTagName)</td></tr>
<tr class="memdesc:a41076795aaafcffc06df4a8b3807f1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaves like <a class="el" href="namespaceUtil.html#a3a7ae9eba3886578c2aae78591b68a28" title="Behaves like GetSingleChildDOMNode() but returns the node converted to a DOM element.">GetSingleChildDOMElement()</a> but returns the content from a DOM element converted to a certain type using <a class="el" href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9" title="Converts a std::string to a value of type T using operator&lt;&lt; of std::stringstream.">Util::StrToT()</a>.  <a href="namespaceUtil.html#a41076795aaafcffc06df4a8b3807f1e1">More...</a><br /></td></tr>
<tr class="separator:a41076795aaafcffc06df4a8b3807f1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e92fff10a06354be9fc0105fe5dc49"><td class="memItemLeft" align="right" valign="top">QDomAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49">GetDOMAttribute</a> (const QDomElement &amp;Element, const QString &amp;AttributeName)</td></tr>
<tr class="memdesc:ad0e92fff10a06354be9fc0105fe5dc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an attribute from a DOM element.  <a href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49">More...</a><br /></td></tr>
<tr class="separator:ad0e92fff10a06354be9fc0105fe5dc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff633244c02e60fab457eb52fe1df33b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aff633244c02e60fab457eb52fe1df33b">GetStringFromDOMAttribute</a> (const QDomElement &amp;Element, const QString &amp;AttributeName)</td></tr>
<tr class="memdesc:aff633244c02e60fab457eb52fe1df33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaves like <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a> but returns the text from the attribute.  <a href="namespaceUtil.html#aff633244c02e60fab457eb52fe1df33b">More...</a><br /></td></tr>
<tr class="separator:aff633244c02e60fab457eb52fe1df33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2668468a7589daa98b6cec9858b78b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2e2668468a7589daa98b6cec9858b78b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a2e2668468a7589daa98b6cec9858b78b">GetTFromDOMAttribute</a> (const QDomElement &amp;Element, const QString &amp;AttributeName)</td></tr>
<tr class="memdesc:a2e2668468a7589daa98b6cec9858b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaves like <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a> but returns the content from an attribute converted to a certain type using <a class="el" href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9" title="Converts a std::string to a value of type T using operator&lt;&lt; of std::stringstream.">Util::StrToT()</a>.  <a href="namespaceUtil.html#a2e2668468a7589daa98b6cec9858b78b">More...</a><br /></td></tr>
<tr class="separator:a2e2668468a7589daa98b6cec9858b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File open and save dialogs</div></td></tr>
<tr class="memitem:a97c71397651d7182d9b8ed5d98861bd9"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9">PromptOpenFilePath</a> (QWidget *Parent, const QString &amp;Title, const QString &amp;DefaultSuffix, const QString &amp;NameFilter, const QString &amp;InitialDirectory=&quot;&quot;)</td></tr>
<tr class="memdesc:a97c71397651d7182d9b8ed5d98861bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file dialog to ask the user to select a single existing file.  <a href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9">More...</a><br /></td></tr>
<tr class="separator:a97c71397651d7182d9b8ed5d98861bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9aa045f3a18d918a4e01b559c34a5a"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aee9aa045f3a18d918a4e01b559c34a5a">PromptSaveFilePath</a> (QWidget *Parent, const QString &amp;Title, const QString &amp;DefaultSuffix, const QString &amp;NameFilter, const QString &amp;InitialDirectory=&quot;&quot;)</td></tr>
<tr class="memdesc:aee9aa045f3a18d918a4e01b559c34a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Works as <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a> but asks the user to select a single file which does not need to exist.  <a href="namespaceUtil.html#aee9aa045f3a18d918a4e01b559c34a5a">More...</a><br /></td></tr>
<tr class="separator:aee9aa045f3a18d918a4e01b559c34a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe245d507bf5b88d763f42878c8ec73"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#afbe245d507bf5b88d763f42878c8ec73">PromptSaveFilePathModule</a> (<a class="el" href="classDynExp_1_1QModuleWidget.html">DynExp::QModuleWidget</a> *Parent, const QString &amp;Title, const QString &amp;DefaultSuffix, const QString &amp;NameFilter)</td></tr>
<tr class="memdesc:afbe245d507bf5b88d763f42878c8ec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Works as <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a> but asks the user to select a single file which does not need to exist. Furthermore, the dialog automatically derives the initial directory using QModuleWidget::GetDataSaveDirectory() and sets the new global directory for saving data to the folder containing the selected file when the user accepts the dialog.  <a href="namespaceUtil.html#afbe245d507bf5b88d763f42878c8ec73">More...</a><br /></td></tr>
<tr class="separator:afbe245d507bf5b88d763f42878c8ec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading and writing files</div></td></tr>
<tr class="memitem:a359fc895768ae094dc278df3235b5ce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a359fc895768ae094dc278df3235b5ce3">SaveToFile</a> (const QString &amp;Filename, std::string_view Text)</td></tr>
<tr class="memdesc:a359fc895768ae094dc278df3235b5ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a std::string_view to a file (using QFile). Creates a new file or truncates an existing file's content.  <a href="namespaceUtil.html#a359fc895768ae094dc278df3235b5ce3">More...</a><br /></td></tr>
<tr class="separator:a359fc895768ae094dc278df3235b5ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae320b654ab22ae7854eebfdaf85c2c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aae320b654ab22ae7854eebfdaf85c2c0">ReadFromFile</a> (const QString &amp;Filename)</td></tr>
<tr class="memdesc:aae320b654ab22ae7854eebfdaf85c2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the entire content from a text file.  <a href="namespaceUtil.html#aae320b654ab22ae7854eebfdaf85c2c0">More...</a><br /></td></tr>
<tr class="separator:aae320b654ab22ae7854eebfdaf85c2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073bfb9f53cf13d1b73117edf066abb8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a073bfb9f53cf13d1b73117edf066abb8">ReadFromFile</a> (const std::string &amp;Filename)</td></tr>
<tr class="memdesc:a073bfb9f53cf13d1b73117edf066abb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the entire content from a text file.  <a href="namespaceUtil.html#a073bfb9f53cf13d1b73117edf066abb8">More...</a><br /></td></tr>
<tr class="separator:a073bfb9f53cf13d1b73117edf066abb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a495a1040e873e0d0e36e8c31937d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a46a495a1040e873e0d0e36e8c31937d6">ReadFromFile</a> (const std::filesystem::path &amp;Filename)</td></tr>
<tr class="memdesc:a46a495a1040e873e0d0e36e8c31937d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the entire content from a text file.  <a href="namespaceUtil.html#a46a495a1040e873e0d0e36e8c31937d6">More...</a><br /></td></tr>
<tr class="separator:a46a495a1040e873e0d0e36e8c31937d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaa3490cda96786eb40f5fd6a386b6042"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aaa3490cda96786eb40f5fd6a386b6042">PyTab</a> = &quot; &quot;</td></tr>
<tr class="memdesc:aaa3490cda96786eb40f5fd6a386b6042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character sequence to indent a Python instruction by one level.  <a href="namespaceUtil.html#aaa3490cda96786eb40f5fd6a386b6042">More...</a><br /></td></tr>
<tr class="separator:aaa3490cda96786eb40f5fd6a386b6042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132b3de3103b01ab172ee946b4ad0c96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... ListTs&gt; </td></tr>
<tr class="memitem:a132b3de3103b01ab172ee946b4ad0c96"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a132b3de3103b01ab172ee946b4ad0c96">is_contained_in_v</a> = <a class="el" href="structUtil_1_1is__contained__in.html">is_contained_in</a>&lt;T, ListTs...&gt;::value</td></tr>
<tr class="memdesc:a132b3de3103b01ab172ee946b4ad0c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type of <code><a class="el" href="structUtil_1_1is__contained__in.html" title="Checks whether a type T is contained in a template parameter pack of types ListTs.">is_contained_in</a></code>.  <a href="namespaceUtil.html#a132b3de3103b01ab172ee946b4ad0c96">More...</a><br /></td></tr>
<tr class="separator:a132b3de3103b01ab172ee946b4ad0c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Image manipulation</h2></td></tr>
<tr class="memitem:a943cefcf0c692b741e6e1fa2cea37065"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a> = std::array&lt; unsigned long long, 256 &gt;</td></tr>
<tr class="memdesc:a943cefcf0c692b741e6e1fa2cea37065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias which represents a histogram as a std::array with 256 numeric bins. The lowest (highest) index represents the darkest (brightest) intensity.  <a href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">More...</a><br /></td></tr>
<tr class="separator:a943cefcf0c692b741e6e1fa2cea37065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63fda4680b61c4dc62f55c7b422c5e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">ImageRGBHistogramType</a> = std::tuple&lt; <a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>, <a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>, <a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a> &gt;</td></tr>
<tr class="memdesc:ae63fda4680b61c4dc62f55c7b422c5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias which represents a RGB histogram as a std::tuple of three <code>ImageHistogramType</code> elements. The first tuple element represents the histogram for red, the second for green, the third for blue.  <a href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">More...</a><br /></td></tr>
<tr class="separator:ae63fda4680b61c4dc62f55c7b422c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df21e866ae29371e55201b229261fd1"><td class="memItemLeft" align="right" valign="top">QImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a8df21e866ae29371e55201b229261fd1">QImageFromBlobData</a> (<a class="el" href="classUtil_1_1BlobDataType.html">BlobDataType</a> &amp;&amp;BlobData, int Width, int Height, int BytesPerLine, QImage::Format Format)</td></tr>
<tr class="memdesc:a8df21e866ae29371e55201b229261fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts raw pixel data stored in a <a class="el" href="classUtil_1_1BlobDataType.html" title="Data type which manages a binary large object. The reserved memory is freed upon destruction.">Util::BlobDataType</a> object to a QImage transfering the ownership of <code>BlobData's</code> content.  <a href="namespaceUtil.html#a8df21e866ae29371e55201b229261fd1">More...</a><br /></td></tr>
<tr class="separator:a8df21e866ae29371e55201b229261fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa153bddf1ff14531ebb96f59caf76295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa153bddf1ff14531ebb96f59caf76295">ComputeIntensityHistogram</a> (const QImage &amp;Image)</td></tr>
<tr class="memdesc:aa153bddf1ff14531ebb96f59caf76295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an intensity (grayscale) histogram from a QImage object.  <a href="namespaceUtil.html#aa153bddf1ff14531ebb96f59caf76295">More...</a><br /></td></tr>
<tr class="separator:aa153bddf1ff14531ebb96f59caf76295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9831d489b2dfe15f00b9bffaace1432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">ImageRGBHistogramType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#af9831d489b2dfe15f00b9bffaace1432">ComputeRGBHistogram</a> (const QImage &amp;Image)</td></tr>
<tr class="memdesc:af9831d489b2dfe15f00b9bffaace1432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a RGB histogram from a QImage object.  <a href="namespaceUtil.html#af9831d489b2dfe15f00b9bffaace1432">More...</a><br /></td></tr>
<tr class="separator:af9831d489b2dfe15f00b9bffaace1432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd9276ae216d126f7a47ed94affbef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a2fd9276ae216d126f7a47ed94affbef3">ConvertRGBToIntensityHistogram</a> (const <a class="el" href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">ImageRGBHistogramType</a> &amp;RGBHistogram)</td></tr>
<tr class="memdesc:a2fd9276ae216d126f7a47ed94affbef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an intensity (grayscale) histogram from a RGB histogram.  <a href="namespaceUtil.html#a2fd9276ae216d126f7a47ed94affbef3">More...</a><br /></td></tr>
<tr class="separator:a2fd9276ae216d126f7a47ed94affbef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce0fdf9a70d472a2bce6e342652f77"><td class="memItemLeft" align="right" valign="top">QPolygonF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a85ce0fdf9a70d472a2bce6e342652f77">MakeCrossPolygon</a> (QPointF Center, unsigned int ArmLength)</td></tr>
<tr class="memdesc:a85ce0fdf9a70d472a2bce6e342652f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a QPolygonF representing a cross-style marker.  <a href="namespaceUtil.html#a85ce0fdf9a70d472a2bce6e342652f77">More...</a><br /></td></tr>
<tr class="separator:a85ce0fdf9a70d472a2bce6e342652f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Conversion functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9c2e8a06d85d2c9b83b5a0d27e85d535"></a>These functions can be used to convert between different number and string types. </p>
</td></tr>
<tr class="memitem:aac7f18dbdcac4a7036045cc4f93a283c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aac7f18dbdcac4a7036045cc4f93a283c">seconds</a> = std::chrono::duration&lt; double &gt;</td></tr>
<tr class="memdesc:aac7f18dbdcac4a7036045cc4f93a283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::chrono by a duration data type for seconds capable of storing fractions of seconds.  <a href="namespaceUtil.html#aac7f18dbdcac4a7036045cc4f93a283c">More...</a><br /></td></tr>
<tr class="separator:aac7f18dbdcac4a7036045cc4f93a283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99231f65c9cf8ce2d11f5768579cec5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a99231f65c9cf8ce2d11f5768579cec5f">picoseconds</a> = std::chrono::duration&lt; double, std::pico &gt;</td></tr>
<tr class="memdesc:a99231f65c9cf8ce2d11f5768579cec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::chrono by a duration data type for picoseconds.  <a href="namespaceUtil.html#a99231f65c9cf8ce2d11f5768579cec5f">More...</a><br /></td></tr>
<tr class="separator:a99231f65c9cf8ce2d11f5768579cec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ef4e82617597bfa95d4b9f0e8e05b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0ef4e82617597bfa95d4b9f0e8e05b9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa0ef4e82617597bfa95d4b9f0e8e05b9">operator&lt;&lt;</a> (std::ostream &amp;stream, const std::chrono::time_point&lt; T &gt; &amp;TimePoint)</td></tr>
<tr class="memdesc:aa0ef4e82617597bfa95d4b9f0e8e05b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a time point to a human-readable string describing the time in the current time zone and writes the string to a stream.  <a href="namespaceUtil.html#aa0ef4e82617597bfa95d4b9f0e8e05b9">More...</a><br /></td></tr>
<tr class="separator:aa0ef4e82617597bfa95d4b9f0e8e05b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9">StrToT</a> (const std::string &amp;String)</td></tr>
<tr class="memdesc:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::string to a value of type <code>T</code> using operator&lt;&lt; of std::stringstream.  <a href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9">More...</a><br /></td></tr>
<tr class="separator:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119393dd8b76c86ab5ec5993f2b2d568"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a119393dd8b76c86ab5ec5993f2b2d568"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a119393dd8b76c86ab5ec5993f2b2d568">ToStr</a> (const T &amp;Value, int Precision=-1)</td></tr>
<tr class="memdesc:a119393dd8b76c86ab5ec5993f2b2d568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (numeric) value of type <code>T</code> to a std::string using operator&lt;&lt; of std::stringstream.  <a href="namespaceUtil.html#a119393dd8b76c86ab5ec5993f2b2d568">More...</a><br /></td></tr>
<tr class="separator:a119393dd8b76c86ab5ec5993f2b2d568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d745d985db64b4802ddb1676ebb7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716d745d985db64b4802ddb1676ebb7e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a716d745d985db64b4802ddb1676ebb7e">ToStr</a> (const std::chrono::time_point&lt; T &gt; &amp;TimePoint)</td></tr>
<tr class="memdesc:a716d745d985db64b4802ddb1676ebb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a time point to a human-readable string describing the time in the current time zone.  <a href="namespaceUtil.html#a716d745d985db64b4802ddb1676ebb7e">More...</a><br /></td></tr>
<tr class="separator:a716d745d985db64b4802ddb1676ebb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f025c80e3fc21a12332d3cce451f0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a678f025c80e3fc21a12332d3cce451f0">ToStr</a> (const char Value)</td></tr>
<tr class="memdesc:a678f025c80e3fc21a12332d3cce451f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>Value</code> to a std::string using operator&lt;&lt; of std::stringstream.  <a href="namespaceUtil.html#a678f025c80e3fc21a12332d3cce451f0">More...</a><br /></td></tr>
<tr class="separator:a678f025c80e3fc21a12332d3cce451f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f30c5ceb81ed16e4b2284ba799fea4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a98f30c5ceb81ed16e4b2284ba799fea4">ToStr</a> (const uint8_t Value)</td></tr>
<tr class="memdesc:a98f30c5ceb81ed16e4b2284ba799fea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>Value</code> to a std::string using operator&lt;&lt; of std::stringstream.  <a href="namespaceUtil.html#a98f30c5ceb81ed16e4b2284ba799fea4">More...</a><br /></td></tr>
<tr class="separator:a98f30c5ceb81ed16e4b2284ba799fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5622dfde1ba9fbbc1706dafd4c515"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a16a5622dfde1ba9fbbc1706dafd4c515">ToStr</a> (const QString &amp;Str)</td></tr>
<tr class="memdesc:a16a5622dfde1ba9fbbc1706dafd4c515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Qt QString <code>Str</code> to a std::string.  <a href="namespaceUtil.html#a16a5622dfde1ba9fbbc1706dafd4c515">More...</a><br /></td></tr>
<tr class="separator:a16a5622dfde1ba9fbbc1706dafd4c515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="memTemplParams" colspan="2">template&lt;typename ToT , typename FromT , std::enable_if_t&lt; std::is_integral_v&lt; ToT &gt; &amp;&amp;std::is_integral_v&lt; FromT &gt; &amp;&amp;std::is_same_v&lt; std::remove_cv_t&lt; ToT &gt;, std::remove_cv_t&lt; FromT &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="memTemplItemLeft" align="right" valign="top">ToT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ac2ced77b741ebc83b2a34a3d6950da5f">NumToT</a> (const FromT Value)</td></tr>
<tr class="memdesc:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of a numeric type to a value of another numeric type checking the conversion for its bounds.  <a href="namespaceUtil.html#ac2ced77b741ebc83b2a34a3d6950da5f">More...</a><br /></td></tr>
<tr class="separator:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22b7f50701b786e792e23fe19776dce"><td class="memTemplParams" colspan="2">template&lt;typename ToT , std::enable_if_t&lt; std::is_integral_v&lt; ToT &gt; &amp;&amp;!std::is_same_v&lt; std::remove_cv_t&lt; ToT &gt;, double &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad22b7f50701b786e792e23fe19776dce"><td class="memTemplItemLeft" align="right" valign="top">ToT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ad22b7f50701b786e792e23fe19776dce">NumToT</a> (const double Value)</td></tr>
<tr class="memdesc:ad22b7f50701b786e792e23fe19776dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of a numeric type to a value of another numeric type checking the conversion for its bounds.  <a href="namespaceUtil.html#ad22b7f50701b786e792e23fe19776dce">More...</a><br /></td></tr>
<tr class="separator:ad22b7f50701b786e792e23fe19776dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82275ae53b547876518e83df7d911b20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82275ae53b547876518e83df7d911b20"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">ToUnitStr</a> ()</td></tr>
<tr class="memdesc:a82275ae53b547876518e83df7d911b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">More...</a><br /></td></tr>
<tr class="separator:a82275ae53b547876518e83df7d911b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291cad87815f03694922382ba402222"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1291cad87815f03694922382ba402222"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a1291cad87815f03694922382ba402222">ToUnitStr&lt; std::chrono::seconds &gt;</a> ()</td></tr>
<tr class="memdesc:a1291cad87815f03694922382ba402222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#a1291cad87815f03694922382ba402222">More...</a><br /></td></tr>
<tr class="separator:a1291cad87815f03694922382ba402222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7c26e0facbdf4807120a4b504b80d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9ff7c26e0facbdf4807120a4b504b80d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a9ff7c26e0facbdf4807120a4b504b80d">ToUnitStr&lt; std::chrono::milliseconds &gt;</a> ()</td></tr>
<tr class="memdesc:a9ff7c26e0facbdf4807120a4b504b80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#a9ff7c26e0facbdf4807120a4b504b80d">More...</a><br /></td></tr>
<tr class="separator:a9ff7c26e0facbdf4807120a4b504b80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#af59e914d8da02ba7dd5f5dbfc55315e6">ToUnitStr&lt; std::chrono::microseconds &gt;</a> ()</td></tr>
<tr class="memdesc:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#af59e914d8da02ba7dd5f5dbfc55315e6">More...</a><br /></td></tr>
<tr class="separator:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa537adcf11f5849c1466e2e864352a0e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa537adcf11f5849c1466e2e864352a0e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa537adcf11f5849c1466e2e864352a0e">ToUnitStr&lt; std::chrono::nanoseconds &gt;</a> ()</td></tr>
<tr class="memdesc:aa537adcf11f5849c1466e2e864352a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#aa537adcf11f5849c1466e2e864352a0e">More...</a><br /></td></tr>
<tr class="separator:aa537adcf11f5849c1466e2e864352a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aefe993b8fa1ecc1599afeee1dc7d0f00">ToUnitStr&lt; seconds &gt;</a> ()</td></tr>
<tr class="memdesc:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#aefe993b8fa1ecc1599afeee1dc7d0f00">More...</a><br /></td></tr>
<tr class="separator:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cde03413439d0e856d6b4d5e2f750e7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4cde03413439d0e856d6b4d5e2f750e7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a4cde03413439d0e856d6b4d5e2f750e7">ToUnitStr&lt; picoseconds &gt;</a> ()</td></tr>
<tr class="memdesc:a4cde03413439d0e856d6b4d5e2f750e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <a href="namespaceUtil.html#a4cde03413439d0e856d6b4d5e2f750e7">More...</a><br /></td></tr>
<tr class="separator:a4cde03413439d0e856d6b4d5e2f750e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DynExp's Util namespace contains commonly used functions and templates as well as extensions to Qt and its widgets. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structUtil_1_1member__fn__ptr__traits" id="structUtil_1_1member__fn__ptr__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits">&#9670;&nbsp;</a></span>Util::member_fn_ptr_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename CallableT&gt;<br />
struct Util::member_fn_ptr_traits&lt; CallableT &gt;</h3>

<p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00312">312</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div>
</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4">&#9670;&nbsp;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</h3>

<p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00318">318</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a359414f7f25f418dbe2b32cfd996b98a"></a></td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa0c3334749702c89ddb6eb64ffdffad4"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae7be2e35117c9da11121a635279c76f1"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4">&#9670;&nbsp;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</h3>

<p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00329">329</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abd5f067575b81ee90003fe0dc52e279e"></a></td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8551dd7ff787aada7f593f6462aec9b4"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a252d72b4bf9c71214ec38849242444cd"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4">&#9670;&nbsp;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</h3>

<p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00340">340</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a57d1dbd6e1af56558b7f2bdb13d5e1a0"></a></td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ad39776ff6486804499a93776ed9fd861"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a316ecfe7f2048362863abeed3386c045"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4">&#9670;&nbsp;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</h3>

<p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00351">351</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a797b47ca0beb7a2fb8e455deed6b4d91"></a></td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a00cd3fe658c233de4019c0e72d9ff755"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a22312ae643f35e45189704ed2a092619"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1remove__first__from__tuple" id="structUtil_1_1remove__first__from__tuple"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1remove__first__from__tuple">&#9670;&nbsp;</a></span>Util::remove_first_from_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::remove_first_from_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename TupleT&gt;<br />
struct Util::remove_first_from_tuple&lt; TupleT &gt;</h3>

<p>Removes first type from a tuple of types <code>TupleT</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00380">380</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div>
</div>
</div>
<a name="structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4" id="structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename FirstElementT, typename... ElementTs&gt;<br />
struct Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</h3>

<p>Removes first type from a tuple of types <code>TupleT</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00386">386</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a38acd6f45f6ede16e2091a3a58e12ff3"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1OffsetIndexSequence" id="structUtil_1_1OffsetIndexSequence"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1OffsetIndexSequence">&#9670;&nbsp;</a></span>Util::OffsetIndexSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::OffsetIndexSequence</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t Offset, typename IndexSequence&gt;<br />
struct Util::OffsetIndexSequence&lt; Offset, IndexSequence &gt;</h3>

<p>Holds an alias for a std::index_sequence where all indices are shifted by an offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexSequence</td><td>Indices passes as template arguments to std::index_sequence </td></tr>
    <tr><td class="paramname">Offset</td><td>Offset added to all indices </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00402">402</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div>
</div>
</div>
<a name="structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4" id="structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4">&#9670;&nbsp;</a></span>Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t Offset, size_t... Indices&gt;<br />
struct Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</h3>

<p>Holds an alias for a std::index_sequence where all indices are shifted by an offset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexSequence</td><td>Indices passes as template arguments to std::index_sequence </td></tr>
    <tr><td class="paramname">Offset</td><td>Offset added to all indices </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00408">408</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a2264e7d262e0a58e4788c91500ad10a3"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
Alias for offset index sequence. </td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1RangeIndexSequence" id="structUtil_1_1RangeIndexSequence"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1RangeIndexSequence">&#9670;&nbsp;</a></span>Util::RangeIndexSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::RangeIndexSequence</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t From, size_t To&gt;<br />
struct Util::RangeIndexSequence&lt; From, To &gt;</h3>

<p>Holds an alias for a std::index_sequence spanning a certain range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">From</td><td>Start value the index sequency begins with </td></tr>
    <tr><td class="paramname">To</td><td>Last value contained in the index sequence </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00428">428</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="af945ff47b624ef31faa420f49a255a95"></a>typedef <a class="el" href="namespaceUtil.html#a6efc4b7656b284a6b140d130326c384f">OffsetIndexSequence_t</a>&lt; From, make_index_sequence&lt; To - From &gt; &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1VersionType" id="structUtil_1_1VersionType"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1VersionType">&#9670;&nbsp;</a></span>Util::VersionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::VersionType</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data type describing DynExp's program version in the form Major.Minor.Patch. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00858">858</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a6ad097a2ead91db7a7321452d34b703d"></a>unsigned int</td>
<td class="fieldname">
Major</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a84f1462fdbcf415382d3d3fc36fee5ca"></a>unsigned int</td>
<td class="fieldname">
Minor</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="add57d9a4e11595bc40658b53acfbee5a"></a>unsigned int</td>
<td class="fieldname">
Patch</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aee9535f26f425537e00abc71ed6a3b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9535f26f425537e00abc71ed6a3b7a">&#9670;&nbsp;</a></span>argument_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#aee9535f26f425537e00abc71ed6a3b7a">Util::argument_of_t</a> = typedef typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt;CallableT&gt;::argument_types</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a tuple of argument types the member function callable of type <code>CallableT</code> expects. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00374">374</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a943cefcf0c692b741e6e1fa2cea37065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943cefcf0c692b741e6e1fa2cea37065">&#9670;&nbsp;</a></span>ImageHistogramType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">Util::ImageHistogramType</a> = typedef std::array&lt;unsigned long long, 256&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias which represents a histogram as a std::array with 256 numeric bins. The lowest (highest) index represents the darkest (brightest) intensity. </p>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00244">244</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="ae63fda4680b61c4dc62f55c7b422c5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63fda4680b61c4dc62f55c7b422c5e8">&#9670;&nbsp;</a></span>ImageRGBHistogramType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">Util::ImageRGBHistogramType</a> = typedef std::tuple&lt;<a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>, <a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>, <a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias which represents a RGB histogram as a std::tuple of three <code>ImageHistogramType</code> elements. The first tuple element represents the histogram for red, the second for green, the third for blue. </p>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00250">250</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="a119ab45e422a49c79f58028ff1ed09d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119ab45e422a49c79f58028ff1ed09d5">&#9670;&nbsp;</a></span>instance_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a119ab45e422a49c79f58028ff1ed09d5">Util::instance_of_t</a> = typedef typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt;CallableT&gt;::instance_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the class type a member function callable of type <code>CallableT</code> is member of. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00368">368</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a6efc4b7656b284a6b140d130326c384f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efc4b7656b284a6b140d130326c384f">&#9670;&nbsp;</a></span>OffsetIndexSequence_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Offset, typename IndexSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a6efc4b7656b284a6b140d130326c384f">Util::OffsetIndexSequence_t</a> = typedef typename <a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence">OffsetIndexSequence</a>&lt;Offset, IndexSequence&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for type contained in <code><a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence" title="Holds an alias for a std::index_sequence where all indices are shifted by an offset.">OffsetIndexSequence</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00420">420</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a99231f65c9cf8ce2d11f5768579cec5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99231f65c9cf8ce2d11f5768579cec5f">&#9670;&nbsp;</a></span>picoseconds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a99231f65c9cf8ce2d11f5768579cec5f">Util::picoseconds</a> = typedef std::chrono::duration&lt;double, std::pico&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends std::chrono by a duration data type for picoseconds. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00762">762</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="abe0533638c16abf01f66d3397a281f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0533638c16abf01f66d3397a281f73">&#9670;&nbsp;</a></span>RangeIndexSequence_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t From, size_t To&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#abe0533638c16abf01f66d3397a281f73">Util::RangeIndexSequence_t</a> = typedef typename <a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">RangeIndexSequence</a>&lt;From, To&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for type contained in <code><a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence" title="Holds an alias for a std::index_sequence spanning a certain range.">RangeIndexSequence</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00437">437</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a6567c7f10bb5d827f0df893e13698aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6567c7f10bb5d827f0df893e13698aee">&#9670;&nbsp;</a></span>remove_first_from_tuple_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a6567c7f10bb5d827f0df893e13698aee">Util::remove_first_from_tuple_t</a> = typedef typename <a class="el" href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple">remove_first_from_tuple</a>&lt;TupleT&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a tuple of types where the first type of the input tuple <code>TupleT</code> is removed. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00392">392</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a81f4ac72ff1d4ad593754196eead2565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f4ac72ff1d4ad593754196eead2565">&#9670;&nbsp;</a></span>return_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CallableT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a81f4ac72ff1d4ad593754196eead2565">Util::return_of_t</a> = typedef typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt;CallableT&gt;::return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the return type of a member function callable of type <code>CallableT</code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00362">362</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="aac7f18dbdcac4a7036045cc4f93a283c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7f18dbdcac4a7036045cc4f93a283c">&#9670;&nbsp;</a></span>seconds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#aac7f18dbdcac4a7036045cc4f93a283c">Util::seconds</a> = typedef std::chrono::duration&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends std::chrono by a duration data type for seconds capable of storing fractions of seconds. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00761">761</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a41705d4222604e87171ef1133477ac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41705d4222604e87171ef1133477ac1d">&#9670;&nbsp;</a></span>TextListIndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a41705d4222604e87171ef1133477ac1d">Util::TextListIndexType</a> = typedef size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List index type of <code><a class="el" href="namespaceUtil.html#a2be935d029b0d65c176e549a5f4329d4" title="List type of text-type parameters.">Util::TextListType</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00030">30</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="a2be935d029b0d65c176e549a5f4329d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be935d029b0d65c176e549a5f4329d4">&#9670;&nbsp;</a></span>TextListType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a2be935d029b0d65c176e549a5f4329d4">Util::TextListType</a> = typedef std::vector&lt;<a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">TextType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List type of text-type parameters. </p>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00029">29</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="a6ff0ca7e2d8ab44f604a60f2ab5b94fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff0ca7e2d8ab44f604a60f2ab5b94fa">&#9670;&nbsp;</a></span>TextRefType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#a6ff0ca7e2d8ab44f604a60f2ab5b94fa">Util::TextRefType</a> = typedef std::string_view</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference-to-string type of text-type parameters (<a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">DynExp::ParamsBase::Param</a>) </p>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00028">28</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="ae4e8f4a1305aa88e268e5042ba89ff32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e8f4a1305aa88e268e5042ba89ff32">&#9670;&nbsp;</a></span>TextType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">Util::TextType</a> = typedef std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String type of text-type parameters (<a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">DynExp::ParamsBase::Param</a>) </p>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00027">27</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="ae830fe52c0bdb97fc86cb28f7882526a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae830fe52c0bdb97fc86cb28f7882526a">&#9670;&nbsp;</a></span>TextValueListType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceUtil.html#ae830fe52c0bdb97fc86cb28f7882526a">Util::TextValueListType</a> = typedef std::vector&lt;std::pair&lt;<a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32">TextType</a>, ValueType&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a list containing key-value pairs where key is a text of type <code><a class="el" href="namespaceUtil.html#ae4e8f4a1305aa88e268e5042ba89ff32" title="String type of text-type parameters (DynExp::ParamsBase::Param)">Util::TextType</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Value-type assocaited with a text-type key </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00037">37</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae3347e48d6767776339d0ccffe6f1041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3347e48d6767776339d0ccffe6f1041">&#9670;&nbsp;</a></span>ErrorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceUtil.html#ae3347e48d6767776339d0ccffe6f1041">Util::ErrorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DynExp's error types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae3347e48d6767776339d0ccffe6f1041a4059b0251f66a18cb56f544728796875"></a>Info&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae3347e48d6767776339d0ccffe6f1041a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae3347e48d6767776339d0ccffe6f1041a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae3347e48d6767776339d0ccffe6f1041a882384ec38ce8d9582b57e70861730e4"></a>Fatal&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Exception_8h_source.html#l00015">15</a> of file <a class="el" href="Exception_8h_source.html">Exception.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa20a78ec763492c5acf6c685782fbfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20a78ec763492c5acf6c685782fbfd2">&#9670;&nbsp;</a></span>ActivateWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::ActivateWindow </td>
          <td>(</td>
          <td class="paramtype">QWidget &amp;&#160;</td>
          <td class="paramname"><em>Widget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a window active and brings it to the front. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Widget</td><td>representing a Qt (dialog) window </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00229">229</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="aa153bddf1ff14531ebb96f59caf76295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa153bddf1ff14531ebb96f59caf76295">&#9670;&nbsp;</a></span>ComputeIntensityHistogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a> Util::ComputeIntensityHistogram </td>
          <td>(</td>
          <td class="paramtype">const QImage &amp;&#160;</td>
          <td class="paramname"><em>Image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an intensity (grayscale) histogram from a QImage object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Image</td><td>Image to compute histogram from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the histogram as an std::array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00171">171</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="af9831d489b2dfe15f00b9bffaace1432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9831d489b2dfe15f00b9bffaace1432">&#9670;&nbsp;</a></span>ComputeRGBHistogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">ImageRGBHistogramType</a> Util::ComputeRGBHistogram </td>
          <td>(</td>
          <td class="paramtype">const QImage &amp;&#160;</td>
          <td class="paramname"><em>Image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a RGB histogram from a QImage object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Image</td><td>Image to compute histogram from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the RGB histogram as a std::tuple of three intensity histograms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00186">186</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a2fd9276ae216d126f7a47ed94affbef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd9276ae216d126f7a47ed94affbef3">&#9670;&nbsp;</a></span>ConvertRGBToIntensityHistogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUtil.html#a943cefcf0c692b741e6e1fa2cea37065">ImageHistogramType</a> Util::ConvertRGBToIntensityHistogram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceUtil.html#ae63fda4680b61c4dc62f55c7b422c5e8">ImageRGBHistogramType</a> &amp;&#160;</td>
          <td class="paramname"><em>RGBHistogram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an intensity (grayscale) histogram from a RGB histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RGBHistogram</td><td>RGB histogram to compute the grayscale histogram from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the grayscale histogram as an std::array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00204">204</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a595e45049086b60cd1cc7ce79fff369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595e45049086b60cd1cc7ce79fff369b">&#9670;&nbsp;</a></span>CurrentTimeAndDateString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Util::CurrentTimeAndDateString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a human-readable string describing the current time and date in the current time zone. </p>
<dl class="section return"><dt>Returns</dt><dd>Time and date string </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00839">839</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a702d46b185233ad1fa56ee7033eabd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702d46b185233ad1fa56ee7033eabd41">&#9670;&nbsp;</a></span>EventLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtil_1_1EventLogger.html">EventLogger</a> &amp; Util::EventLog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function holds a static <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance and returns a reference to it. DynExp uses only one <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance to log events from any thread. A local static object instead of a global object is employed to avoid initialization order problems. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to DynExp's unique <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8cpp_source.html#l00509">509</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a id="a3214377992588c6e7eabe298496544af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3214377992588c6e7eabe298496544af">&#9670;&nbsp;</a></span>ExceptionToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ExceptionToStr </td>
          <td>(</td>
          <td class="paramtype">const std::exception_ptr&#160;</td>
          <td class="paramname"><em>ExceptionPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the what() information of an exception derived from std::exception and stored in an exception pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExceptionPtr</td><td>Pointer to an exception derived from std::exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::exception::what() if <code>ExceptionPtr</code> contains an exception. Empty string if <code>ExceptionPtr</code> does not contain an exception. Placeholder string if the exception stored in <code>ExceptionPtr</code> is not derived from std::exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8cpp_source.html#l00189">189</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a id="aa1d8df62a6cca9d2e0e444f533501c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d8df62a6cca9d2e0e444f533501c8d">&#9670;&nbsp;</a></span>FFT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::complex&lt; double &gt; &gt; Util::FFT </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>InverseTransform</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Fast Fourier Transform (FFT) a vector of complex values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Data</td><td>Vector of complex values to be transformed </td></tr>
    <tr><td class="paramname">InverseTransform</td><td>If true, the inverse FFT is computed. False is default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of complex values containing the computed FFT </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1OverflowException.html" title="Thrown when a numeric operation would result in an overflow (e.g. due to incompatible data types)">OverflowException</a></td><td>if <code>Data</code> contains more items than half of the maximal value <code>size_t</code> can represent. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1NotAvailableException.html" title="Thrown when some operation or feature is temporarily or permanently not available.">NotAvailableException</a></td><td>if GSL functions fail reserving memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">InvalidDataException</a></td><td>if GSL fails to perform the FFT on <code>Data</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8cpp_source.html#l00220">220</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a id="a25dd61e68ce03cc8686779f38d354d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dd61e68ce03cc8686779f38d354d40">&#9670;&nbsp;</a></span>FilenameFromPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Util::FilenameFromPath </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the filename from a path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Path</td><td>Path ending with a filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring of <code>Path</code> containing the filename </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00846">846</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a2a9f0d5782cf60eccacaa216ea9d1fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9f0d5782cf60eccacaa216ea9d1fa8">&#9670;&nbsp;</a></span>ForwardException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::ForwardException </td>
          <td>(</td>
          <td class="paramtype">std::exception_ptr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps the exception passed to the function in a <a class="el" href="classUtil_1_1ForwardedException.html" title="Class to forward an Exception instance from one DynExp::Object instance to another DynExp::Object ins...">ForwardedException</a> and throws the <a class="el" href="classUtil_1_1ForwardedException.html" title="Class to forward an Exception instance from one DynExp::Object instance to another DynExp::Object ins...">ForwardedException</a>. Does nothing if e is not an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Pointer to an exception </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Exception_8cpp_source.html#l00030">30</a> of file <a class="el" href="Exception_8cpp_source.html">Exception.cpp</a>.</p>

</div>
</div>
<a id="a80d8a5a00dfbbdff8c6085a1db67c639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d8a5a00dfbbdff8c6085a1db67c639">&#9670;&nbsp;</a></span>GetChildDOMNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; QDomNode &gt; Util::GetChildDOMNodes </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ChildTagName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds child nodes with a certain tag name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Parent node whose child nodes are searched </td></tr>
    <tr><td class="paramname">ChildTagName</td><td>Tag name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of matching child nodes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">Util::InvalidDataException</a></td><td>is thrown when <code>Parent</code> is a null node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00019">19</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a62d6fb43e8d89b0aaf434700bd746349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d6fb43e8d89b0aaf434700bd746349">&#9670;&nbsp;</a></span>GetDefaultQtLocale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QLocale &amp; Util::GetDefaultQtLocale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default locale properties to be assigned to Qt widgets. </p>
<dl class="section return"><dt>Returns</dt><dd>QLocale object initialized with DynExp's default locale settings </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00012">12</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="ad0e92fff10a06354be9fc0105fe5dc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e92fff10a06354be9fc0105fe5dc49">&#9670;&nbsp;</a></span>GetDOMAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDomAttr Util::GetDOMAttribute </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>AttributeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts an attribute from a DOM element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Element</td><td>DOM element containing the attribute </td></tr>
    <tr><td class="paramname">AttributeName</td><td>Name of the attribute to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the matching attribute. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">Util::InvalidDataException</a></td><td>is thrown if <code>Element</code> is null or if the requested attribute is invalid or does not exist. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00087">87</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a3a7ae9eba3886578c2aae78591b68a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7ae9eba3886578c2aae78591b68a28">&#9670;&nbsp;</a></span>GetSingleChildDOMElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDomElement Util::GetSingleChildDOMElement </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ChildTagName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Behaves like <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a> but returns the node converted to a DOM element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Refer to <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a>. </td></tr>
    <tr><td class="paramname">ChildTagName</td><td>Refer to <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the matching child DOM element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">Util::InvalidDataException</a></td><td>is additionally thrown if the matching DOM element is null. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00062">62</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="ad5019de5098e712affed41aac58a0475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5019de5098e712affed41aac58a0475">&#9670;&nbsp;</a></span>GetSingleChildDOMNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDomNode Util::GetSingleChildDOMNode </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ChildTagName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a single child node with a certain tag name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Parent node whose child nodes are searched </td></tr>
    <tr><td class="paramname">ChildTagName</td><td>Tag name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the matching child node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">Util::InvalidDataException</a></td><td>is thrown when <code>Parent</code> is a null node or when multiple child nodes with matching tag name have been found. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1NotFoundException.html" title="Thrown when a requested ressource does not exist.">Util::NotFoundException</a></td><td>is thrown when not any matching node has been found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00036">36</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="aff633244c02e60fab457eb52fe1df33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff633244c02e60fab457eb52fe1df33b">&#9670;&nbsp;</a></span>GetStringFromDOMAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::GetStringFromDOMAttribute </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>AttributeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Behaves like <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a> but returns the text from the attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Element</td><td>Refer to <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a>. </td></tr>
    <tr><td class="paramname">AttributeName</td><td>Refer to <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Text extracted from the matching attribute </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00099">99</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a52828c76c1701c77645aa0dcfc8b8ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52828c76c1701c77645aa0dcfc8b8ad7">&#9670;&nbsp;</a></span>GetStringFromDOMElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::GetStringFromDOMElement </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ChildTagName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Behaves like <a class="el" href="namespaceUtil.html#a3a7ae9eba3886578c2aae78591b68a28" title="Behaves like GetSingleChildDOMNode() but returns the node converted to a DOM element.">GetSingleChildDOMElement()</a> but returns the text from a DOM element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Refer to <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a>. </td></tr>
    <tr><td class="paramname">ChildTagName</td><td>Refer to <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Text extracted from a DOM element </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00073">73</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a2e2668468a7589daa98b6cec9858b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2668468a7589daa98b6cec9858b78b">&#9670;&nbsp;</a></span>GetTFromDOMAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::GetTFromDOMAttribute </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>AttributeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Behaves like <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a> but returns the content from an attribute converted to a certain type using <a class="el" href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9" title="Converts a std::string to a value of type T using operator&lt;&lt; of std::stringstream.">Util::StrToT()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert the attribute's content to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Element</td><td>Refer to <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a>. </td></tr>
    <tr><td class="paramname">AttributeName</td><td>Refer to <a class="el" href="namespaceUtil.html#ad0e92fff10a06354be9fc0105fe5dc49" title="Extracts an attribute from a DOM element.">GetDOMAttribute()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of type <code>T</code> extracted from the matching attribute </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00108">108</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a41076795aaafcffc06df4a8b3807f1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41076795aaafcffc06df4a8b3807f1e1">&#9670;&nbsp;</a></span>GetTFromDOMElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::GetTFromDOMElement </td>
          <td>(</td>
          <td class="paramtype">const QDomElement &amp;&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>ChildTagName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Behaves like <a class="el" href="namespaceUtil.html#a3a7ae9eba3886578c2aae78591b68a28" title="Behaves like GetSingleChildDOMNode() but returns the node converted to a DOM element.">GetSingleChildDOMElement()</a> but returns the content from a DOM element converted to a certain type using <a class="el" href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9" title="Converts a std::string to a value of type T using operator&lt;&lt; of std::stringstream.">Util::StrToT()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert the DOM element's content to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Refer to <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a>. </td></tr>
    <tr><td class="paramname">ChildTagName</td><td>Refer to <a class="el" href="namespaceUtil.html#ad5019de5098e712affed41aac58a0475" title="Finds a single child node with a certain tag name.">GetSingleChildDOMNode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of type <code>T</code> extracted from the matching DOM element </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00082">82</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a85ce0fdf9a70d472a2bce6e342652f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ce0fdf9a70d472a2bce6e342652f77">&#9670;&nbsp;</a></span>MakeCrossPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPolygonF Util::MakeCrossPolygon </td>
          <td>(</td>
          <td class="paramtype">QPointF&#160;</td>
          <td class="paramname"><em>Center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ArmLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a QPolygonF representing a cross-style marker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Center</td><td>Center coordinate of the marker </td></tr>
    <tr><td class="paramname">ArmLength</td><td>Length of one of the four arms of the cross. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Polygon representing the marker </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00216">216</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="ad22b7f50701b786e792e23fe19776dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22b7f50701b786e792e23fe19776dce">&#9670;&nbsp;</a></span>NumToT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ToT , std::enable_if_t&lt; std::is_integral_v&lt; ToT &gt; &amp;&amp;!std::is_same_v&lt; std::remove_cv_t&lt; ToT &gt;, double &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ToT Util::NumToT </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a value of a numeric type to a value of another numeric type checking the conversion for its bounds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ToT</td><td>Numeric type to convert to </td></tr>
    <tr><td class="paramname">FromT</td><td>Numeric type to convert from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1OutOfRangeException.html" title="Thrown when an argument passed to a function exceeds the valid range.">OutOfRangeException</a></td><td>is thrown in case <code>Value</code> of type <code>FromT</code> does not fit into type <code>ToT</code> when both integral types, <code>FromT</code> and <code>ToT</code>, are either signed or unsigned. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1OverflowException.html" title="Thrown when a numeric operation would result in an overflow (e.g. due to incompatible data types)">OverflowException</a></td><td>is thrown in case the conversion of <code>Value</code> from type <code>FromT</code> to type <code>ToT</code> would yield an overflow when one of the types, <code>FromT</code> or <code>ToT</code>, is signed and the respective other type is unsigned or when <code>FromT</code> is non-integral. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1UnderflowException.html" title="Thrown when a numeric operation would result in an underflow (e.g. due to incompatible data types)">UnderflowException</a></td><td>is thrown in case the conversion of <code>Value</code> from type <code>FromT</code> to type <code>ToT</code> would yield an underflow when one of the types, <code>FromT</code> or <code>ToT</code>, is signed and the respective other type is unsigned or when <code>FromT</code> is non-integral. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00749">749</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ac2ced77b741ebc83b2a34a3d6950da5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ced77b741ebc83b2a34a3d6950da5f">&#9670;&nbsp;</a></span>NumToT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ToT , typename FromT , std::enable_if_t&lt; std::is_integral_v&lt; ToT &gt; &amp;&amp;std::is_integral_v&lt; FromT &gt; &amp;&amp;std::is_same_v&lt; std::remove_cv_t&lt; ToT &gt;, std::remove_cv_t&lt; FromT &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ToT Util::NumToT </td>
          <td>(</td>
          <td class="paramtype">const FromT&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a value of a numeric type to a value of another numeric type checking the conversion for its bounds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ToT</td><td>Numeric type to convert to </td></tr>
    <tr><td class="paramname">FromT</td><td>Numeric type to convert from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1OutOfRangeException.html" title="Thrown when an argument passed to a function exceeds the valid range.">OutOfRangeException</a></td><td>is thrown in case <code>Value</code> of type <code>FromT</code> does not fit into type <code>ToT</code> when both integral types, <code>FromT</code> and <code>ToT</code>, are either signed or unsigned. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1OverflowException.html" title="Thrown when a numeric operation would result in an overflow (e.g. due to incompatible data types)">OverflowException</a></td><td>is thrown in case the conversion of <code>Value</code> from type <code>FromT</code> to type <code>ToT</code> would yield an overflow when one of the types, <code>FromT</code> or <code>ToT</code>, is signed and the respective other type is unsigned or when <code>FromT</code> is non-integral. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1UnderflowException.html" title="Thrown when a numeric operation would result in an underflow (e.g. due to incompatible data types)">UnderflowException</a></td><td>is thrown in case the conversion of <code>Value</code> from type <code>FromT</code> to type <code>ToT</code> would yield an underflow when one of the types, <code>FromT</code> or <code>ToT</code>, is signed and the respective other type is unsigned or when <code>FromT</code> is non-integral. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00687">687</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ad4cd00e28ff76f7cff0a2d9c08c8f943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cd00e28ff76f7cff0a2d9c08c8f943">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUtil_1_1Exception.html">Exception</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a DynExp exception in a user-readable way to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Stream to write to </td></tr>
    <tr><td class="paramname">e</td><td><a class="el" href="classUtil_1_1Exception.html" title="DynExp exceptions are derived from this class. It contains basic information about the cause of the e...">Exception</a> to be logged to the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the same stream which was passed to the operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Exception_8cpp_source.html#l00017">17</a> of file <a class="el" href="Exception_8cpp_source.html">Exception.cpp</a>.</p>

</div>
</div>
<a id="aa0ef4e82617597bfa95d4b9f0e8e05b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ef4e82617597bfa95d4b9f0e8e05b9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>TimePoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats a time point to a human-readable string describing the time in the current time zone and writes the string to a stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><code>TimePoint's</code> clock type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Stream to write to </td></tr>
    <tr><td class="paramname">TimePoint</td><td>Time point to format and to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stream which was passed to the function </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00588">588</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a9e8491d385f4f8671067e17da06244a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8491d385f4f8671067e17da06244a9">&#9670;&nbsp;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering Util::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two program version types with each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side of the comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a std::strong_ordering object as the result of the comparison. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8cpp_source.html#l00149">149</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a id="a45b50c45e3e7042beb21d70af3678c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b50c45e3e7042beb21d70af3678c42">&#9670;&nbsp;</a></span>ParseCSV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::tuple&lt;Ts...&gt; &gt; Util::ParseCSV </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>CSVData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Delimiter</em> = <code>';'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>SkipLines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a string containing comma-separated values (csv) and inserts each row as one tuple containing column data into a vector of tuples. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Ts</td><td>Data types of the columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CSVData</td><td>csv data to parse </td></tr>
    <tr><td class="paramname">Delimiter</td><td>Delimiter character the csv data is separated with </td></tr>
    <tr><td class="paramname">SkipLines</td><td>Amount of header lines (separated by '\n') to skip at the beginning of <code>CSVData</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of parsed csv data </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00898">898</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a97c71397651d7182d9b8ed5d98861bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c71397651d7182d9b8ed5d98861bd9">&#9670;&nbsp;</a></span>PromptOpenFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Util::PromptOpenFilePath </td>
          <td>(</td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>Title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>DefaultSuffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>NameFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>InitialDirectory</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a file dialog to ask the user to select a single existing file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Parent widget of this dialog </td></tr>
    <tr><td class="paramname">Title</td><td>Title used for the dialog window </td></tr>
    <tr><td class="paramname">DefaultSuffix</td><td>Default file extension (e.g. ".dynp") </td></tr>
    <tr><td class="paramname">NameFilter</td><td>Filter to select files (e.g. "DynExp project files (*.dynp)") </td></tr>
    <tr><td class="paramname">InitialDirectory</td><td>Initial directory to show in the dile dialog. If empty, the default directory is specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the full path to the selected file or an empty string if the user cancels the dialog. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00113">113</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="aee9aa045f3a18d918a4e01b559c34a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9aa045f3a18d918a4e01b559c34a5a">&#9670;&nbsp;</a></span>PromptSaveFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Util::PromptSaveFilePath </td>
          <td>(</td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>Title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>DefaultSuffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>NameFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>InitialDirectory</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Works as <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a> but asks the user to select a single file which does not need to exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">Title</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">DefaultSuffix</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">NameFilter</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">InitialDirectory</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00128">128</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="afbe245d507bf5b88d763f42878c8ec73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe245d507bf5b88d763f42878c8ec73">&#9670;&nbsp;</a></span>PromptSaveFilePathModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Util::PromptSaveFilePathModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1QModuleWidget.html">DynExp::QModuleWidget</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>Title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>DefaultSuffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>NameFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Works as <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a> but asks the user to select a single file which does not need to exist. Furthermore, the dialog automatically derives the initial directory using QModuleWidget::GetDataSaveDirectory() and sets the new global directory for saving data to the folder containing the selected file when the user accepts the dialog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parent</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">Title</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">DefaultSuffix</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
    <tr><td class="paramname">NameFilter</td><td>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Refer to <a class="el" href="namespaceUtil.html#a97c71397651d7182d9b8ed5d98861bd9" title="Opens a file dialog to ask the user to select a single existing file.">PromptOpenFilePath()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00143">143</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a8df21e866ae29371e55201b229261fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df21e866ae29371e55201b229261fd1">&#9670;&nbsp;</a></span>QImageFromBlobData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QImage Util::QImageFromBlobData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtil_1_1BlobDataType.html">BlobDataType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>BlobData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BytesPerLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QImage::Format&#160;</td>
          <td class="paramname"><em>Format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts raw pixel data stored in a <a class="el" href="classUtil_1_1BlobDataType.html" title="Data type which manages a binary large object. The reserved memory is freed upon destruction.">Util::BlobDataType</a> object to a QImage transfering the ownership of <code>BlobData's</code> content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BlobData</td><td>Binary large object containing pixel data </td></tr>
    <tr><td class="paramname">Width</td><td>Width of the image represented by <code>BlobData</code> in pixels </td></tr>
    <tr><td class="paramname">Height</td><td>Height of the image represented by <code>BlobData</code> in pixels </td></tr>
    <tr><td class="paramname">BytesPerLine</td><td>Number of bytes which represent a single row of pixels </td></tr>
    <tr><td class="paramname">Format</td><td>Format of the pixel data stored in <code>BlobData</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the QImage constructed from raw pixel data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if any of <code>Width</code>, <code>Height</code>, or <code>BytesPerLine</code> is 0 or if <code>Format</code> is <code>QImage::Format::Format_Invalid</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00153">153</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="aa3151e735e3f9712b7838f4fce34cfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3151e735e3f9712b7838f4fce34cfd1">&#9670;&nbsp;</a></span>QtEnumToTextValueList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Util::QtEnumToTextValueList </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>SkipEntriesFront</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>SkipEntriesEnd</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>SkipCharsFront</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>SkipCharsEnd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a TextValueListType containing entries which reflect the items (names and values) of an enumeration registered to Qt's meta-object system. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EnumType</td><td>Enumeration type to extract entries from. The enumeration type has to be registered to Qt's meta-object system with the Q_ENUM macro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SkipEntriesFront</td><td>Number of enumeration entries to skip from the beginning of the enum declaration </td></tr>
    <tr><td class="paramname">SkipEntriesEnd</td><td>Number of enumeration entries to skip from the end of the enum declaration </td></tr>
    <tr><td class="paramname">SkipCharsFront</td><td>Number of characters to remove from the beginning of each enum entry's name </td></tr>
    <tr><td class="paramname">SkipCharsEnd</td><td>Number of characters to remove from the end of each enum entry's name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List containing key-value pairs of <code>EnumType's</code> entries with entries skipped according to <code>SkipEntriesFront</code> and <code>SkipEntriesEnd</code> ans entry names trimmed according to <code>SkipCharsFront</code> and <code>SkipCharsEnd</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1OutOfRangeException.html" title="Thrown when an argument passed to a function exceeds the valid range.">Util::OutOfRangeException</a></td><td>is thrown when <code>SkipEntriesFront</code> and <code>SkipEntriesEnd</code> are incompatible with the actual amount of enum entries in <code>EnumType</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8h_source.html#l00055">55</a> of file <a class="el" href="QtUtil_8h_source.html">QtUtil.h</a>.</p>

</div>
</div>
<a id="aae320b654ab22ae7854eebfdaf85c2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae320b654ab22ae7854eebfdaf85c2c0">&#9670;&nbsp;</a></span>ReadFromFile() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ReadFromFile </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>Filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the entire content from a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filename</td><td>Full filename of the file to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Content read from the file </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1FileIOErrorException.html" title="Thrown when reading from or writing to a file failed.">Util::FileIOErrorException</a></td><td>is thrown if the specified file cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00250">250</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a46a495a1040e873e0d0e36e8c31937d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a495a1040e873e0d0e36e8c31937d6">&#9670;&nbsp;</a></span>ReadFromFile() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ReadFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>Filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the entire content from a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filename</td><td>Full filename of the file to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Content read from the file </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1FileIOErrorException.html" title="Thrown when reading from or writing to a file failed.">Util::FileIOErrorException</a></td><td>is thrown if the specified file cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00267">267</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a073bfb9f53cf13d1b73117edf066abb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073bfb9f53cf13d1b73117edf066abb8">&#9670;&nbsp;</a></span>ReadFromFile() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ReadFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the entire content from a text file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filename</td><td>Full filename of the file to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Content read from the file </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1FileIOErrorException.html" title="Thrown when reading from or writing to a file failed.">Util::FileIOErrorException</a></td><td>is thrown if the specified file cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00262">262</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="ab6f34c2470241f4648bf004d6b342005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f34c2470241f4648bf004d6b342005">&#9670;&nbsp;</a></span>RemoveExtFromPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Util::RemoveExtFromPath </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the filename's extension from a path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Path</td><td>Path ending with a filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring of <code>Path</code> containing the original path and filename but no file extension </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00853">853</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a359fc895768ae094dc278df3235b5ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fc895768ae094dc278df3235b5ce3">&#9670;&nbsp;</a></span>SaveToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::SaveToFile </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>Filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>Text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a std::string_view to a file (using QFile). Creates a new file or truncates an existing file's content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filename</td><td>Path of the file to write to. </td></tr>
    <tr><td class="paramname">Text</td><td>Content to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true in case of success, otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="QtUtil_8cpp_source.html#l00236">236</a> of file <a class="el" href="QtUtil_8cpp_source.html">QtUtil.cpp</a>.</p>

</div>
</div>
<a id="a369758c59fefaaba87b25ba4c3d3d6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369758c59fefaaba87b25ba4c3d3d6c9">&#9670;&nbsp;</a></span>StrToT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Util::StrToT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>String</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a std::string to a value of type <code>T</code> using operator&lt;&lt; of std::stringstream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value the string should be converted to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">String</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the converted value of type <code>T</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">InvalidDataException</a></td><td>is thrown in case of an incompatible conversion. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00604">604</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="aab8c0b4a3ef36519bbcd9fe76cf68dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8c0b4a3ef36519bbcd9fe76cf68dde">&#9670;&nbsp;</a></span>ToLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToLower </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a string into lower case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Str</td><td>String to transform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the content of <code>Str</code> transformed to lower case </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8cpp_source.html#l00208">208</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a id="a678f025c80e3fc21a12332d3cce451f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f025c80e3fc21a12332d3cce451f0">&#9670;&nbsp;</a></span>ToStr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToStr </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>Value</code> to a std::string using operator&lt;&lt; of std::stringstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>Value</code> converted to a string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00656">656</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a16a5622dfde1ba9fbbc1706dafd4c515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a5622dfde1ba9fbbc1706dafd4c515">&#9670;&nbsp;</a></span>ToStr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToStr </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the Qt QString <code>Str</code> to a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Str</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>Str</code> converted to a string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00668">668</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a716d745d985db64b4802ddb1676ebb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716d745d985db64b4802ddb1676ebb7e">&#9670;&nbsp;</a></span>ToStr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToStr </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>TimePoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a time point to a human-readable string describing the time in the current time zone. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><code>TimePoint's</code> clock type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimePoint</td><td>Time point to format and to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>TimePoint</code> converted to a string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00643">643</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a119393dd8b76c86ab5ec5993f2b2d568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119393dd8b76c86ab5ec5993f2b2d568">&#9670;&nbsp;</a></span>ToStr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToStr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Precision</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a (numeric) value of type <code>T</code> to a std::string using operator&lt;&lt; of std::stringstream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to convert </td></tr>
    <tr><td class="paramname">Precision</td><td>Fixed precision of the numeric conversion for <code>Precision</code> &gt;= 0. For any <code>Precision</code> &lt; 0 (default) the precision is not set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>Value</code> converted to a string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00625">625</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a98f30c5ceb81ed16e4b2284ba799fea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f30c5ceb81ed16e4b2284ba799fea4">&#9670;&nbsp;</a></span>ToStr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToStr </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>Value</code> to a std::string using operator&lt;&lt; of std::stringstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>Value</code> converted to a string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00661">661</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ab3da43074568850d2691bfa052f1e445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3da43074568850d2691bfa052f1e445">&#9670;&nbsp;</a></span>ToStr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;&#160;</td>
          <td class="paramname"><em>Version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a program version to a string in the form specified by <code><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType" title="Data type describing DynExp&#39;s program version in the form Major.Minor.Patch.">VersionType</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Version</td><td>Program version to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing the program version </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00886">886</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a82275ae53b547876518e83df7d911b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82275ae53b547876518e83df7d911b20">&#9670;&nbsp;</a></span>ToUnitStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::ToUnitStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

</div>
</div>
<a id="a4cde03413439d0e856d6b4d5e2f750e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cde03413439d0e856d6b4d5e2f750e7">&#9670;&nbsp;</a></span>ToUnitStr&lt; picoseconds &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a>&lt; <a class="el" href="namespaceUtil.html#a99231f65c9cf8ce2d11f5768579cec5f">picoseconds</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00822">822</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="aefe993b8fa1ecc1599afeee1dc7d0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe993b8fa1ecc1599afeee1dc7d0f00">&#9670;&nbsp;</a></span>ToUnitStr&lt; seconds &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a>&lt; <a class="el" href="namespaceUtil.html#aac7f18dbdcac4a7036045cc4f93a283c">seconds</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00813">813</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="af59e914d8da02ba7dd5f5dbfc55315e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59e914d8da02ba7dd5f5dbfc55315e6">&#9670;&nbsp;</a></span>ToUnitStr&lt; std::chrono::microseconds &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a>&lt; std::chrono::microseconds &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00795">795</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a9ff7c26e0facbdf4807120a4b504b80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff7c26e0facbdf4807120a4b504b80d">&#9670;&nbsp;</a></span>ToUnitStr&lt; std::chrono::milliseconds &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a>&lt; std::chrono::milliseconds &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00786">786</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="aa537adcf11f5849c1466e2e864352a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa537adcf11f5849c1466e2e864352a0e">&#9670;&nbsp;</a></span>ToUnitStr&lt; std::chrono::nanoseconds &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a>&lt; std::chrono::nanoseconds &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00804">804</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a1291cad87815f03694922382ba402222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1291cad87815f03694922382ba402222">&#9670;&nbsp;</a></span>ToUnitStr&lt; std::chrono::seconds &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a>&lt; std::chrono::seconds &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type which has a physical unit associated with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String describing the abbreviation of a physical unit </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00777">777</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="ab963e59ba11ee8e43e8e1fe3482fa377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab963e59ba11ee8e43e8e1fe3482fa377">&#9670;&nbsp;</a></span>TrimTrailingZeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::TrimTrailingZeros </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes trailing zeros ('\0') from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Str</td><td>String to remove zeros from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String with trailing zeros removed </dd></dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00833">833</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="a68b9b93456301284ca7d695c51a4001a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b9b93456301284ca7d695c51a4001a">&#9670;&nbsp;</a></span>VersionFromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> Util::VersionFromString </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a program version from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Str</td><td>String containing a programm version in the form specified by <code><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType" title="Data type describing DynExp&#39;s program version in the form Major.Minor.Patch.">VersionType</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType" title="Data type describing DynExp&#39;s program version in the form Major.Minor.Patch.">VersionType</a></code> object containing the extracted program version </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidDataException.html" title="Data to operate on is invalid for a specific purpose. This indicates a corrupted data structure or fu...">InvalidDataException</a></td><td>if <code>Str</code> does not contain a valid version number. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8cpp_source.html#l00162">162</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a132b3de3103b01ab172ee946b4ad0c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132b3de3103b01ab172ee946b4ad0c96">&#9670;&nbsp;</a></span>is_contained_in_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... ListTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Util::is_contained_in_v = <a class="el" href="structUtil_1_1is__contained__in.html">is_contained_in</a>&lt;T, ListTs...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value type of <code><a class="el" href="structUtil_1_1is__contained__in.html" title="Checks whether a type T is contained in a template parameter pack of types ListTs.">is_contained_in</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00303">303</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a id="aaa3490cda96786eb40f5fd6a386b6042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3490cda96786eb40f5fd6a386b6042">&#9670;&nbsp;</a></span>PyTab</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Util::PyTab = &quot; &quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Character sequence to indent a Python instruction by one level. </p>

<p class="definition">Definition at line <a class="el" href="PyUtil_8h_source.html#l00019">19</a> of file <a class="el" href="PyUtil_8h_source.html">PyUtil.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceUtil.html">Util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
