<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynExp: DynExp::ModuleBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="DynExp.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynExp
   </div>
   <div id="projectbrief">Highly flexible laboratory automation for dynamically changing experiments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classDynExp_1_1ModuleBase.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDynExp_1_1ModuleBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DynExp::ModuleBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for modules. Modules implement programs on their own (e.g. measurement protocols or servers for ethernet communication). They might have a user interface. Modules make use of meta instruments (<code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>) to implement e.g. measurement routines on a higher level, which renders the modules independent from physical devices from specific manufacturers. Derive from this class to implement modules without a user interface.  
 <a href="classDynExp_1_1ModuleBase.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DynExp::ModuleBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDynExp_1_1ModuleBase__inherit__graph.svg" width="1498" height="898"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase_1_1EventListenersOnlyType.html">EventListenersOnlyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> private methods to any <code><a class="el" href="classDynExp_1_1TypedEventListeners.html" title="Typed managers of event listeners class whose instances are owned by classes derived from InterModule...">TypedEventListeners</a></code> class.  <a href="classDynExp_1_1ModuleBase_1_1EventListenersOnlyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase_1_1ModuleThreadOnlyType.html">ModuleThreadOnlyType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> private methods to the module thread <code><a class="el" href="classDynExp_1_1ModuleBase_1_1ModuleThreadOnlyType.html#ac83bb615c44d3c2c4026bacb7dea2831" title="Modules run in their own thread. This is the module thread&#39;s main function.">ModuleThreadMain()</a></code>.  <a href="classDynExp_1_1ModuleBase_1_1ModuleThreadOnlyType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80f112aebff5ce1b782577b2fc323418"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a80f112aebff5ce1b782577b2fc323418">ParamsType</a> = <a class="el" href="classDynExp_1_1ModuleParamsBase.html">ModuleParamsBase</a></td></tr>
<tr class="memdesc:a80f112aebff5ce1b782577b2fc323418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1ModuleBase.html#a80f112aebff5ce1b782577b2fc323418">More...</a><br /></td></tr>
<tr class="separator:a80f112aebff5ce1b782577b2fc323418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aeb623c59ea374c078c24bb85d9d1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ad5aeb623c59ea374c078c24bb85d9d1a">ConfigType</a> = <a class="el" href="classDynExp_1_1ModuleConfiguratorBase.html">ModuleConfiguratorBase</a></td></tr>
<tr class="memdesc:ad5aeb623c59ea374c078c24bb85d9d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1ModuleBase.html#ad5aeb623c59ea374c078c24bb85d9d1a">More...</a><br /></td></tr>
<tr class="separator:ad5aeb623c59ea374c078c24bb85d9d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f951c9f5a84261efae867bf9c51b1fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a> = <a class="el" href="classDynExp_1_1ModuleDataBase.html">ModuleDataBase</a></td></tr>
<tr class="memdesc:a5f951c9f5a84261efae867bf9c51b1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the data class belonging to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> type. Declare this alias in every derived class with the respective data class accompanying the derived <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>.  <a href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">More...</a><br /></td></tr>
<tr class="separator:a5f951c9f5a84261efae867bf9c51b1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae553980005909642693d3cbbae0e96b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleDataTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; <a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a> &gt;</td></tr>
<tr class="memdesc:aae553980005909642693d3cbbae0e96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of <a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">ModuleBase::GetModuleData()</a>. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">More...</a><br /></td></tr>
<tr class="separator:aae553980005909642693d3cbbae0e96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9080ee1a99b5e77959e571be22dce1a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">ModuleDataTypeSyncPtrConstType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; const <a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a> &gt;</td></tr>
<tr class="memdesc:a9080ee1a99b5e77959e571be22dce1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of ModuleBase::GetModuleData() const. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">More...</a><br /></td></tr>
<tr class="separator:a9080ee1a99b5e77959e571be22dce1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197bd1be0fef72c813ab69a772823c5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a197bd1be0fef72c813ab69a772823c5d">ModuleDataGetterType</a> = <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt; <a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a>, <a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleDataTypeSyncPtrType</a>(ModuleBase::*)(const std::chrono::milliseconds)&gt;</td></tr>
<tr class="memdesc:a197bd1be0fef72c813ab69a772823c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">ModuleBase::GetModuleData()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with.  <a href="classDynExp_1_1ModuleBase.html#a197bd1be0fef72c813ab69a772823c5d">More...</a><br /></td></tr>
<tr class="separator:a197bd1be0fef72c813ab69a772823c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a0c2032af7cd592f2333234b2f5b854eb inherit pub_types_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a0c2032af7cd592f2333234b2f5b854eb">ParamsType</a> = <a class="el" href="classDynExp_1_1RunnableObjectParams.html">RunnableObjectParams</a></td></tr>
<tr class="memdesc:a0c2032af7cd592f2333234b2f5b854eb inherit pub_types_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1RunnableObject.html#a0c2032af7cd592f2333234b2f5b854eb">More...</a><br /></td></tr>
<tr class="separator:a0c2032af7cd592f2333234b2f5b854eb inherit pub_types_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5466b09b2bf0fb4d5ca625629b5d797 inherit pub_types_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#ac5466b09b2bf0fb4d5ca625629b5d797">ConfigType</a> = <a class="el" href="classDynExp_1_1RunnableObjectConfigurator.html">RunnableObjectConfigurator</a></td></tr>
<tr class="memdesc:ac5466b09b2bf0fb4d5ca625629b5d797 inherit pub_types_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1RunnableObject.html#ac5466b09b2bf0fb4d5ca625629b5d797">More...</a><br /></td></tr>
<tr class="separator:ac5466b09b2bf0fb4d5ca625629b5d797 inherit pub_types_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> = <a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a></td></tr>
<tr class="memdesc:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">More...</a><br /></td></tr>
<tr class="separator:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; <a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> &gt;</td></tr>
<tr class="memdesc:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a>. Parameters wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">More...</a><br /></td></tr>
<tr class="separator:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">ParamsConstTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; const <a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> &gt;</td></tr>
<tr class="memdesc:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of Object::GetParams() const. Parameters wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <a href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">More...</a><br /></td></tr>
<tr class="separator:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1e4cd6bac98bce47b148e267079f21e9">ConfigType</a> = <a class="el" href="classDynExp_1_1ConfiguratorBase.html">ConfiguratorBase</a></td></tr>
<tr class="memdesc:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <a href="classDynExp_1_1Object.html#a1e4cd6bac98bce47b148e267079f21e9">More...</a><br /></td></tr>
<tr class="separator:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a935874e227bc5bcb039052df45cad956">ParamsGetterType</a> = <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, decltype(&amp;<a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">Object::GetParams</a>)&gt;</td></tr>
<tr class="memdesc:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with.  <a href="classDynExp_1_1Object.html#a935874e227bc5bcb039052df45cad956">More...</a><br /></td></tr>
<tr class="separator:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8630ea32b290077f187c42480b00d290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a8630ea32b290077f187c42480b00d290">ModuleBase</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a8630ea32b290077f187c42480b00d290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance.  <a href="classDynExp_1_1ModuleBase.html#a8630ea32b290077f187c42480b00d290">More...</a><br /></td></tr>
<tr class="separator:a8630ea32b290077f187c42480b00d290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0289cb33c49e80391b55f899199413"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a5a0289cb33c49e80391b55f899199413">~ModuleBase</a> ()=0</td></tr>
<tr class="separator:a5a0289cb33c49e80391b55f899199413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d50167b798951b1a347739976a007d1"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a6d50167b798951b1a347739976a007d1">GetCategory</a> () const override</td></tr>
<tr class="memdesc:a6d50167b798951b1a347739976a007d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the category of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type.  <a href="classDynExp_1_1ModuleBase.html#a6d50167b798951b1a347739976a007d1">More...</a><br /></td></tr>
<tr class="separator:a6d50167b798951b1a347739976a007d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread-safe public functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods can be called from any thread. </p>
</div></td></tr>
<tr class="memitem:af397d2e01e526d907480e0b757f58f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#af397d2e01e526d907480e0b757f58f0d">RestoreWindowStatesFromParams</a> ()</td></tr>
<tr class="memdesc:af397d2e01e526d907480e0b757f58f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classDynExp_1_1ModuleBase.html#af397d2e01e526d907480e0b757f58f0d" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParams()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code> to restore the styles of possibly owned windows according to the style saved in the module's parameters.  <a href="classDynExp_1_1ModuleBase.html#af397d2e01e526d907480e0b757f58f0d">More...</a><br /></td></tr>
<tr class="separator:af397d2e01e526d907480e0b757f58f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6919d21e63bd4f1329275f7e941b0142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a6919d21e63bd4f1329275f7e941b0142">UpdateParamsFromWindowStates</a> ()</td></tr>
<tr class="memdesc:a6919d21e63bd4f1329275f7e941b0142"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classDynExp_1_1ModuleBase.html#a6919d21e63bd4f1329275f7e941b0142" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStates()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code> to store the styles of possibly owned windows in the module's parameters.  <a href="classDynExp_1_1ModuleBase.html#a6919d21e63bd4f1329275f7e941b0142">More...</a><br /></td></tr>
<tr class="separator:a6919d21e63bd4f1329275f7e941b0142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d6b4890c72c88ac9b9407fc51f0436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleDataTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436">GetModuleData</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a>)</td></tr>
<tr class="memdesc:a09d6b4890c72c88ac9b9407fc51f0436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the module data class instance <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a> assigned to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. Module data should not be locked by having called this function while subsequently calling a derived module's method which also makes use of the module's data by locking it. If this happens, the module data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice.  <a href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436">More...</a><br /></td></tr>
<tr class="separator:a09d6b4890c72c88ac9b9407fc51f0436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c07500c142248230cef06214b2dba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">ModuleDataTypeSyncPtrConstType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a06c07500c142248230cef06214b2dba3">GetModuleData</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a06c07500c142248230cef06214b2dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the module data class instance <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a> assigned to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. Module data should not be locked by having called this function while subsequently calling a derived module's method which also makes use of the module's data by locking it. If this happens, the module data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice.  <a href="classDynExp_1_1ModuleBase.html#a06c07500c142248230cef06214b2dba3">More...</a><br /></td></tr>
<tr class="separator:a06c07500c142248230cef06214b2dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784b327cbbba14124e1e303b289714c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a784b327cbbba14124e1e303b289714c4">EnqueueEvent</a> (<a class="el" href="classDynExp_1_1ModuleDataBase.html#a3bd0088908e8bd4f59ba294a75e9ed3e">ModuleDataBase::EventPtrType</a> &amp;&amp;Event) const</td></tr>
<tr class="memdesc:a784b327cbbba14124e1e303b289714c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>Event</code> at the module event queue's back. Takes ownership of the event. Notifies the module owning the respective <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a>'s</code> instance that a new event has been enqueued.  <a href="classDynExp_1_1ModuleBase.html#a784b327cbbba14124e1e303b289714c4">More...</a><br /></td></tr>
<tr class="separator:a784b327cbbba14124e1e303b289714c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6929f6ac89a2c9f9c4e686c59acd31ce"><td class="memTemplParams" colspan="2">template&lt;typename ReceiverType , typename EventType , typename... ArgsTs&gt; </td></tr>
<tr class="memitem:a6929f6ac89a2c9f9c4e686c59acd31ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a6929f6ac89a2c9f9c4e686c59acd31ce">MakeAndEnqueueEvent</a> (ReceiverType *Receiver, EventType EventFuncPtr, ArgsTs &amp;&amp;...Args) const</td></tr>
<tr class="memdesc:a6929f6ac89a2c9f9c4e686c59acd31ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="namespaceDynExp.html#ac244e17a12bb64ee2d459fc347c97cb6" title="Creates an event of type DefaultEvent.">MakeEvent()</a></code> to construct a new event and subsequently enqueues the event into the module's event queue. Logical const-ness: this is a const member function to allow pointers to <code>const</code> <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> inserting events into the module's event queue. These kind of pointers are e.g. returned by <a class="el" href="classDynExp_1_1RunnableInstance.html#af58777edf59b61db1049e096383ee392" title="Returns Owner.">RunnableInstance::GetOwner()</a> which can be called by events' <a class="el" href="classDynExp_1_1EventBase.html#a77b9b29345abc36c7f798e1ae3822670" title="Invokes the event passing the receiving module&#39;s instance reference to it.">EventBase::InvokeChild()</a> functions. For <code>const</code> <code>ModuleBase*</code>, it is possible to insert events into the event queue, but not to change the <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> object itself (e.g. calling <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a>).  <a href="classDynExp_1_1ModuleBase.html#a6929f6ac89a2c9f9c4e686c59acd31ce">More...</a><br /></td></tr>
<tr class="separator:a6929f6ac89a2c9f9c4e686c59acd31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a5e3f33a83b1a9b1d2c8fea2ebe18d8f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a5e3f33a83b1a9b1d2c8fea2ebe18d8f1">RunnableObject</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a5e3f33a83b1a9b1d2c8fea2ebe18d8f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1RunnableObject.html#a5e3f33a83b1a9b1d2c8fea2ebe18d8f1">More...</a><br /></td></tr>
<tr class="separator:a5e3f33a83b1a9b1d2c8fea2ebe18d8f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee536858f410d08629c44493fe840a inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a75ee536858f410d08629c44493fe840a">~RunnableObject</a> ()=0</td></tr>
<tr class="separator:a75ee536858f410d08629c44493fe840a inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4736ee64946008136525afe5f7250eb inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#af4736ee64946008136525afe5f7250eb">SetPaused</a> (bool Pause, std::string Description=&quot;&quot;)</td></tr>
<tr class="memdesc:af4736ee64946008136525afe5f7250eb inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses or resumes a <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance. Its thread stays running, but the instance does not perform any action while it is paused.  <a href="classDynExp_1_1RunnableObject.html#af4736ee64946008136525afe5f7250eb">More...</a><br /></td></tr>
<tr class="separator:af4736ee64946008136525afe5f7250eb inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af963d89b1f862ec1487243b582e4292b inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#af963d89b1f862ec1487243b582e4292b">IsRunning</a> () const noexcept</td></tr>
<tr class="memdesc:af963d89b1f862ec1487243b582e4292b inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#a14503e0c26947af03db4d24dbd90630f" title="Indicates whether the RunnableObject instance is running.">Running</a>.  <a href="classDynExp_1_1RunnableObject.html#af963d89b1f862ec1487243b582e4292b">More...</a><br /></td></tr>
<tr class="separator:af963d89b1f862ec1487243b582e4292b inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdc273407c6b72ff8f44b3420d1bd4e inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aabdc273407c6b72ff8f44b3420d1bd4e">IsPaused</a> () const noexcept</td></tr>
<tr class="memdesc:aabdc273407c6b72ff8f44b3420d1bd4e inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#a9d31acb25204f3e22bac761e9a8cd645" title="Indicates whether the RunnableObject instance is paused.">Paused</a>.  <a href="classDynExp_1_1RunnableObject.html#aabdc273407c6b72ff8f44b3420d1bd4e">More...</a><br /></td></tr>
<tr class="separator:aabdc273407c6b72ff8f44b3420d1bd4e inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa68571b91bbfa501c2a571ef0945d03 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aaa68571b91bbfa501c2a571ef0945d03">IsExiting</a> () const noexcept</td></tr>
<tr class="memdesc:aaa68571b91bbfa501c2a571ef0945d03 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#aa2e7e86495da4f938eaaca0774b21abd" title="Indicates whether this RunnableObject instance&#39;s thread should terminate.">ShouldExit</a>.  <a href="classDynExp_1_1RunnableObject.html#aaa68571b91bbfa501c2a571ef0945d03">More...</a><br /></td></tr>
<tr class="separator:aaa68571b91bbfa501c2a571ef0945d03 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e529b916c8fd4b2a1b89d888bd134c inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a43e529b916c8fd4b2a1b89d888bd134c">GetStartupType</a> () const noexcept</td></tr>
<tr class="memdesc:a43e529b916c8fd4b2a1b89d888bd134c inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#a90c4c0e78078946252ade4c3f0fc088a" title="Reflects the value of RunnableObjectParams::Startup. This variable is only updated when Run() is call...">Startup</a>.  <a href="classDynExp_1_1RunnableObject.html#a43e529b916c8fd4b2a1b89d888bd134c">More...</a><br /></td></tr>
<tr class="separator:a43e529b916c8fd4b2a1b89d888bd134c inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb2e71639fdcab42c9c6c299e4cf2b8 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#adbb2e71639fdcab42c9c6c299e4cf2b8">GetReasonWhyPaused</a> () const</td></tr>
<tr class="memdesc:adbb2e71639fdcab42c9c6c299e4cf2b8 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1RunnableObject.html#aacef09883d7d4462fc014330663d9f4f" title="Holds information about why the RunnableObject instance is paused.">ReasonWhyPaused</a>.  <a href="classDynExp_1_1RunnableObject.html#adbb2e71639fdcab42c9c6c299e4cf2b8">More...</a><br /></td></tr>
<tr class="separator:adbb2e71639fdcab42c9c6c299e4cf2b8 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416b8000830913b11eaf02d1f1af49d6 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6">Run</a> (QWidget *ParentWidget=nullptr)</td></tr>
<tr class="memdesc:a416b8000830913b11eaf02d1f1af49d6 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread and ensures that all <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instances linked to this instance via <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> parameters are in a ready state. Calls <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a></code> which is to be overridden by derived classes to start a thread and to pass this thread back by calling <code><a class="el" href="classDynExp_1_1RunnableObject.html#aac70e1485923ee8c78ed5732099b4c90" title="Stores a thread constructed by a derived class overriding RunChild() in Thread taking ownership of th...">StoreThread()</a></code>.  <a href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6">More...</a><br /></td></tr>
<tr class="separator:a416b8000830913b11eaf02d1f1af49d6 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8275b7f99072059d5608a4201ed579af inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a8275b7f99072059d5608a4201ed579af">RunIfRunAutomatic</a> ()</td></tr>
<tr class="memdesc:a8275b7f99072059d5608a4201ed579af inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> if <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a1ef775df6c01b554f3c102024646c0dd" title="Determines when the runnable object is started. Refer to RunnableObjectParams::StartupType.">RunnableObjectParams::Startup</a> is set to <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a33b475bb5737bca9bf78ce6a6a7c41f4af69add31b7e16e98b1fa4642036b1bfc">RunnableObjectParams::Automatic</a>.  <a href="classDynExp_1_1RunnableObject.html#a8275b7f99072059d5608a4201ed579af">More...</a><br /></td></tr>
<tr class="separator:a8275b7f99072059d5608a4201ed579af inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4a5c01c205de78aaf9269f07b87f97 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#afa4a5c01c205de78aaf9269f07b87f97">RunIfRunOnCreation</a> ()</td></tr>
<tr class="memdesc:afa4a5c01c205de78aaf9269f07b87f97 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> if <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a1ef775df6c01b554f3c102024646c0dd" title="Determines when the runnable object is started. Refer to RunnableObjectParams::StartupType.">RunnableObjectParams::Startup</a> is set to <a class="el" href="classDynExp_1_1RunnableObjectParams.html#a33b475bb5737bca9bf78ce6a6a7c41f4ad34691b5a53a925e88d07542d5cadf8f">RunnableObjectParams::OnCreation</a>.  <a href="classDynExp_1_1RunnableObject.html#afa4a5c01c205de78aaf9269f07b87f97">More...</a><br /></td></tr>
<tr class="separator:afa4a5c01c205de78aaf9269f07b87f97 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae3d704e86c69825835ba35399d87f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1">Terminate</a> (bool Force=false, const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1RunnableObject.html#a0a4195a66ff3a00a8d9d523d5783e5ad">TerminateTimeoutDefault</a>)</td></tr>
<tr class="memdesc:afae3d704e86c69825835ba35399d87f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread to terminate and waits until it has ended. Calls <a class="el" href="classDynExp_1_1RunnableObject.html#a9bc1c98af72a500c1e916c65c33b5464" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">TerminateImpl()</a>.  <a href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1">More...</a><br /></td></tr>
<tr class="separator:afae3d704e86c69825835ba35399d87f1 inherit pub_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classUtil_1_1INonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classUtil_1_1INonCopyable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memitem:ad1604a205a9a18f20c51f04327079243 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#ad1604a205a9a18f20c51f04327079243">INonCopyable</a> (const <a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:ad1604a205a9a18f20c51f04327079243 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fdb9f2928ae66d61f51499bc893e78 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a66fdb9f2928ae66d61f51499bc893e78">operator=</a> (const <a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:a66fdb9f2928ae66d61f51499bc893e78 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a3d16fbb9394b595905e28ba9291ac402">GetID</a> () const noexcept</td></tr>
<tr class="memdesc:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. Thread-safe since ID is const.  <a href="classDynExp_1_1Object.html#a3d16fbb9394b595905e28ba9291ac402">More...</a><br /></td></tr>
<tr class="separator:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1a9d46583b415dabe8a41b774f5e0db9">GetCategoryAndName</a> () const</td></tr>
<tr class="memdesc:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string from an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> category and name to allow the user to identify an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> type.  <a href="classDynExp_1_1Object.html#a1a9d46583b415dabe8a41b774f5e0db9">More...</a><br /></td></tr>
<tr class="separator:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5061381dd74b8278624d6f004021db8">EnsureReadyState</a> (bool IsAutomaticStartup)</td></tr>
<tr class="memdesc:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready by possibly starting its worker thread or by opening connections to hardware devices.  <a href="classDynExp_1_1Object.html#ac5061381dd74b8278624d6f004021db8">More...</a><br /></td></tr>
<tr class="separator:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#afd2469a30700f322ae28374cf48a8ba7">CheckLinkedObjectStates</a> () const</td></tr>
<tr class="memdesc:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instances this instance uses are in a ready state. Override <code><a class="el" href="classDynExp_1_1Object.html#a8a0fd11d2dc276253b9ec9d710acb864" title="Override to implement a check whether linked objects are in a ready state.">CheckLinkedObjectStatesChild()</a></code> to implement this behavior.  <a href="classDynExp_1_1Object.html#afd2469a30700f322ae28374cf48a8ba7">More...</a><br /></td></tr>
<tr class="separator:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46">Reset</a> ()</td></tr>
<tr class="memdesc:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance (including all its derived classes) by calling <code><a class="el" href="classDynExp_1_1Object.html#a53b82dbe7ee6bb4e9b948c462fffc964" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code>. A reset implies that the derived classes reload all their parameters from <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> and that all <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instances owned by this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance become invalidated.  <a href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46">More...</a><br /></td></tr>
<tr class="separator:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a5ad8b51f8e38c57a48a408b0ee813143">BlockIfUnused</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>)</td></tr>
<tr class="memdesc:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance setting <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a> to true. Refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a> for the consequences.  <a href="classDynExp_1_1Object.html#a5ad8b51f8e38c57a48a408b0ee813143">More...</a><br /></td></tr>
<tr class="separator:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">ParamsConstTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">GetParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the parameter class instance <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a>.  <a href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">More...</a><br /></td></tr>
<tr class="separator:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a96ef443e2da7a0c95eccbdf0a5d4d0c1">GetParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>)</td></tr>
<tr class="memdesc:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the parameter class instance <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a>.  <a href="classDynExp_1_1Object.html#a96ef443e2da7a0c95eccbdf0a5d4d0c1">More...</a><br /></td></tr>
<tr class="separator:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ad525cf93f649e6edc5c31c5f16476a43">GetObjectName</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1Object.html#ad525cf93f649e6edc5c31c5f16476a43">More...</a><br /></td></tr>
<tr class="separator:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#acc8cf73407e49b40b7429bf9ad018235">IsSharedUsageEnabled</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether shared usage has been enabled for this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. Refer to <a class="el" href="classDynExp_1_1ParamsBase.html#abad5385ae3558b535ee831ca37e16616" title="Determines whether an Object can be linked to only one (unique) or multiple (shared) other objects.">ParamsBase::UsageType</a>.  <a href="classDynExp_1_1Object.html#acc8cf73407e49b40b7429bf9ad018235">More...</a><br /></td></tr>
<tr class="separator:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1244d53367db00489c98b06d1c3cf221">SetWarning</a> (std::string Description, int ErrorCode) const</td></tr>
<tr class="memdesc:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>. Sets the warning by a description and an error code.  <a href="classDynExp_1_1Object.html#a1244d53367db00489c98b06d1c3cf221">More...</a><br /></td></tr>
<tr class="separator:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af8005025d4b226d97490c0a0581a610f">SetWarning</a> (const <a class="el" href="classUtil_1_1Exception.html">Util::Exception</a> &amp;e) const</td></tr>
<tr class="memdesc:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>. Sets the warning by retrieving the warning data from an exception <code>e</code>.  <a href="classDynExp_1_1Object.html#af8005025d4b226d97490c0a0581a610f">More...</a><br /></td></tr>
<tr class="separator:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a7584b53df46340e83301d76e5ca85ba3">ClearWarning</a> () const</td></tr>
<tr class="memdesc:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>.  <a href="classDynExp_1_1Object.html#a7584b53df46340e83301d76e5ca85ba3">More...</a><br /></td></tr>
<tr class="separator:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#aa696a7ed149a758d7ba5943834ca19f1">GetWarning</a> () const</td></tr>
<tr class="memdesc:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a> in a thread-safe way by copying its internal data.  <a href="classDynExp_1_1Object.html#aa696a7ed149a758d7ba5943834ca19f1">More...</a><br /></td></tr>
<tr class="separator:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5f18675231275acf933b5989b8811cc">GetException</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the exception which has caused this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to fail.  <a href="classDynExp_1_1Object.html#ac5f18675231275acf933b5989b8811cc">More...</a><br /></td></tr>
<tr class="separator:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#aab58ec8b7377ac5082e376bd9d82dba1">IsReady</a> () const</td></tr>
<tr class="memdesc:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>).  <a href="classDynExp_1_1Object.html#aab58ec8b7377ac5082e376bd9d82dba1">More...</a><br /></td></tr>
<tr class="separator:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a41b950acea065c13b4899d7c9a12048d">GetUseCount</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the registered useres in a thread-safe way.  <a href="classDynExp_1_1Object.html#a41b950acea065c13b4899d7c9a12048d">More...</a><br /></td></tr>
<tr class="separator:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a73f9e22dafdeab31ebeb6859c51da546">IsUnused</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is used by other instances.  <a href="classDynExp_1_1Object.html#a73f9e22dafdeab31ebeb6859c51da546">More...</a><br /></td></tr>
<tr class="separator:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a393f14bb1759eef2fe956a792243dc8b">GetUserIDs</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the IDs of the registered users in a thread-safe way.  <a href="classDynExp_1_1Object.html#a393f14bb1759eef2fe956a792243dc8b">More...</a><br /></td></tr>
<tr class="separator:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a542639f48d6826b0546362fb4078256b">GetUserNamesString</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string describing which users are registered containing their object names, categories and type names in a thread-safe way.  <a href="classDynExp_1_1Object.html#a542639f48d6826b0546362fb4078256b">More...</a><br /></td></tr>
<tr class="separator:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057f86e9ceec0f7e709e720f66cbb7fb inherit pub_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a057f86e9ceec0f7e709e720f66cbb7fb">GetName</a> () const =0</td></tr>
<tr class="memdesc:a057f86e9ceec0f7e709e720f66cbb7fb inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type.  <a href="classDynExp_1_1Object.html#a057f86e9ceec0f7e709e720f66cbb7fb">More...</a><br /></td></tr>
<tr class="separator:a057f86e9ceec0f7e709e720f66cbb7fb inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abb8b0a39ab6950220cbf2c812295889f"><td class="memItemLeft" align="right" valign="top">constexpr static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#abb8b0a39ab6950220cbf2c812295889f">Category</a> () noexcept</td></tr>
<tr class="memdesc:abb8b0a39ab6950220cbf2c812295889f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every derived class has to redefine this function.  <a href="classDynExp_1_1ModuleBase.html#abb8b0a39ab6950220cbf2c812295889f">More...</a><br /></td></tr>
<tr class="separator:abb8b0a39ab6950220cbf2c812295889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af55298b0589b9239ff3076d540c97449">CategoryAndNameToStr</a> (const std::string &amp;Category, const std::string &amp;Name)</td></tr>
<tr class="memdesc:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string from an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> category and name to allow the user to identify an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> type.  <a href="classDynExp_1_1Object.html#af55298b0589b9239ff3076d540c97449">More...</a><br /></td></tr>
<tr class="separator:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa62c218c15d17c8beeaafbec0e9e2846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1ModuleBase_1_1ModuleThreadOnlyType.html">ModuleThreadOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#aa62c218c15d17c8beeaafbec0e9e2846">ModuleThreadOnly</a></td></tr>
<tr class="memdesc:aa62c218c15d17c8beeaafbec0e9e2846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> private methods to the module thread <code><a class="el" href="namespaceDynExp.html#acd637f0e67b9a2815532b5a7e1754bd2" title="Modules run in their own thread. This is the module thread&#39;s main function.">ModuleThreadMain()</a></code>.  <a href="classDynExp_1_1ModuleBase.html#aa62c218c15d17c8beeaafbec0e9e2846">More...</a><br /></td></tr>
<tr class="separator:aa62c218c15d17c8beeaafbec0e9e2846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb7bfaf4658e6b499912178450a5de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1ModuleBase_1_1EventListenersOnlyType.html">EventListenersOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#aafb7bfaf4658e6b499912178450a5de0">EventListenersOnly</a></td></tr>
<tr class="memdesc:aafb7bfaf4658e6b499912178450a5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> private methods to any <code><a class="el" href="classDynExp_1_1TypedEventListeners.html" title="Typed managers of event listeners class whose instances are owned by classes derived from InterModule...">TypedEventListeners</a></code> class.  <a href="classDynExp_1_1ModuleBase.html#aafb7bfaf4658e6b499912178450a5de0">More...</a><br /></td></tr>
<tr class="separator:aafb7bfaf4658e6b499912178450a5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:acb2919ca14c007ca6bb3d7fe02ef02a4 inherit pub_attribs_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1RunnableObject_1_1RunnableInstanceOnlyType.html">RunnableInstanceOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#acb2919ca14c007ca6bb3d7fe02ef02a4">RunnableInstanceOnly</a></td></tr>
<tr class="memdesc:acb2919ca14c007ca6bb3d7fe02ef02a4 inherit pub_attribs_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a>'s</code> private methods to class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>.  <a href="classDynExp_1_1RunnableObject.html#acb2919ca14c007ca6bb3d7fe02ef02a4">More...</a><br /></td></tr>
<tr class="separator:acb2919ca14c007ca6bb3d7fe02ef02a4 inherit pub_attribs_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object_1_1LinkedObjectWrapperOnlyType.html">LinkedObjectWrapperOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a4428d406d0477fc605a2d27dc4ac409c">LinkedObjectWrapperOnly</a></td></tr>
<tr class="memdesc:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> private methods to any LinkedObjectWrapper&lt;T&gt;.  <a href="classDynExp_1_1Object.html#a4428d406d0477fc605a2d27dc4ac409c">More...</a><br /></td></tr>
<tr class="separator:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad26a3040b59bb39a2cbf921b072e0306"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a> = std::chrono::milliseconds(1000)</td></tr>
<tr class="memdesc:ad26a3040b59bb39a2cbf921b072e0306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the default timeout for <code><a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">GetModuleData()</a></code> to lock the mutex synchronizing the module's data <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>.  <a href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">More...</a><br /></td></tr>
<tr class="separator:ad26a3040b59bb39a2cbf921b072e0306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a8755819fc4e5d8c91ad03ba043c93414 inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a8755819fc4e5d8c91ad03ba043c93414">ShortTimeoutDefault</a> = std::chrono::milliseconds(50)</td></tr>
<tr class="memdesc:a8755819fc4e5d8c91ad03ba043c93414 inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout e.g. used as a default for calls to <a class="el" href="classDynExp_1_1InstrumentBase.html#aa31383861ecdb9c418666562c1fb7fb8" title="Locks the mutex of the instrument data class instance InstrumentData assigned to this InstrumentBase ...">InstrumentBase::GetInstrumentData</a> or <a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">ModuleBase::GetModuleData</a>.  <a href="classDynExp_1_1RunnableObject.html#a8755819fc4e5d8c91ad03ba043c93414">More...</a><br /></td></tr>
<tr class="separator:a8755819fc4e5d8c91ad03ba043c93414 inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4195a66ff3a00a8d9d523d5783e5ad inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a0a4195a66ff3a00a8d9d523d5783e5ad">TerminateTimeoutDefault</a> = std::chrono::milliseconds(3000)</td></tr>
<tr class="memdesc:a0a4195a66ff3a00a8d9d523d5783e5ad inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout used as a default for calls to <a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">RunnableObject::Terminate</a>.  <a href="classDynExp_1_1RunnableObject.html#a0a4195a66ff3a00a8d9d523d5783e5ad">More...</a><br /></td></tr>
<tr class="separator:a0a4195a66ff3a00a8d9d523d5783e5ad inherit pub_static_attribs_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">static constexpr std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a> = std::chrono::milliseconds(100)</td></tr>
<tr class="memdesc:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout used by <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a> to lock the mutex of the parameter instance assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">More...</a><br /></td></tr>
<tr class="separator:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3b5f0043da6a34555b28ba05fd070e65"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a3b5f0043da6a34555b28ba05fd070e65">GetExceptionUnsafe</a> (const <a class="el" href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">ModuleDataTypeSyncPtrConstType</a> &amp;ModuleDataPtr)</td></tr>
<tr class="memdesc:a3b5f0043da6a34555b28ba05fd070e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="classDynExp_1_1ModuleDataBase.html#a17e379588d31f7daf6a5e1a855bbb6b9" title="Used to transfer exceptions from the module thread to the main (user interface) thread....">ModuleDataBase::ModuleException</a> assuming that the module data has already been locked.  <a href="classDynExp_1_1ModuleBase.html#a3b5f0043da6a34555b28ba05fd070e65">More...</a><br /></td></tr>
<tr class="separator:a3b5f0043da6a34555b28ba05fd070e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5a35c378edbab93859bc03833fae2c4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a5a35c378edbab93859bc03833fae2c4f">ResetImpl</a> (<a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1RunnableObject.html">RunnableObject</a> &gt;) override final</td></tr>
<tr class="memdesc:a5a35c378edbab93859bc03833fae2c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5a35c378edbab93859bc03833fae2c4f" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.  <a href="classDynExp_1_1ModuleBase.html#a5a35c378edbab93859bc03833fae2c4f">More...</a><br /></td></tr>
<tr class="separator:a5a35c378edbab93859bc03833fae2c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a25fbb93523e77f80b3f39296da63d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a50a25fbb93523e77f80b3f39296da63d">ResetImpl</a> (<a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a> &gt;)=0</td></tr>
<tr class="memdesc:a50a25fbb93523e77f80b3f39296da63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5a35c378edbab93859bc03833fae2c4f" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.  <a href="classDynExp_1_1ModuleBase.html#a50a25fbb93523e77f80b3f39296da63d">More...</a><br /></td></tr>
<tr class="separator:a50a25fbb93523e77f80b3f39296da63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e812852c9d7263b07e54e3349032b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a2e812852c9d7263b07e54e3349032b29">ModuleSetReasonWhyPaused</a> (std::string Description)</td></tr>
<tr class="memdesc:a2e812852c9d7263b07e54e3349032b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason why this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance has been paused.  <a href="classDynExp_1_1ModuleBase.html#a2e812852c9d7263b07e54e3349032b29">More...</a><br /></td></tr>
<tr class="separator:a2e812852c9d7263b07e54e3349032b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad242f26db214876d935a313467a19c72"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ad242f26db214876d935a313467a19c72">GetExceptionChild</a> ([[maybe_unused]] const std::chrono::milliseconds Timeout) const override final</td></tr>
<tr class="separator:ad242f26db214876d935a313467a19c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb81c2e4107ab33b51cf053b38927cc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#adb81c2e4107ab33b51cf053b38927cc5">IsReadyChild</a> () const override final</td></tr>
<tr class="memdesc:adb81c2e4107ab33b51cf053b38927cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>).  <a href="classDynExp_1_1ModuleBase.html#adb81c2e4107ab33b51cf053b38927cc5">More...</a><br /></td></tr>
<tr class="separator:adb81c2e4107ab33b51cf053b38927cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Private functions for logical const-ness</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Logical const-ness: refer to <a class="el" href="classDynExp_1_1ModuleBase.html#a6929f6ac89a2c9f9c4e686c59acd31ce" title="Calls MakeEvent() to construct a new event and subsequently enqueues the event into the module&#39;s even...">ModuleBase::MakeAndEnqueueEvent()</a>. </p>
</div></td></tr>
<tr class="memitem:ae473e688cb173ee492e7663815462ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleDataTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ae473e688cb173ee492e7663815462ce1">GetNonConstModuleData</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:ae473e688cb173ee492e7663815462ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always allows <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> to obtain a non-const pointer to the module's data - even in const event functions.  <a href="classDynExp_1_1ModuleBase.html#ae473e688cb173ee492e7663815462ce1">More...</a><br /></td></tr>
<tr class="separator:ae473e688cb173ee492e7663815462ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Module thread only</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions must be called by module thread only. </p>
</div></td></tr>
<tr class="memitem:a832cb100caeb9bcba79c515efc5b5f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a832cb100caeb9bcba79c515efc5b5f71">HandleEvent</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance)</td></tr>
<tr class="memdesc:a832cb100caeb9bcba79c515efc5b5f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes and removes the next pending event from the module's event queue.  <a href="classDynExp_1_1ModuleBase.html#a832cb100caeb9bcba79c515efc5b5f71">More...</a><br /></td></tr>
<tr class="separator:a832cb100caeb9bcba79c515efc5b5f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2010071b9ef285d63381fb9e4d186b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ac2010071b9ef285d63381fb9e4d186b6">AddRegisteredEvent</a> (<a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a> &amp;EventListeners)</td></tr>
<tr class="memdesc:ac2010071b9ef285d63381fb9e4d186b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a manager of event listeners to <a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268" title="Holds a list of pointers to managers of event listeners of the events this module has registered/subs...">RegisteredEvents</a> if it was not already added before. Called indirectly by <a class="el" href="classDynExp_1_1TypedEventListeners.html#ad00404b8a0a59e5167586c02a83c1482" title="Registers/Subscribes module Listener to the event with the event function EventFunc....">TypedEventListeners::Register()</a>.  <a href="classDynExp_1_1ModuleBase.html#ac2010071b9ef285d63381fb9e4d186b6">More...</a><br /></td></tr>
<tr class="separator:ac2010071b9ef285d63381fb9e4d186b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e7cf897ebcdfea8c39f5954bcd3729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a79e7cf897ebcdfea8c39f5954bcd3729">RemoveRegisteredEvent</a> (<a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a> &amp;EventListeners)</td></tr>
<tr class="memdesc:a79e7cf897ebcdfea8c39f5954bcd3729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a manager of event listeners from <a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268" title="Holds a list of pointers to managers of event listeners of the events this module has registered/subs...">RegisteredEvents</a> if it was added before. Called indirectly by <a class="el" href="classDynExp_1_1TypedEventListeners.html#a9d21b5765fb573f9cdb3302b9c30cf07" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">TypedEventListeners::Deregister()</a>.  <a href="classDynExp_1_1ModuleBase.html#a79e7cf897ebcdfea8c39f5954bcd3729">More...</a><br /></td></tr>
<tr class="separator:a79e7cf897ebcdfea8c39f5954bcd3729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb9fa22465fe0fc2ca36ba510a37f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57">Util::DynExpErrorCodes::DynExpErrorCodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#afdb9fa22465fe0fc2ca36ba510a37f45">ExecModuleMainLoop</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance)</td></tr>
<tr class="memdesc:afdb9fa22465fe0fc2ca36ba510a37f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs <code><a class="el" href="classDynExp_1_1ModuleBase.html#abe86b2a8c7a6e60a2937be8b2a0e6b00" title="Module main loop. The function is executed periodically by the module thread. Also refer to GetMainLo...">ModuleMainLoop()</a></code>.  <a href="classDynExp_1_1ModuleBase.html#afdb9fa22465fe0fc2ca36ba510a37f45">More...</a><br /></td></tr>
<tr class="separator:afdb9fa22465fe0fc2ca36ba510a37f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2428398352d29da29dab0b0c48dbd37b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a2428398352d29da29dab0b0c48dbd37b">OnPause</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance)</td></tr>
<tr class="memdesc:a2428398352d29da29dab0b0c48dbd37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler gets called just after the module pauses due to e.g. an error in an instrument the module depends on. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#ae1814f6d7cb0b105f4e534c83360405c" title="This handler gets called just after the module pauses due to e.g. an error in an instrument the modul...">OnPauseChild()</a></code> to e.g. abort a measurement or to store internal states for resuming later.  <a href="classDynExp_1_1ModuleBase.html#a2428398352d29da29dab0b0c48dbd37b">More...</a><br /></td></tr>
<tr class="separator:a2428398352d29da29dab0b0c48dbd37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3867671a668012192fec7f649b6e933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#aa3867671a668012192fec7f649b6e933">OnResume</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance)</td></tr>
<tr class="memdesc:aa3867671a668012192fec7f649b6e933"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler gets called just after the module resumed from a paused state. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5eb479cbfe5bf10898ce48c52bac0a05" title="This handler gets called just after the module resumed from a paused state. Override OnResumeChild() ...">OnResumeChild()</a></code> to reinitialize instruments or a measurement routine.  <a href="classDynExp_1_1ModuleBase.html#aa3867671a668012192fec7f649b6e933">More...</a><br /></td></tr>
<tr class="separator:aa3867671a668012192fec7f649b6e933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86fe18fa3d55d64993569e6d6061889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ab86fe18fa3d55d64993569e6d6061889">OnError</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance)</td></tr>
<tr class="memdesc:ab86fe18fa3d55d64993569e6d6061889"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler gets called just before the module thread terminates due to an exception. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a22578f8bc7260fd4aff1b96322b9d87c" title="This handler gets called just before the module thread terminates due to an exception....">OnErrorChild()</a></code> to perform shutdown and cleanup actions.  <a href="classDynExp_1_1ModuleBase.html#ab86fe18fa3d55d64993569e6d6061889">More...</a><br /></td></tr>
<tr class="separator:ab86fe18fa3d55d64993569e6d6061889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Main thread only</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions must not be called by module thread. </p>
</div></td></tr>
<tr class="memitem:a2d871f2200f496821d35999966862271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a2d871f2200f496821d35999966862271">RunChild</a> () override final</td></tr>
<tr class="memdesc:a2d871f2200f496821d35999966862271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code>.  <a href="classDynExp_1_1ModuleBase.html#a2d871f2200f496821d35999966862271">More...</a><br /></td></tr>
<tr class="separator:a2d871f2200f496821d35999966862271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c78a68f51f2c1f0b8316f3f85c4996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a25c78a68f51f2c1f0b8316f3f85c4996">NotifyChild</a> () override final</td></tr>
<tr class="memdesc:a25c78a68f51f2c1f0b8316f3f85c4996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify derived classes that some state has changed (e.g. the termination of <code>Thread</code> is requested) and that the child's event/task queue should run now.  <a href="classDynExp_1_1ModuleBase.html#a25c78a68f51f2c1f0b8316f3f85c4996">More...</a><br /></td></tr>
<tr class="separator:a25c78a68f51f2c1f0b8316f3f85c4996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023fca52cd7b9acddaae83a931158961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a023fca52cd7b9acddaae83a931158961">TerminateChild</a> (const std::chrono::milliseconds Timeout) override final</td></tr>
<tr class="memdesc:a023fca52cd7b9acddaae83a931158961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals derived classes that terminating the <a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a> instance's thread is about to be requested. Derived classes might now enqueue respective exit tasks/events into their task/event queues. Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a61aa6890ad8bc345563a8119fb7297d0" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">TerminateUnsafe()</a></code>.  <a href="classDynExp_1_1ModuleBase.html#a023fca52cd7b9acddaae83a931158961">More...</a><br /></td></tr>
<tr class="separator:a023fca52cd7b9acddaae83a931158961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40d048de291a9076061c4a6773ba4eb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classBusyDialog.html">BusyDialog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ab40d048de291a9076061c4a6773ba4eb">MakeStartupBusyDialogChild</a> (QWidget *ParentWidget) const override final</td></tr>
<tr class="memdesc:ab40d048de291a9076061c4a6773ba4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override to make this function return a pointer to a <code><a class="el" href="classBusyDialog.html">BusyDialog</a></code> instance. Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code>.  <a href="classDynExp_1_1ModuleBase.html#ab40d048de291a9076061c4a6773ba4eb">More...</a><br /></td></tr>
<tr class="separator:ab40d048de291a9076061c4a6773ba4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Event functions running in the module thread. </p>
</div></td></tr>
<tr class="memitem:a51b4635720cb3b96033970dba4a95500"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a51b4635720cb3b96033970dba4a95500">OnInit</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> *Instance) const</td></tr>
<tr class="memdesc:a51b4635720cb3b96033970dba4a95500"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is triggered right before the module thread starts. Override it to lock instruments this module depends on (via <a class="el" href="classDynExp_1_1RunnableInstance.html#ada6ce77e9ce2a2b30c36aac86724c7ea" title="Locks an Object instance referenced by a parameter LinkParam of type ParamsBase::Param&lt; ObjectLink&lt; O...">RunnableInstance::LockObject()</a>) and to register/subscribe for events (via <a class="el" href="classDynExp_1_1InterModuleEvent.html#a9cef4596c1e4dfbc7c6bdb2b067208da" title="Registers/Subscribes module Listener to the event with the event function EventFunc....">InterModuleEvent::Register()</a>).  <a href="classDynExp_1_1ModuleBase.html#a51b4635720cb3b96033970dba4a95500">More...</a><br /></td></tr>
<tr class="separator:a51b4635720cb3b96033970dba4a95500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fb87b30e26eea73d6d53d2d871160a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a77fb87b30e26eea73d6d53d2d871160a">OnExit</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> *Instance) const</td></tr>
<tr class="memdesc:a77fb87b30e26eea73d6d53d2d871160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is triggered right before the module thread terminates (not due to an exception, in this case refer to <a class="el" href="classDynExp_1_1ModuleBase.html#ab86fe18fa3d55d64993569e6d6061889" title="This handler gets called just before the module thread terminates due to an exception....">ModuleBase::OnError</a>). Override it to unlock instruments this module depends on (via <a class="el" href="classDynExp_1_1RunnableInstance.html#a2a35438cccb579c51e217d0e50e53797" title="Unlocks an Object instance stored in the LinkedObjectWrapperContainer ObjectWrapperContainer....">RunnableInstance::UnlockObject()</a>) and to deregister/unsubscribe from events (via <a class="el" href="classDynExp_1_1InterModuleEvent.html#ad1c539c32b97bfcfb7262cc69465be2d" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">InterModuleEvent::Deregister()</a>).  <a href="classDynExp_1_1ModuleBase.html#a77fb87b30e26eea73d6d53d2d871160a">More...</a><br /></td></tr>
<tr class="separator:a77fb87b30e26eea73d6d53d2d871160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36edced314272a5b31cea3649f6a7ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a36edced314272a5b31cea3649f6a7ca8">OnDeregisterEvents</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> *Instance) const</td></tr>
<tr class="memdesc:a36edced314272a5b31cea3649f6a7ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This event is triggered after the <code>OnExit</code> event. It calls <a class="el" href="classDynExp_1_1EventListenersBase.html#af1124e3f51d17121973a296b395ae4b7" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">EventListenersBase::Deregister()</a> for all managers of event listeners stored in <a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268" title="Holds a list of pointers to managers of event listeners of the events this module has registered/subs...">RegisteredEvents</a> since we do not trust in derived modules deregistering/unsubscribing from all registered events via <a class="el" href="classDynExp_1_1InterModuleEvent.html#ad1c539c32b97bfcfb7262cc69465be2d" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">InterModuleEvent::Deregister()</a>.  <a href="classDynExp_1_1ModuleBase.html#a36edced314272a5b31cea3649f6a7ca8">More...</a><br /></td></tr>
<tr class="separator:a36edced314272a5b31cea3649f6a7ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a56ccafca54cfc4f7f6231b198b1e2d86"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; <a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86">ModuleData</a></td></tr>
<tr class="memdesc:a56ccafca54cfc4f7f6231b198b1e2d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module data belonging to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance.  <a href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86">More...</a><br /></td></tr>
<tr class="separator:a56ccafca54cfc4f7f6231b198b1e2d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6848726c4ec4d5eaeb2b4e6d710f268"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268">RegisteredEvents</a></td></tr>
<tr class="memdesc:ab6848726c4ec4d5eaeb2b4e6d710f268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a list of pointers to managers of event listeners of the events this module has registered/subscribed to. The stored pointers always outlive all module instances since they are static members of types derived from <code><a class="el" href="classDynExp_1_1InterModuleEvent.html" title="Typed base class for inter-module events to realize CRTP.">InterModuleEvent</a></code>.  <a href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268">More...</a><br /></td></tr>
<tr class="separator:ab6848726c4ec4d5eaeb2b4e6d710f268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Override</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6da8e67225fdcfa78c3ea5dc3154b849"></a>Override by derived classes. </p>
</td></tr>
<tr class="memitem:aff620d0db4b7bc90490e2c6f93db224f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#aff620d0db4b7bc90490e2c6f93db224f">HasUI</a> () const noexcept</td></tr>
<tr class="memdesc:aff620d0db4b7bc90490e2c6f93db224f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this module possesses a user interface (UI) which is shown in a window dedicated to the module.  <a href="classDynExp_1_1ModuleBase.html#aff620d0db4b7bc90490e2c6f93db224f">More...</a><br /></td></tr>
<tr class="separator:aff620d0db4b7bc90490e2c6f93db224f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c362a3e086828a2ccbde05fb5d4795"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ae8c362a3e086828a2ccbde05fb5d4795">TreatModuleExceptionsAsWarnings</a> () const</td></tr>
<tr class="memdesc:ae8c362a3e086828a2ccbde05fb5d4795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this module should be terminated if an exception leaves the module's main loop or respective event handlers.  <a href="classDynExp_1_1ModuleBase.html#ae8c362a3e086828a2ccbde05fb5d4795">More...</a><br /></td></tr>
<tr class="separator:ae8c362a3e086828a2ccbde05fb5d4795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7baae8cb81ade4cc48898d72eff8693"><td class="memItemLeft" align="right" valign="top">virtual std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#af7baae8cb81ade4cc48898d72eff8693">GetMainLoopDelay</a> () const</td></tr>
<tr class="memdesc:af7baae8cb81ade4cc48898d72eff8693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies in which time intervals the module's event queue runs to handle pending events.  <a href="classDynExp_1_1ModuleBase.html#af7baae8cb81ade4cc48898d72eff8693">More...</a><br /></td></tr>
<tr class="separator:af7baae8cb81ade4cc48898d72eff8693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1814f6d7cb0b105f4e534c83360405c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#ae1814f6d7cb0b105f4e534c83360405c">OnPauseChild</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance) const</td></tr>
<tr class="memdesc:ae1814f6d7cb0b105f4e534c83360405c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler gets called just after the module pauses due to e.g. an error in an instrument the module depends on. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#ae1814f6d7cb0b105f4e534c83360405c" title="This handler gets called just after the module pauses due to e.g. an error in an instrument the modul...">OnPauseChild()</a></code> to e.g. abort a measurement or to store internal states for resuming later.  <a href="classDynExp_1_1ModuleBase.html#ae1814f6d7cb0b105f4e534c83360405c">More...</a><br /></td></tr>
<tr class="separator:ae1814f6d7cb0b105f4e534c83360405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb479cbfe5bf10898ce48c52bac0a05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a5eb479cbfe5bf10898ce48c52bac0a05">OnResumeChild</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance) const</td></tr>
<tr class="memdesc:a5eb479cbfe5bf10898ce48c52bac0a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler gets called just after the module resumed from a paused state. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5eb479cbfe5bf10898ce48c52bac0a05" title="This handler gets called just after the module resumed from a paused state. Override OnResumeChild() ...">OnResumeChild()</a></code> to reinitialize instruments or a measurement routine.  <a href="classDynExp_1_1ModuleBase.html#a5eb479cbfe5bf10898ce48c52bac0a05">More...</a><br /></td></tr>
<tr class="separator:a5eb479cbfe5bf10898ce48c52bac0a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22578f8bc7260fd4aff1b96322b9d87c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a22578f8bc7260fd4aff1b96322b9d87c">OnErrorChild</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance) const</td></tr>
<tr class="memdesc:a22578f8bc7260fd4aff1b96322b9d87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler gets called just before the module thread terminates due to an exception. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a22578f8bc7260fd4aff1b96322b9d87c" title="This handler gets called just before the module thread terminates due to an exception....">OnErrorChild()</a></code> to perform shutdown and cleanup actions.  <a href="classDynExp_1_1ModuleBase.html#a22578f8bc7260fd4aff1b96322b9d87c">More...</a><br /></td></tr>
<tr class="separator:a22578f8bc7260fd4aff1b96322b9d87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5d5962e1961e61f8d6e261a13576dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd">RestoreWindowStatesFromParamsChild</a> ()</td></tr>
<tr class="memdesc:a8f5d5962e1961e61f8d6e261a13576dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classDynExp_1_1ModuleBase.html#af397d2e01e526d907480e0b757f58f0d" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParams()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code> to restore the styles of possibly owned windows according to the style saved in the module's parameters.  <a href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd">More...</a><br /></td></tr>
<tr class="separator:a8f5d5962e1961e61f8d6e261a13576dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd5df7dceed175019e087a8694ed8fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc">UpdateParamsFromWindowStatesChild</a> ()</td></tr>
<tr class="memdesc:acdd5df7dceed175019e087a8694ed8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classDynExp_1_1ModuleBase.html#a6919d21e63bd4f1329275f7e941b0142" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStates()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code> to store the styles of possibly owned windows in the module's parameters.  <a href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc">More...</a><br /></td></tr>
<tr class="separator:acdd5df7dceed175019e087a8694ed8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe86b2a8c7a6e60a2937be8b2a0e6b00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57">Util::DynExpErrorCodes::DynExpErrorCodes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html#abe86b2a8c7a6e60a2937be8b2a0e6b00">ModuleMainLoop</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;Instance)=0</td></tr>
<tr class="memdesc:abe86b2a8c7a6e60a2937be8b2a0e6b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module main loop. The function is executed periodically by the module thread. Also refer to <code><a class="el" href="classDynExp_1_1ModuleBase.html#af7baae8cb81ade4cc48898d72eff8693" title="Specifies in which time intervals the module&#39;s event queue runs to handle pending events.">GetMainLoopDelay()</a></code>.  <a href="classDynExp_1_1ModuleBase.html#abe86b2a8c7a6e60a2937be8b2a0e6b00">More...</a><br /></td></tr>
<tr class="separator:abe86b2a8c7a6e60a2937be8b2a0e6b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classDynExp_1_1RunnableObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDynExp_1_1RunnableObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDynExp_1_1RunnableObject.html">DynExp::RunnableObject</a></td></tr>
<tr class="memitem:a39ef8e00794211e897f2d50905639772 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a39ef8e00794211e897f2d50905639772">Init</a> ()</td></tr>
<tr class="memdesc:a39ef8e00794211e897f2d50905639772 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes member variables in case of a reset.  <a href="classDynExp_1_1RunnableObject.html#a39ef8e00794211e897f2d50905639772">More...</a><br /></td></tr>
<tr class="separator:a39ef8e00794211e897f2d50905639772 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a89773cf56f3c229dd9c141de12ab3 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">std::promise&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a28a89773cf56f3c229dd9c141de12ab3">MakeThreadExitedPromise</a> ()</td></tr>
<tr class="memdesc:a28a89773cf56f3c229dd9c141de12ab3 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to be used by overridden <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a></code> functions in derived classes to (re)initialize the <a class="el" href="classDynExp_1_1RunnableObject.html#a45a818a181d16129dfb43080152527c4" title="Future which signals that Thread has terminated. Refer to OnThreadHasExited().">ThreadExitedSignal</a> future and to provide the derived class a promise to signal the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance that its thread has terminated.  <a href="classDynExp_1_1RunnableObject.html#a28a89773cf56f3c229dd9c141de12ab3">More...</a><br /></td></tr>
<tr class="separator:a28a89773cf56f3c229dd9c141de12ab3 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac70e1485923ee8c78ed5732099b4c90 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aac70e1485923ee8c78ed5732099b4c90">StoreThread</a> (std::thread &amp;&amp;<a class="el" href="classDynExp_1_1RunnableObject.html#a7f653f6a7407d6a69dd9d75858d6b363">Thread</a>) noexcept</td></tr>
<tr class="memdesc:aac70e1485923ee8c78ed5732099b4c90 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a thread constructed by a derived class overriding <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a></code> in <code>Thread</code> taking ownership of the thread. Only call this function within <code><a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63" title="Refer to Run().">RunChild()</a>!</code>  <a href="classDynExp_1_1RunnableObject.html#aac70e1485923ee8c78ed5732099b4c90">More...</a><br /></td></tr>
<tr class="separator:aac70e1485923ee8c78ed5732099b4c90 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fc682e09f7e23e2a65fc8b8eef7106 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a21fc682e09f7e23e2a65fc8b8eef7106">IsCallFromRunnableThread</a> () const</td></tr>
<tr class="memdesc:a21fc682e09f7e23e2a65fc8b8eef7106 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>Thread's</code> id matches the id of the calling thread. This is thread-safe if the function is called by the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread since <code><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">Terminate()</a></code> joins the threads before changing the <code>Thread</code> member. It is also thread-safe if the function is called by the thread owning the the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance since <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> and <code><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">Terminate()</a></code> can only be called by this thread. Only <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code> and <code><a class="el" href="classDynExp_1_1RunnableObject.html#afae3d704e86c69825835ba35399d87f1" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">Terminate()</a></code> (indirectly) modify <code>Thread</code>.  <a href="classDynExp_1_1RunnableObject.html#a21fc682e09f7e23e2a65fc8b8eef7106">More...</a><br /></td></tr>
<tr class="separator:a21fc682e09f7e23e2a65fc8b8eef7106 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb143a7fd58432e344ab53a2f8f41ae2 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#aeb143a7fd58432e344ab53a2f8f41ae2">EnsureCallFromRunnableThread</a> () const</td></tr>
<tr class="memdesc:aeb143a7fd58432e344ab53a2f8f41ae2 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the call to this function is performed from the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance's thread by calling <a class="el" href="classDynExp_1_1RunnableObject.html#a21fc682e09f7e23e2a65fc8b8eef7106" title="Checks whether Thread&#39;s id matches the id of the calling thread. This is thread-safe if the function ...">IsCallFromRunnableThread()</a>.  <a href="classDynExp_1_1RunnableObject.html#aeb143a7fd58432e344ab53a2f8f41ae2">More...</a><br /></td></tr>
<tr class="separator:aeb143a7fd58432e344ab53a2f8f41ae2 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4faad6fc3ff1e9b398b61a5d3a7f586 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#ae4faad6fc3ff1e9b398b61a5d3a7f586">SetReasonWhyPaused</a> (std::string Description)</td></tr>
<tr class="memdesc:ae4faad6fc3ff1e9b398b61a5d3a7f586 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason why this <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance has been paused.  <a href="classDynExp_1_1RunnableObject.html#ae4faad6fc3ff1e9b398b61a5d3a7f586">More...</a><br /></td></tr>
<tr class="separator:ae4faad6fc3ff1e9b398b61a5d3a7f586 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505a71aea1cac9f7625784095f8ff7f inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#a5505a71aea1cac9f7625784095f8ff7f">SetReasonWhyPaused</a> (const <a class="el" href="classUtil_1_1Exception.html">Util::Exception</a> &amp;e)</td></tr>
<tr class="memdesc:a5505a71aea1cac9f7625784095f8ff7f inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason why this <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance has been paused.  <a href="classDynExp_1_1RunnableObject.html#a5505a71aea1cac9f7625784095f8ff7f">More...</a><br /></td></tr>
<tr class="separator:a5505a71aea1cac9f7625784095f8ff7f inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cadbf7dbaff94692a73ddbf1ab8c28 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html#ae0cadbf7dbaff94692a73ddbf1ab8c28">ClearReasonWhyPaused</a> ()</td></tr>
<tr class="memdesc:ae0cadbf7dbaff94692a73ddbf1ab8c28 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the reason why this <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance has been paused (since it is resumed).  <a href="classDynExp_1_1RunnableObject.html#ae0cadbf7dbaff94692a73ddbf1ab8c28">More...</a><br /></td></tr>
<tr class="separator:ae0cadbf7dbaff94692a73ddbf1ab8c28 inherit pro_methods_classDynExp_1_1RunnableObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classUtil_1_1INonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classUtil_1_1INonCopyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memitem:a4442a7fe15262e3ad291220b0af2cd0b inherit pro_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a4442a7fe15262e3ad291220b0af2cd0b">INonCopyable</a> ()=default</td></tr>
<tr class="separator:a4442a7fe15262e3ad291220b0af2cd0b inherit pro_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f837dbc82c4bbf3905900ed59d30152 inherit pro_methods_classUtil_1_1INonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a8f837dbc82c4bbf3905900ed59d30152">~INonCopyable</a> ()=default</td></tr>
<tr class="separator:a8f837dbc82c4bbf3905900ed59d30152 inherit pro_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a10164159ffa218cb580e98cbdc1d49a2">Object</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1Object.html#a10164159ffa218cb580e98cbdc1d49a2">More...</a><br /></td></tr>
<tr class="separator:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477148f8a4a1b829edbb96ca03bfaaa2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a477148f8a4a1b829edbb96ca03bfaaa2">~Object</a> ()=0</td></tr>
<tr class="separator:a477148f8a4a1b829edbb96ca03bfaaa2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af6fde3f79ccf7e596889176af39ab6b2">EnsureCallFromOwningThread</a> () const</td></tr>
<tr class="memdesc:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the call to this function is performed from the thread which constructed this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance (the thread with the id stored in <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd" title="Thread id of the thread which has constructed (and owns) this Object instance.">Object::OwnerThreadID</a>).  <a href="classDynExp_1_1Object.html#af6fde3f79ccf7e596889176af39ab6b2">More...</a><br /></td></tr>
<tr class="separator:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a98a7bb1553e393adbc62d28911d82f42">GetNonConstParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows derived <code>Objects</code> to edit their own parameters - even in const task functions (for instruments) or event functions (for modules).  <a href="classDynExp_1_1Object.html#a98a7bb1553e393adbc62d28911d82f42">More...</a><br /></td></tr>
<tr class="separator:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af6f3ec1d9b22c4699e344d58ab7a873c">LockUserList</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>)</td></tr>
<tr class="memdesc:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the user list for thread-safe manipulation.  <a href="classDynExp_1_1Object.html#af6f3ec1d9b22c4699e344d58ab7a873c">More...</a><br /></td></tr>
<tr class="separator:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5f51f73ef153e261856790b5a9e8870">DeregisterAllUnsafe</a> ()</td></tr>
<tr class="memdesc:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregisters all users and notifies them that they need to check the states of their used linked objects.  <a href="classDynExp_1_1Object.html#ac5f51f73ef153e261856790b5a9e8870">More...</a><br /></td></tr>
<tr class="separator:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0517857d7390e4a40c0bfbf47ac85e2 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ab0517857d7390e4a40c0bfbf47ac85e2">GetUseCountUnsafe</a> ()</td></tr>
<tr class="separator:ab0517857d7390e4a40c0bfbf47ac85e2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b2f15f8129c30d4d3525b187e7ed2b inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a76b2f15f8129c30d4d3525b187e7ed2b">GetUserNamesStringUnsafe</a> () const</td></tr>
<tr class="separator:a76b2f15f8129c30d4d3525b187e7ed2b inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a61de80a7326bf7bf35700e9e76d7ea45">IsUnusedUnsafe</a> ()</td></tr>
<tr class="memdesc:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is used by other instances (not thread-safe).  <a href="classDynExp_1_1Object.html#a61de80a7326bf7bf35700e9e76d7ea45">More...</a><br /></td></tr>
<tr class="separator:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for modules. Modules implement programs on their own (e.g. measurement protocols or servers for ethernet communication). They might have a user interface. Modules make use of meta instruments (<code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>) to implement e.g. measurement routines on a higher level, which renders the modules independent from physical devices from specific manufacturers. Derive from this class to implement modules without a user interface. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00391">391</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad5aeb623c59ea374c078c24bb85d9d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aeb623c59ea374c078c24bb85d9d1a">&#9670;&nbsp;</a></span>ConfigType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1ModuleBase.html#ad5aeb623c59ea374c078c24bb85d9d1a">DynExp::ModuleBase::ConfigType</a> =  <a class="el" href="classDynExp_1_1ModuleConfiguratorBase.html">ModuleConfiguratorBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00444">444</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a197bd1be0fef72c813ab69a772823c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197bd1be0fef72c813ab69a772823c5d">&#9670;&nbsp;</a></span>ModuleDataGetterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1ModuleBase.html#a197bd1be0fef72c813ab69a772823c5d">DynExp::ModuleBase::ModuleDataGetterType</a> =  <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt;<a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a>, <a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleDataTypeSyncPtrType</a> (ModuleBase::*)(const std::chrono::milliseconds)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">ModuleBase::GetModuleData()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00586">586</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a5f951c9f5a84261efae867bf9c51b1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f951c9f5a84261efae867bf9c51b1fb">&#9670;&nbsp;</a></span>ModuleDataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">DynExp::ModuleBase::ModuleDataType</a> =  <a class="el" href="classDynExp_1_1ModuleDataBase.html">ModuleDataBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the data class belonging to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> type. Declare this alias in every derived class with the respective data class accompanying the derived <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00450">450</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a9080ee1a99b5e77959e571be22dce1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9080ee1a99b5e77959e571be22dce1a5">&#9670;&nbsp;</a></span>ModuleDataTypeSyncPtrConstType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">DynExp::ModuleBase::ModuleDataTypeSyncPtrConstType</a> =  <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt;const <a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the return type of ModuleBase::GetModuleData() const. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00462">462</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="aae553980005909642693d3cbbae0e96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae553980005909642693d3cbbae0e96b">&#9670;&nbsp;</a></span>ModuleDataTypeSyncPtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">DynExp::ModuleBase::ModuleDataTypeSyncPtrType</a> =  <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt;<a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the return type of <a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">ModuleBase::GetModuleData()</a>. Data class instances wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00456">456</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a80f112aebff5ce1b782577b2fc323418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f112aebff5ce1b782577b2fc323418">&#9670;&nbsp;</a></span>ParamsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1ModuleBase.html#a80f112aebff5ce1b782577b2fc323418">DynExp::ModuleBase::ParamsType</a> =  <a class="el" href="classDynExp_1_1ModuleParamsBase.html">ModuleParamsBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00443">443</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8630ea32b290077f187c42480b00d290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8630ea32b290077f187c42480b00d290">&#9670;&nbsp;</a></span>ModuleBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynExp::ModuleBase::ModuleBase </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id&#160;</td>
          <td class="paramname"><em>OwnerThreadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OwnerThreadID</td><td>Thread id of the thread owning the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to be constructed. </td></tr>
    <tr><td class="paramname">Params</td><td>Parameter class instance to be assigned to the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>OwnerThreadID</code> is an invalid thread id or if <code>Params</code> is nullptr. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <a class="el" href="classDynExp_1_1ModuleParamsBase.html#a2e36fe2c76151ac0d2eaa8b1b2f38c0a" title="Just used temporarily during the construction of a module. Refer to MakeModule() and ModuleBase::Modu...">ModuleParamsBase::ModuleData</a> of <code>Params</code> is nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00189">189</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a5a0289cb33c49e80391b55f899199413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0289cb33c49e80391b55f899199413">&#9670;&nbsp;</a></span>~ModuleBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynExp::ModuleBase::~ModuleBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00198">198</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2010071b9ef285d63381fb9e4d186b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2010071b9ef285d63381fb9e4d186b6">&#9670;&nbsp;</a></span>AddRegisteredEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::AddRegisteredEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a> &amp;&#160;</td>
          <td class="paramname"><em>EventListeners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a manager of event listeners to <a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268" title="Holds a list of pointers to managers of event listeners of the events this module has registered/subs...">RegisteredEvents</a> if it was not already added before. Called indirectly by <a class="el" href="classDynExp_1_1TypedEventListeners.html#ad00404b8a0a59e5167586c02a83c1482" title="Registers/Subscribes module Listener to the event with the event function EventFunc....">TypedEventListeners::Register()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EventListeners</td><td>Manager of event listeners to add </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00242">242</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="abb8b0a39ab6950220cbf2c812295889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b0a39ab6950220cbf2c812295889f">&#9670;&nbsp;</a></span>Category()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static auto DynExp::ModuleBase::Category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Every derived class has to redefine this function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the category of this module type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00468">468</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a784b327cbbba14124e1e303b289714c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784b327cbbba14124e1e303b289714c4">&#9670;&nbsp;</a></span>EnqueueEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::EnqueueEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleDataBase.html#a3bd0088908e8bd4f59ba294a75e9ed3e">ModuleDataBase::EventPtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Event</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues <code>Event</code> at the module event queue's back. Takes ownership of the event. Notifies the module owning the respective <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a>'s</code> instance that a new event has been enqueued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Event</td><td>Pointer to the event to be enqueued. Must not be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>Event</code> is nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00212">212</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="afdb9fa22465fe0fc2ca36ba510a37f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb9fa22465fe0fc2ca36ba510a37f45">&#9670;&nbsp;</a></span>ExecModuleMainLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57">Util::DynExpErrorCodes::DynExpErrorCodes</a> DynExp::ModuleBase::ExecModuleMainLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs <code><a class="el" href="classDynExp_1_1ModuleBase.html#abe86b2a8c7a6e60a2937be8b2a0e6b00" title="Module main loop. The function is executed periodically by the module thread. Also refer to GetMainLo...">ModuleMainLoop()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57a0902dabc399ef983a70150b54f735e24">Util::DynExpErrorCodes::NoError</a> if module loop should continue, annother error code otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00264">264</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a6d50167b798951b1a347739976a007d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d50167b798951b1a347739976a007d1">&#9670;&nbsp;</a></span>GetCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string DynExp::ModuleBase::GetCategory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the category of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. </p>

<p>Implements <a class="el" href="classDynExp_1_1Object.html#a378599da58153d446bd382e89be2203c">DynExp::Object</a>.</p>

<p>Reimplemented in <a class="el" href="classDynExpModule_1_1Widefield_1_1WidefieldMicroscope.html#a80a37a0ee7b5f8625b79ebf4c3102805">DynExpModule::Widefield::WidefieldMicroscope</a>, <a class="el" href="classDynExpModule_1_1Trajectory1D.html#af1d38843f5d4d428a7b9e8489685beb6">DynExpModule::Trajectory1D</a>, <a class="el" href="classDynExpModule_1_1StreamManipulator.html#a5bb8b3b859e73d5a69d86f2e43f58bc2">DynExpModule::StreamManipulator</a>, <a class="el" href="classDynExpModule_1_1Stage1D.html#ae6b0e4030dd0e346cd54bfa16277355d">DynExpModule::Stage1D</a>, <a class="el" href="classDynExpModule_1_1SpectrumViewer_1_1SpectrumViewer.html#ad7ff633fc9d84f47fb4bbf0836630da7">DynExpModule::SpectrumViewer::SpectrumViewer</a>, <a class="el" href="classDynExpModule_1_1SignalPlotter.html#a0de2444508ea5e84a3ea85eec2ba0869">DynExpModule::SignalPlotter</a>, <a class="el" href="classDynExpModule_1_1SignalDesigner.html#ae80b4812600437d628c787f9511bcd02">DynExpModule::SignalDesigner</a>, <a class="el" href="classDynExpModule_1_1OutputPortWriter.html#a1fe975acc1a070922751bf259ba98fb2">DynExpModule::OutputPortWriter</a>, <a class="el" href="classDynExpModule_1_1ODMR_1_1ODMR.html#a1a4649a045214c704de902d9268f4ac4">DynExpModule::ODMR::ODMR</a>, <a class="el" href="classDynExpModule_1_1LockinAmplifierControl.html#ac7f4d7237150121f8739d74bee455214">DynExpModule::LockinAmplifierControl</a>, <a class="el" href="classDynExpModule_1_1InputPortReader.html#a2dd0a060b41a04d092e35c76f0883815">DynExpModule::InputPortReader</a>, <a class="el" href="classDynExpModule_1_1ImageViewer_1_1ImageViewer.html#a599238c3fd92fed1fd040f7b920d03a8">DynExpModule::ImageViewer::ImageViewer</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#ae6f5109578a311f8eeb43c0c31831afc">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#ae6f5109578a311f8eeb43c0c31831afc">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>, and <a class="el" href="classDynExpModule_1_1ArbitraryFunctionFromCSV.html#a967269a12f232208345f7e36266f46ed">DynExpModule::ArbitraryFunctionFromCSV</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00479">479</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="ad242f26db214876d935a313467a19c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad242f26db214876d935a313467a19c72">&#9670;&nbsp;</a></span>GetExceptionChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr DynExp::ModuleBase::GetExceptionChild </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00358">358</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a3b5f0043da6a34555b28ba05fd070e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5f0043da6a34555b28ba05fd070e65">&#9670;&nbsp;</a></span>GetExceptionUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto DynExp::ModuleBase::GetExceptionUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">ModuleDataTypeSyncPtrConstType</a> &amp;&#160;</td>
          <td class="paramname"><em>ModuleDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for <a class="el" href="classDynExp_1_1ModuleDataBase.html#a17e379588d31f7daf6a5e1a855bbb6b9" title="Used to transfer exceptions from the module thread to the main (user interface) thread....">ModuleDataBase::ModuleException</a> assuming that the module data has already been locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ModuleDataPtr</td><td>Synchronized pointer to the locked <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the exception being responsible for the module's current state. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00610">610</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="af7baae8cb81ade4cc48898d72eff8693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7baae8cb81ade4cc48898d72eff8693">&#9670;&nbsp;</a></span>GetMainLoopDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::chrono::milliseconds DynExp::ModuleBase::GetMainLoopDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies in which time intervals the module's event queue runs to handle pending events. </p>
<dl class="section return"><dt>Returns</dt><dd>Delay time in between event queue executions. Return <code>std::chrono::milliseconds::max()</code> to make the module thread only wake up to execute the module main loop (after handling enqueued events) when an event is enqueued. Return 0 to make the module main loop execute as fast as possible. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExpModule_1_1Widefield_1_1WidefieldMicroscope.html#ae59e24b742dc548d4fd8fbf2db376172">DynExpModule::Widefield::WidefieldMicroscope</a>, <a class="el" href="classDynExpModule_1_1Trajectory1D.html#a39c436c9e3e1f422e050eb762bc11d53">DynExpModule::Trajectory1D</a>, <a class="el" href="classDynExpModule_1_1StreamManipulator.html#adef61dee90809b4af30e263ba7dc3e86">DynExpModule::StreamManipulator</a>, <a class="el" href="classDynExpModule_1_1Stage1D.html#aaada5b9359b0c0e58cda837482b79ff9">DynExpModule::Stage1D</a>, <a class="el" href="classDynExpModule_1_1SpectrumViewer_1_1SpectrumViewer.html#af03d022bdb99273d2bb88fc2b2162ba1">DynExpModule::SpectrumViewer::SpectrumViewer</a>, <a class="el" href="classDynExpModule_1_1SignalPlotter.html#a096da5998caa8c9e35b2006a42de4c43">DynExpModule::SignalPlotter</a>, <a class="el" href="classDynExpModule_1_1OutputPortWriter.html#affa7ae0dbd2c181dea1dfece434d5ebe">DynExpModule::OutputPortWriter</a>, <a class="el" href="classDynExpModule_1_1ODMR_1_1ODMR.html#a471fc95eaad1138349a2682bf967019c">DynExpModule::ODMR::ODMR</a>, <a class="el" href="classDynExpModule_1_1LockinAmplifierControl.html#a21d4f950e245f675267ecea4c132e4e6">DynExpModule::LockinAmplifierControl</a>, <a class="el" href="classDynExpModule_1_1InputPortReader.html#a364a982e4c9a5bc8c75f5df8282f1859">DynExpModule::InputPortReader</a>, <a class="el" href="classDynExpModule_1_1ImageViewer_1_1ImageViewer.html#a8981571eb09187a6125e450fa5d11ea3">DynExpModule::ImageViewer::ImageViewer</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a28acf451c41f47435e58b12319ea06bf">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a28acf451c41f47435e58b12319ea06bf">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>, and <a class="el" href="classDynExpModule_1_1ArbitraryFunctionFromCSV.html#a80ffa0ba1c89af283830c7132743b28f">DynExpModule::ArbitraryFunctionFromCSV</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00506">506</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a09d6b4890c72c88ac9b9407fc51f0436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d6b4890c72c88ac9b9407fc51f0436">&#9670;&nbsp;</a></span>GetModuleData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleBase::ModuleDataTypeSyncPtrType</a> DynExp::ModuleBase::GetModuleData </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em> = <code><a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex of the module data class instance <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a> assigned to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. Module data should not be locked by having called this function while subsequently calling a derived module's method which also makes use of the module's data by locking it. If this happens, the module data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait for locking the mutex of <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code>ModuleDataType</code> (non-const) to allow access all of its members. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00202">202</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a06c07500c142248230cef06214b2dba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c07500c142248230cef06214b2dba3">&#9670;&nbsp;</a></span>GetModuleData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1ModuleBase.html#a9080ee1a99b5e77959e571be22dce1a5">ModuleBase::ModuleDataTypeSyncPtrConstType</a> DynExp::ModuleBase::GetModuleData </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em> = <code><a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex of the module data class instance <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a> assigned to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. Module data should not be locked by having called this function while subsequently calling a derived module's method which also makes use of the module's data by locking it. If this happens, the module data's mutex is locked recursively. In principle, this does no harm since <a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">Util::ISynchronizedPointerLockable</a> supports that. But, it is not considered good practice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait for locking the mutex of <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to const <code>ModuleDataType</code>, since access to non-const members of <code>ModuleDataType</code> is only allowed to the main thread! </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00207">207</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="ae473e688cb173ee492e7663815462ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae473e688cb173ee492e7663815462ce1">&#9670;&nbsp;</a></span>GetNonConstModuleData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1ModuleBase.html#aae553980005909642693d3cbbae0e96b">ModuleBase::ModuleDataTypeSyncPtrType</a> DynExp::ModuleBase::GetNonConstModuleData </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em> = <code><a class="el" href="classDynExp_1_1ModuleBase.html#ad26a3040b59bb39a2cbf921b072e0306">GetModuleDataTimeoutDefault</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Always allows <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> to obtain a non-const pointer to the module's data - even in const event functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait for locking the mutex of <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to <code>ModuleDataType</code> (non-const) to allow access all of its members. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00217">217</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a832cb100caeb9bcba79c515efc5b5f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832cb100caeb9bcba79c515efc5b5f71">&#9670;&nbsp;</a></span>HandleEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::HandleEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes and removes the next pending event from the module's event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00222">222</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="aff620d0db4b7bc90490e2c6f93db224f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff620d0db4b7bc90490e2c6f93db224f">&#9670;&nbsp;</a></span>HasUI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DynExp::ModuleBase::HasUI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this module possesses a user interface (UI) which is shown in a window dedicated to the module. </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if the module possesses an UI, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExp_1_1QModuleBase.html#a506328ffa55d9148d61ed062528c380b">DynExp::QModuleBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00490">490</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="adb81c2e4107ab33b51cf053b38927cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb81c2e4107ab33b51cf053b38927cc5">&#9670;&nbsp;</a></span>IsReadyChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DynExp::ModuleBase::IsReadyChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classDynExp_1_1Object.html#a4dc92bcd4b24ce2242b323f6ebac070a">DynExp::Object</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00368">368</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a6929f6ac89a2c9f9c4e686c59acd31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6929f6ac89a2c9f9c4e686c59acd31ce">&#9670;&nbsp;</a></span>MakeAndEnqueueEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiverType , typename EventType , typename... ArgsTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::MakeAndEnqueueEvent </td>
          <td>(</td>
          <td class="paramtype">ReceiverType *&#160;</td>
          <td class="paramname"><em>Receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventType&#160;</td>
          <td class="paramname"><em>EventFuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="namespaceDynExp.html#ac244e17a12bb64ee2d459fc347c97cb6" title="Creates an event of type DefaultEvent.">MakeEvent()</a></code> to construct a new event and subsequently enqueues the event into the module's event queue. Logical const-ness: this is a const member function to allow pointers to <code>const</code> <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> inserting events into the module's event queue. These kind of pointers are e.g. returned by <a class="el" href="classDynExp_1_1RunnableInstance.html#af58777edf59b61db1049e096383ee392" title="Returns Owner.">RunnableInstance::GetOwner()</a> which can be called by events' <a class="el" href="classDynExp_1_1EventBase.html#a77b9b29345abc36c7f798e1ae3822670" title="Invokes the event passing the receiving module&#39;s instance reference to it.">EventBase::InvokeChild()</a> functions. For <code>const</code> <code>ModuleBase*</code>, it is possible to insert events into the event queue, but not to change the <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> object itself (e.g. calling <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReceiverType</td><td>Module type to receive this event. </td></tr>
    <tr><td class="paramname">EventType</td><td>Type (signature) of the event function. </td></tr>
    <tr><td class="paramname">...ArgsTs</td><td>Types of arguments passed to the event function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Receiver</td><td>Pointer to the module receiving this event. Pointer <code>this</code> is not directly used since it is not a pointer to the derived type. Passing a pointer to the derived type saves a <code>dynamic_cast</code> operation. </td></tr>
    <tr><td class="paramname">EventFuncPtr</td><td>Event function to be invoked (member function of <code>ReceiverType</code> expected). </td></tr>
    <tr><td class="paramname">...Args</td><td>Arguments to pass to the event function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>Receiver</code> is not a pointer to the <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance <a class="el" href="classDynExp_1_1ModuleBase.html#a6929f6ac89a2c9f9c4e686c59acd31ce" title="Calls MakeEvent() to construct a new event and subsequently enqueues the event into the module&#39;s even...">ModuleBase::MakeAndEnqueueEvent()</a> is called on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00780">780</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="ab40d048de291a9076061c4a6773ba4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40d048de291a9076061c4a6773ba4eb">&#9670;&nbsp;</a></span>MakeStartupBusyDialogChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classBusyDialog.html">BusyDialog</a> &gt; DynExp::ModuleBase::MakeStartupBusyDialogChild </td>
          <td>(</td>
          <td class="paramtype">QWidget *&#160;</td>
          <td class="paramname"><em>ParentWidget</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override to make this function return a pointer to a <code><a class="el" href="classBusyDialog.html">BusyDialog</a></code> instance. Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ParentWidget</td><td>Qt QWidget acting as a parent of the modal busy dialog </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="el" href="classBusyDialog.html">BusyDialog</a></code> instance </dd></dl>

<p>Reimplemented from <a class="el" href="classDynExp_1_1RunnableObject.html#a56d01789107dfec105f461442f364c30">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00350">350</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="abe86b2a8c7a6e60a2937be8b2a0e6b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe86b2a8c7a6e60a2937be8b2a0e6b00">&#9670;&nbsp;</a></span>ModuleMainLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57">Util::DynExpErrorCodes::DynExpErrorCodes</a> DynExp::ModuleBase::ModuleMainLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Module main loop. The function is executed periodically by the module thread. Also refer to <code><a class="el" href="classDynExp_1_1ModuleBase.html#af7baae8cb81ade4cc48898d72eff8693" title="Specifies in which time intervals the module&#39;s event queue runs to handle pending events.">GetMainLoopDelay()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57a0902dabc399ef983a70150b54f735e24">Util::DynExpErrorCodes::NoError</a> if module loop should continue, annother error code otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classDynExpModule_1_1Widefield_1_1WidefieldMicroscope.html#a67b144ddccd2ae5bf086e70937a36aa4">DynExpModule::Widefield::WidefieldMicroscope</a>, <a class="el" href="classDynExpModule_1_1Trajectory1D.html#acb86499d11bb4fa93fdb0f9290acdfb5">DynExpModule::Trajectory1D</a>, <a class="el" href="classDynExpModule_1_1StreamManipulator.html#a64ab53f56daba425cd2c10f88e7bd28d">DynExpModule::StreamManipulator</a>, <a class="el" href="classDynExpModule_1_1Stage1D.html#addaaf771d71b2d63d512b2bd9a45c8ee">DynExpModule::Stage1D</a>, <a class="el" href="classDynExpModule_1_1SpectrumViewer_1_1SpectrumViewer.html#a3fdd44280aa4bc9dc4274dc0b9462f73">DynExpModule::SpectrumViewer::SpectrumViewer</a>, <a class="el" href="classDynExpModule_1_1SignalPlotter.html#a223c63a821966293de301c558d86ffd6">DynExpModule::SignalPlotter</a>, <a class="el" href="classDynExpModule_1_1SignalDesigner.html#a5a26348ab17d2ed9d16a165ddc87e877">DynExpModule::SignalDesigner</a>, <a class="el" href="classDynExpModule_1_1OutputPortWriter.html#a0e48421f79c08c418a4333d453fe6efa">DynExpModule::OutputPortWriter</a>, <a class="el" href="classDynExpModule_1_1ODMR_1_1ODMR.html#a311914bb55e4a4048226554d6c527010">DynExpModule::ODMR::ODMR</a>, <a class="el" href="classDynExpModule_1_1LockinAmplifierControl.html#a5f8b06da646c5bfbecd26c5cc842501f">DynExpModule::LockinAmplifierControl</a>, <a class="el" href="classDynExpModule_1_1InputPortReader.html#a956ee0c17ec437665f001fe8af01b890">DynExpModule::InputPortReader</a>, <a class="el" href="classDynExpModule_1_1ImageViewer_1_1ImageViewer.html#a4ca1e44d6defd64b5b926faf1117e2ea">DynExpModule::ImageViewer::ImageViewer</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a813ccd4f60b51e1ac0b9351ac688c527">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a813ccd4f60b51e1ac0b9351ac688c527">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>, and <a class="el" href="classDynExpModule_1_1ArbitraryFunctionFromCSV.html#a73a99804febe1a03631ef6f66edb7042">DynExpModule::ArbitraryFunctionFromCSV</a>.</p>

</div>
</div>
<a id="a2e812852c9d7263b07e54e3349032b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e812852c9d7263b07e54e3349032b29">&#9670;&nbsp;</a></span>ModuleSetReasonWhyPaused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::ModuleSetReasonWhyPaused </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reason why this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance has been paused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Description</td><td>Human-readable string describing the reason </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00694">694</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a25c78a68f51f2c1f0b8316f3f85c4996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c78a68f51f2c1f0b8316f3f85c4996">&#9670;&nbsp;</a></span>NotifyChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::NotifyChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify derived classes that some state has changed (e.g. the termination of <code>Thread</code> is requested) and that the child's event/task queue should run now. </p>

<p>Reimplemented from <a class="el" href="classDynExp_1_1RunnableObject.html#a4af7d2755ba134d284e9cfc6ab99b509">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00328">328</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a36edced314272a5b31cea3649f6a7ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36edced314272a5b31cea3649f6a7ca8">&#9670;&nbsp;</a></span>OnDeregisterEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::OnDeregisterEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> *&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This event is triggered after the <code>OnExit</code> event. It calls <a class="el" href="classDynExp_1_1EventListenersBase.html#af1124e3f51d17121973a296b395ae4b7" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">EventListenersBase::Deregister()</a> for all managers of event listeners stored in <a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268" title="Holds a list of pointers to managers of event listeners of the events this module has registered/subs...">RegisteredEvents</a> since we do not trust in derived modules deregistering/unsubscribing from all registered events via <a class="el" href="classDynExp_1_1InterModuleEvent.html#ad1c539c32b97bfcfb7262cc69465be2d" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">InterModuleEvent::Deregister()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00379">379</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="ab86fe18fa3d55d64993569e6d6061889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86fe18fa3d55d64993569e6d6061889">&#9670;&nbsp;</a></span>OnError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::OnError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This handler gets called just before the module thread terminates due to an exception. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a22578f8bc7260fd4aff1b96322b9d87c" title="This handler gets called just before the module thread terminates due to an exception....">OnErrorChild()</a></code> to perform shutdown and cleanup actions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00285">285</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a22578f8bc7260fd4aff1b96322b9d87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22578f8bc7260fd4aff1b96322b9d87c">&#9670;&nbsp;</a></span>OnErrorChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::OnErrorChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This handler gets called just before the module thread terminates due to an exception. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a22578f8bc7260fd4aff1b96322b9d87c" title="This handler gets called just before the module thread terminates due to an exception....">OnErrorChild()</a></code> to perform shutdown and cleanup actions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classDynExpModule_1_1gRPCModule.html#a2d00dda2dcdacdc79f553476c2554ce0">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, and <a class="el" href="classDynExpModule_1_1gRPCModule.html#a2d00dda2dcdacdc79f553476c2554ce0">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00673">673</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a77fb87b30e26eea73d6d53d2d871160a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fb87b30e26eea73d6d53d2d871160a">&#9670;&nbsp;</a></span>OnExit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::OnExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> *&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This event is triggered right before the module thread terminates (not due to an exception, in this case refer to <a class="el" href="classDynExp_1_1ModuleBase.html#ab86fe18fa3d55d64993569e6d6061889" title="This handler gets called just before the module thread terminates due to an exception....">ModuleBase::OnError</a>). Override it to unlock instruments this module depends on (via <a class="el" href="classDynExp_1_1RunnableInstance.html#a2a35438cccb579c51e217d0e50e53797" title="Unlocks an Object instance stored in the LinkedObjectWrapperContainer ObjectWrapperContainer....">RunnableInstance::UnlockObject()</a>) and to deregister/unsubscribe from events (via <a class="el" href="classDynExp_1_1InterModuleEvent.html#ad1c539c32b97bfcfb7262cc69465be2d" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">InterModuleEvent::Deregister()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classDynExpModule_1_1Widefield_1_1WidefieldMicroscope.html#ab5c8afd987c57e557e4c7e1e386f58e6">DynExpModule::Widefield::WidefieldMicroscope</a>, <a class="el" href="classDynExpModule_1_1Trajectory1D.html#a9f80fc455b81ffb43fe634e8e4441ebf">DynExpModule::Trajectory1D</a>, <a class="el" href="classDynExpModule_1_1StreamManipulator.html#ab924fa1db8a207f4d5cb2d059984910f">DynExpModule::StreamManipulator</a>, <a class="el" href="classDynExpModule_1_1Stage1D.html#ad5f545c1109c4fec2e236d4e01e72ff1">DynExpModule::Stage1D</a>, <a class="el" href="classDynExpModule_1_1SpectrumViewer_1_1SpectrumViewer.html#a06da27806f46240c106991753cb72c94">DynExpModule::SpectrumViewer::SpectrumViewer</a>, <a class="el" href="classDynExpModule_1_1SignalPlotter.html#a3adc0f5e1bba080fd16ba07a817062c3">DynExpModule::SignalPlotter</a>, <a class="el" href="classDynExpModule_1_1SignalDesigner.html#a62c41daeaf8077b4f3b040abd42d5f90">DynExpModule::SignalDesigner</a>, <a class="el" href="classDynExpModule_1_1OutputPortWriter.html#a37ae6c00575b0d633a3c558887c3b6d7">DynExpModule::OutputPortWriter</a>, <a class="el" href="classDynExpModule_1_1ODMR_1_1ODMR.html#a3089cd398d623afb7269f4f415ea6151">DynExpModule::ODMR::ODMR</a>, <a class="el" href="classDynExpModule_1_1LockinAmplifierControl.html#aaa232157a63de196e7c791381ce98746">DynExpModule::LockinAmplifierControl</a>, <a class="el" href="classDynExpModule_1_1InputPortReader.html#aa76edd858c11f57c8a5df8b99d11a6f1">DynExpModule::InputPortReader</a>, <a class="el" href="classDynExpModule_1_1ImageViewer_1_1ImageViewer.html#a75b40e2ca3e4317e08c1511f2042da0f">DynExpModule::ImageViewer::ImageViewer</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#af3e72dc07a1d478f089039f247eec7e5">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#af3e72dc07a1d478f089039f247eec7e5">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>, and <a class="el" href="classDynExpModule_1_1ArbitraryFunctionFromCSV.html#a6d484cf3852d5089d1259a1aa8729a87">DynExpModule::ArbitraryFunctionFromCSV</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00728">728</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a51b4635720cb3b96033970dba4a95500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b4635720cb3b96033970dba4a95500">&#9670;&nbsp;</a></span>OnInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::OnInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> *&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This event is triggered right before the module thread starts. Override it to lock instruments this module depends on (via <a class="el" href="classDynExp_1_1RunnableInstance.html#ada6ce77e9ce2a2b30c36aac86724c7ea" title="Locks an Object instance referenced by a parameter LinkParam of type ParamsBase::Param&lt; ObjectLink&lt; O...">RunnableInstance::LockObject()</a>) and to register/subscribe for events (via <a class="el" href="classDynExp_1_1InterModuleEvent.html#a9cef4596c1e4dfbc7c6bdb2b067208da" title="Registers/Subscribes module Listener to the event with the event function EventFunc....">InterModuleEvent::Register()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classDynExpModule_1_1Widefield_1_1WidefieldMicroscope.html#a304ddda54875a234944cae501fa8c10a">DynExpModule::Widefield::WidefieldMicroscope</a>, <a class="el" href="classDynExpModule_1_1Trajectory1D.html#a53da5848d24caf10b4b868f4bb6baffe">DynExpModule::Trajectory1D</a>, <a class="el" href="classDynExpModule_1_1StreamManipulator.html#a0b25947611ac176e213863ef4c3e11a9">DynExpModule::StreamManipulator</a>, <a class="el" href="classDynExpModule_1_1Stage1D.html#acc011c965289d1575c9a1e593985106a">DynExpModule::Stage1D</a>, <a class="el" href="classDynExpModule_1_1SpectrumViewer_1_1SpectrumViewer.html#a4eb78a050431d412662dbe667981d74f">DynExpModule::SpectrumViewer::SpectrumViewer</a>, <a class="el" href="classDynExpModule_1_1SignalPlotter.html#ad533808c7519d41277c180a1a6f77aa8">DynExpModule::SignalPlotter</a>, <a class="el" href="classDynExpModule_1_1SignalDesigner.html#a89f37e2a8055e29ec69651b08cb369fa">DynExpModule::SignalDesigner</a>, <a class="el" href="classDynExpModule_1_1OutputPortWriter.html#ac70194c783f83d9a88a03f2c242aa715">DynExpModule::OutputPortWriter</a>, <a class="el" href="classDynExpModule_1_1ODMR_1_1ODMR.html#ae50cb435ff957b0192734801279f25b5">DynExpModule::ODMR::ODMR</a>, <a class="el" href="classDynExpModule_1_1LockinAmplifierControl.html#a54c003cfc15acfa19c5a5c59f4887fc8">DynExpModule::LockinAmplifierControl</a>, <a class="el" href="classDynExpModule_1_1InputPortReader.html#a643b636412d65077fd675b2e31e24d26">DynExpModule::InputPortReader</a>, <a class="el" href="classDynExpModule_1_1ImageViewer_1_1ImageViewer.html#a320b12959831ffbef29d9ace81d331e0">DynExpModule::ImageViewer::ImageViewer</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a0457346a17af6b957c0a3b0927f35a15">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a0457346a17af6b957c0a3b0927f35a15">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>, and <a class="el" href="classDynExpModule_1_1ArbitraryFunctionFromCSV.html#a7181f10f1d8889eca671cd55814bf7c8">DynExpModule::ArbitraryFunctionFromCSV</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00719">719</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a2428398352d29da29dab0b0c48dbd37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2428398352d29da29dab0b0c48dbd37b">&#9670;&nbsp;</a></span>OnPause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::OnPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This handler gets called just after the module pauses due to e.g. an error in an instrument the module depends on. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#ae1814f6d7cb0b105f4e534c83360405c" title="This handler gets called just after the module pauses due to e.g. an error in an instrument the modul...">OnPauseChild()</a></code> to e.g. abort a measurement or to store internal states for resuming later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00271">271</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="ae1814f6d7cb0b105f4e534c83360405c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1814f6d7cb0b105f4e534c83360405c">&#9670;&nbsp;</a></span>OnPauseChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::OnPauseChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This handler gets called just after the module pauses due to e.g. an error in an instrument the module depends on. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#ae1814f6d7cb0b105f4e534c83360405c" title="This handler gets called just after the module pauses due to e.g. an error in an instrument the modul...">OnPauseChild()</a></code> to e.g. abort a measurement or to store internal states for resuming later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00671">671</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="aa3867671a668012192fec7f649b6e933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3867671a668012192fec7f649b6e933">&#9670;&nbsp;</a></span>OnResume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::OnResume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This handler gets called just after the module resumed from a paused state. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5eb479cbfe5bf10898ce48c52bac0a05" title="This handler gets called just after the module resumed from a paused state. Override OnResumeChild() ...">OnResumeChild()</a></code> to reinitialize instruments or a measurement routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00278">278</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a5eb479cbfe5bf10898ce48c52bac0a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb479cbfe5bf10898ce48c52bac0a05">&#9670;&nbsp;</a></span>OnResumeChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::OnResumeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> &amp;&#160;</td>
          <td class="paramname"><em>Instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This handler gets called just after the module resumed from a paused state. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5eb479cbfe5bf10898ce48c52bac0a05" title="This handler gets called just after the module resumed from a paused state. Override OnResumeChild() ...">OnResumeChild()</a></code> to reinitialize instruments or a measurement routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00672">672</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a79e7cf897ebcdfea8c39f5954bcd3729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e7cf897ebcdfea8c39f5954bcd3729">&#9670;&nbsp;</a></span>RemoveRegisteredEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::RemoveRegisteredEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a> &amp;&#160;</td>
          <td class="paramname"><em>EventListeners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a manager of event listeners from <a class="el" href="classDynExp_1_1ModuleBase.html#ab6848726c4ec4d5eaeb2b4e6d710f268" title="Holds a list of pointers to managers of event listeners of the events this module has registered/subs...">RegisteredEvents</a> if it was added before. Called indirectly by <a class="el" href="classDynExp_1_1TypedEventListeners.html#a9d21b5765fb573f9cdb3302b9c30cf07" title="Deregisters/unsubscribes module Listener from the event. Indirectly calls ModuleBase::RemoveRegistere...">TypedEventListeners::Deregister()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EventListeners</td><td>Manager of event listeners to remove </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00253">253</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a50a25fbb93523e77f80b3f39296da63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a25fbb93523e77f80b3f39296da63d">&#9670;&nbsp;</a></span>ResetImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::ResetImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5a35c378edbab93859bc03833fae2c4f" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy. </p>

<p>Implemented in <a class="el" href="classDynExp_1_1QModuleBase.html#af83ab323976c05c5ba791de5aa61f5c1">DynExp::QModuleBase</a>.</p>

</div>
</div>
<a id="a5a35c378edbab93859bc03833fae2c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a35c378edbab93859bc03833fae2c4f">&#9670;&nbsp;</a></span>ResetImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::ResetImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1RunnableObject.html">RunnableObject</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1ModuleBase.html#a5a35c378edbab93859bc03833fae2c4f" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy. </p>

<p>Implements <a class="el" href="classDynExp_1_1RunnableObject.html#ac90bb7c8a28c813a7f4fd79c081a7aa1">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00309">309</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="af397d2e01e526d907480e0b757f58f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af397d2e01e526d907480e0b757f58f0d">&#9670;&nbsp;</a></span>RestoreWindowStatesFromParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::RestoreWindowStatesFromParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classDynExp_1_1ModuleBase.html#af397d2e01e526d907480e0b757f58f0d" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParams()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code> to restore the styles of possibly owned windows according to the style saved in the module's parameters. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00527">527</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a8f5d5962e1961e61f8d6e261a13576dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5d5962e1961e61f8d6e261a13576dd">&#9670;&nbsp;</a></span>RestoreWindowStatesFromParamsChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::RestoreWindowStatesFromParamsChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classDynExp_1_1ModuleBase.html#af397d2e01e526d907480e0b757f58f0d" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParams()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#a8f5d5962e1961e61f8d6e261a13576dd" title="RestoreWindowStatesFromParams() only calls RestoreWindowStatesFromParamsChild(). Override RestoreWind...">RestoreWindowStatesFromParamsChild()</a></code> to restore the styles of possibly owned windows according to the style saved in the module's parameters. </p>

<p>Reimplemented in <a class="el" href="classDynExp_1_1QModuleBase.html#a2ed40d999b1f90b10ba27c21743041a7">DynExp::QModuleBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00675">675</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a2d871f2200f496821d35999966862271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d871f2200f496821d35999966862271">&#9670;&nbsp;</a></span>RunChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::RunChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a416b8000830913b11eaf02d1f1af49d6" title="Starts the RunnableObject instance&#39;s thread and ensures that all Object instances linked to this inst...">Run()</a></code>. </p>

<p>Implements <a class="el" href="classDynExp_1_1RunnableObject.html#a4c5f38623b6ded650104c80f52885c63">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00317">317</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a023fca52cd7b9acddaae83a931158961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023fca52cd7b9acddaae83a931158961">&#9670;&nbsp;</a></span>TerminateChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::TerminateChild </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>Timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals derived classes that terminating the <a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a> instance's thread is about to be requested. Derived classes might now enqueue respective exit tasks/events into their task/event queues. Refer to <code><a class="el" href="classDynExp_1_1RunnableObject.html#a61aa6890ad8bc345563a8119fb7297d0" title="Notifies the RunnableObject instance&#39;s thread to terminate and waits until it has ended....">TerminateUnsafe()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Time to wait until the <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a>'s</code> thread has ended. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classDynExp_1_1RunnableObject.html#afcbabd17804369f574cd8433b36d4339">DynExp::RunnableObject</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00333">333</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="ae8c362a3e086828a2ccbde05fb5d4795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c362a3e086828a2ccbde05fb5d4795">&#9670;&nbsp;</a></span>TreatModuleExceptionsAsWarnings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DynExp::ModuleBase::TreatModuleExceptionsAsWarnings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this module should be terminated if an exception leaves the module's main loop or respective event handlers. </p>
<dl class="section return"><dt>Returns</dt><dd>Return false if the module should be terminated in case of an uncaught exception, true to only record the exception as the module's warning. </dd></dl>

<p>Reimplemented in <a class="el" href="classDynExpModule_1_1ODMR_1_1ODMR.html#af696df25279114dd84237335196ed27c">DynExpModule::ODMR::ODMR</a>, <a class="el" href="classDynExpModule_1_1StreamManipulator.html#aea29b764e6a3f348f1fed99ea3a18418">DynExpModule::StreamManipulator</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a7ee2b9470535eebcec71f8c00085c8b4">DynExpModule::gRPCModule&lt; gRPCServices &gt;</a>, <a class="el" href="classDynExpModule_1_1gRPCModule.html#a7ee2b9470535eebcec71f8c00085c8b4">DynExpModule::gRPCModule&lt; gRPCServices... &gt;</a>, and <a class="el" href="classDynExpModule_1_1ArbitraryFunctionFromCSV.html#a3b1a4a9eebf82ff46d1e6d9a3c4f2c27">DynExpModule::ArbitraryFunctionFromCSV</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00498">498</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a6919d21e63bd4f1329275f7e941b0142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6919d21e63bd4f1329275f7e941b0142">&#9670;&nbsp;</a></span>UpdateParamsFromWindowStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::ModuleBase::UpdateParamsFromWindowStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classDynExp_1_1ModuleBase.html#a6919d21e63bd4f1329275f7e941b0142" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStates()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code> to store the styles of possibly owned windows in the module's parameters. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00534">534</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="acdd5df7dceed175019e087a8694ed8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd5df7dceed175019e087a8694ed8fc">&#9670;&nbsp;</a></span>UpdateParamsFromWindowStatesChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::ModuleBase::UpdateParamsFromWindowStatesChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="classDynExp_1_1ModuleBase.html#a6919d21e63bd4f1329275f7e941b0142" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStates()</a></code> only calls <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code>. Override <code><a class="el" href="classDynExp_1_1ModuleBase.html#acdd5df7dceed175019e087a8694ed8fc" title="UpdateParamsFromWindowStates() only calls UpdateParamsFromWindowStatesChild(). Override UpdateParamsF...">UpdateParamsFromWindowStatesChild()</a></code> to store the styles of possibly owned windows in the module's parameters. </p>

<p>Reimplemented in <a class="el" href="classDynExp_1_1QModuleBase.html#a15c2ad1e72a7749344585dbb32305bb1">DynExp::QModuleBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00676">676</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aafb7bfaf4658e6b499912178450a5de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb7bfaf4658e6b499912178450a5de0">&#9670;&nbsp;</a></span>EventListenersOnly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1ModuleBase_1_1EventListenersOnlyType.html">EventListenersOnlyType</a> DynExp::ModuleBase::EventListenersOnly</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> private methods to any <code><a class="el" href="classDynExp_1_1TypedEventListeners.html" title="Typed managers of event listeners class whose instances are owned by classes derived from InterModule...">TypedEventListeners</a></code> class. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00516">516</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="ad26a3040b59bb39a2cbf921b072e0306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26a3040b59bb39a2cbf921b072e0306">&#9670;&nbsp;</a></span>GetModuleDataTimeoutDefault</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto DynExp::ModuleBase::GetModuleDataTimeoutDefault = std::chrono::milliseconds(1000)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the default timeout for <code><a class="el" href="classDynExp_1_1ModuleBase.html#a09d6b4890c72c88ac9b9407fc51f0436" title="Locks the mutex of the module data class instance ModuleData assigned to this ModuleBase instance and...">GetModuleData()</a></code> to lock the mutex synchronizing the module's data <a class="el" href="classDynExp_1_1ModuleBase.html#a56ccafca54cfc4f7f6231b198b1e2d86" title="Module data belonging to this ModuleBase instance.">ModuleData</a>. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00513">513</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a56ccafca54cfc4f7f6231b198b1e2d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ccafca54cfc4f7f6231b198b1e2d86">&#9670;&nbsp;</a></span>ModuleData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;<a class="el" href="classDynExp_1_1ModuleBase.html#a5f951c9f5a84261efae867bf9c51b1fb">ModuleDataType</a>&gt; DynExp::ModuleBase::ModuleData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Module data belonging to this <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00743">743</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="aa62c218c15d17c8beeaafbec0e9e2846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62c218c15d17c8beeaafbec0e9e2846">&#9670;&nbsp;</a></span>ModuleThreadOnly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDynExp_1_1ModuleBase_1_1ModuleThreadOnlyType.html">ModuleThreadOnlyType</a> DynExp::ModuleBase::ModuleThreadOnly</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> private methods to the module thread <code><a class="el" href="namespaceDynExp.html#acd637f0e67b9a2815532b5a7e1754bd2" title="Modules run in their own thread. This is the module thread&#39;s main function.">ModuleThreadMain()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00515">515</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="ab6848726c4ec4d5eaeb2b4e6d710f268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6848726c4ec4d5eaeb2b4e6d710f268">&#9670;&nbsp;</a></span>RegisteredEvents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a>*&gt; DynExp::ModuleBase::RegisteredEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a list of pointers to managers of event listeners of the events this module has registered/subscribed to. The stored pointers always outlive all module instances since they are static members of types derived from <code><a class="el" href="classDynExp_1_1InterModuleEvent.html" title="Typed base class for inter-module events to realize CRTP.">InterModuleEvent</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00750">750</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Module_8h_source.html">Module.h</a></li>
<li><a class="el" href="Module_8cpp_source.html">Module.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDynExp.html">DynExp</a></li><li class="navelem"><a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
