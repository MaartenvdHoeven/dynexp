<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynExp: Util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="DynExp.ico"/></td>
  <td id="projectalign">
   <div id="projectname">DynExp
   </div>
   <div id="projectbrief">Highly flexible laboratory automation for dynamically changing experiments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('Util_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Util.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides general utilities within DynExp's Util namespace.  
<a href="#details">More...</a></p>

<p><a href="Util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to delete copy constructor and copy assignment operator and thus make derived classes non-copyable.  <a href="classUtil_1_1INonCopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonMovable.html">Util::INonMovable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to delete move constructor and move assignment operator and thus make derived classes non-movable.  <a href="classUtil_1_1INonMovable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html">Util::ILockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to allow synchronizing the access to derived classes between different threads by providing a mutex and a method to lock that mutex. Recursive locking is <b>not</b> allowed.  <a href="classUtil_1_1ILockable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html">Util::ISynchronizedPointerLockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to allow synchronizing the access to derived classes between different threads by making the class lockable by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">SynchronizedPointer</a> smart pointer objects. Recursive locking is allowed.  <a href="classUtil_1_1ISynchronizedPointerLockable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to lock a class derived from <code><a class="el" href="classUtil_1_1ISynchronizedPointerLockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by making th...">ISynchronizedPointerLockable</a></code> for synchronizing between threads. Instances of this class are not intended to be stored somewhere since they make other threads block. Only use as temporary objects.  <a href="classUtil_1_1SynchronizedPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OneToOneNotifier.html">Util::OneToOneNotifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to communicate flags between different threads based on a condition variable and a mutex. Two threads make use of the same instance of this class. One of the thread awaits a flag to be set by the other thread.  <a href="classUtil_1_1OneToOneNotifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1is__contained__in.html">Util::is_contained_in&lt; T, ListTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type <code>T</code> is contained in a template parameter pack of types <code>ListTs</code>.  <a href="structUtil_1_1is__contained__in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4" id="r_structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4">Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.    <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4" id="r_structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4">Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.    <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4" id="r_structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4">Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.    <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4" id="r_structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4">Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.    <a href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4" id="r_structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4">Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes first type from a tuple of types <code>TupleT</code>.    <a href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4" id="r_structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4">Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an alias for a std::index_sequence where all indices are shifted by an offset.    <a href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1RangeIndexSequence" id="r_structUtil_1_1RangeIndexSequence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">Util::RangeIndexSequence&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:structUtil_1_1RangeIndexSequence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an alias for a std::index_sequence spanning a certain range.  <a href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1RangeIndexSequence"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper&lt; ObjectT, CallableT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a member function of some object and stores its default arguments. Moving from <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">CallableMemberWrapper</a> does not work since this class holds const members and a reference to the object the member function is invoked on. Copy instead.  <a href="classUtil_1_1CallableMemberWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OnDestruction.html">Util::OnDestruction&lt; ObjectT, CallableT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a <code><a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">CallableMemberWrapper</a></code> and invokes its callable when being destroyed.  <a href="classUtil_1_1OnDestruction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1BlobDataType.html">Util::BlobDataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type which manages a binary large object. The reserved memory is freed upon destruction.  <a href="classUtil_1_1BlobDataType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1OptionalBool.html">Util::OptionalBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type which stores an optional bool value (unknown, false, true). The type evaluates to bool while an unknown value is considered false.  <a href="classUtil_1_1OptionalBool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structUtil_1_1VersionType" id="r_structUtil_1_1VersionType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">Util::VersionType</a></td></tr>
<tr class="memdesc:structUtil_1_1VersionType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type describing DynExp's program version in the form Major.Minor.Patch.  <a href="namespaceUtil.html#structUtil_1_1VersionType">More...</a><br /></td></tr>
<tr class="separator:structUtil_1_1VersionType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1Warning.html">Util::Warning</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store information about warnings in a thread-safe manner (deriving from <code><a class="el" href="classUtil_1_1ILockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by providing...">ILockable</a></code>). All function calls are thread-safe.  <a href="classUtil_1_1Warning.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1Warning_1_1WarningData.html">Util::Warning::WarningData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data associated with a warning. The class is convertible to bool (true if it describes an error/warning, false otherwise).  <a href="structUtil_1_1Warning_1_1WarningData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1LogEntry.html">Util::LogEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type of a single entry in DynExp's log.  <a href="structUtil_1_1LogEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1EventLogger.html">Util::EventLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs events like errors and writes them immediately to a HTML file in a human-readable format. The logger also stores the events in an internal event log to be displayed within DynExp. The class is designed such that instances can be shared between different threads. Member function calls are synchronized.  <a href="classUtil_1_1EventLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1FeatureTester.html">Util::FeatureTester&lt; EnumType, &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a bitset containing flags to indicate which features a certain instrument/ module etc. supports.  <a href="classUtil_1_1FeatureTester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1StateMachineState.html">Util::StateMachineState&lt; CallableT, &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State machine state as used by class <a class="el" href="classUtil_1_1StateMachine.html" title="This class models a state machine. It keeps track of the current state and allows to invoke its assoc...">StateMachine</a>. A state mainly wraps a state function of the member function pointer type CallableT to be invoked by the state machine.  <a href="classUtil_1_1StateMachineState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1StateMachineContext.html">Util::StateMachineContext&lt; StateMachineStateT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State machine context as used by class <a class="el" href="classUtil_1_1StateMachine.html" title="This class models a state machine. It keeps track of the current state and allows to invoke its assoc...">StateMachine</a>. A state machine context holds a map with keys and values of unique state identifiers of type StateEnumType (refer to class <a class="el" href="classUtil_1_1StateMachineState.html" title="State machine state as used by class StateMachine. A state mainly wraps a state function of the membe...">StateMachineState</a>). Each map entry indicates a state (key) to be replaced by another state (value). <a class="el" href="classUtil_1_1StateMachine.html#a4362aa008a969e440e4585079c046d80" title="Invokes the state function associated with the current state machine state on an instance of the clas...">StateMachine::Invoke</a> checks the state identifiers returned by <a class="el" href="classUtil_1_1StateMachineState.html#a6ffe3a9eb4a56870df5c4f7016e26e5f" title="Invokes the state function associated with this state on an instance of the class the state function ...">StateMachineState::Invoke</a> and possibly replaces them according to the current context before setting the new state machine state. Contexts can be derived from base contexts unifying and including their replacement lists.  <a href="classUtil_1_1StateMachineContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1StateMachine.html">Util::StateMachine&lt; StateMachineStateT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models a state machine. It keeps track of the current state and allows to invoke its associated state function. The return value of the state function determines the new state to transition into. Additionally, a context of type <a class="el" href="classUtil_1_1StateMachineContext.html" title="State machine context as used by class StateMachine. A state machine context holds a map with keys an...">StateMachineContext</a> can be assigned to the state machine. Contexts allow for replacing states with other states. This makes sense to write inner protocols BeginState -&gt; StateA -&gt; ... -&gt; StateN -&gt; EndState and to embed them into outer protocols. The outer protocol can transition into BeginState and take control back by replacing EndState with one of its own states by setting a respective context. All states (of type <a class="el" href="classUtil_1_1StateMachineState.html" title="State machine state as used by class StateMachine. A state mainly wraps a state function of the membe...">StateMachineState</a>) have to be registered upon construction of the <a class="el" href="classUtil_1_1StateMachine.html" title="This class models a state machine. It keeps track of the current state and allows to invoke its assoc...">StateMachine</a> instance.  <a href="classUtil_1_1StateMachine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtil" id="r_namespaceUtil"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html">Util</a></td></tr>
<tr class="memdesc:namespaceUtil"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp's Util namespace contains commonly used functions and templates as well as extensions to Qt and its widgets. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a81f4ac72ff1d4ad593754196eead2565" id="r_a81f4ac72ff1d4ad593754196eead2565"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:a81f4ac72ff1d4ad593754196eead2565"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a81f4ac72ff1d4ad593754196eead2565">Util::return_of_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt; CallableT &gt;::return_type</td></tr>
<tr class="memdesc:a81f4ac72ff1d4ad593754196eead2565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of a member function callable of type <code>CallableT</code>.  <br /></td></tr>
<tr class="separator:a81f4ac72ff1d4ad593754196eead2565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119ab45e422a49c79f58028ff1ed09d5" id="r_a119ab45e422a49c79f58028ff1ed09d5"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:a119ab45e422a49c79f58028ff1ed09d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a119ab45e422a49c79f58028ff1ed09d5">Util::instance_of_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt; CallableT &gt;::instance_type</td></tr>
<tr class="memdesc:a119ab45e422a49c79f58028ff1ed09d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the class type a member function callable of type <code>CallableT</code> is member of.  <br /></td></tr>
<tr class="separator:a119ab45e422a49c79f58028ff1ed09d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9535f26f425537e00abc71ed6a3b7a" id="r_aee9535f26f425537e00abc71ed6a3b7a"><td class="memTemplParams" colspan="2">template&lt;typename CallableT &gt; </td></tr>
<tr class="memitem:aee9535f26f425537e00abc71ed6a3b7a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aee9535f26f425537e00abc71ed6a3b7a">Util::argument_of_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1member__fn__ptr__traits">member_fn_ptr_traits</a>&lt; CallableT &gt;::argument_types</td></tr>
<tr class="memdesc:aee9535f26f425537e00abc71ed6a3b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a tuple of argument types the member function callable of type <code>CallableT</code> expects.  <br /></td></tr>
<tr class="separator:aee9535f26f425537e00abc71ed6a3b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6567c7f10bb5d827f0df893e13698aee" id="r_a6567c7f10bb5d827f0df893e13698aee"><td class="memTemplParams" colspan="2">template&lt;typename TupleT &gt; </td></tr>
<tr class="memitem:a6567c7f10bb5d827f0df893e13698aee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a6567c7f10bb5d827f0df893e13698aee">Util::remove_first_from_tuple_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1remove__first__from__tuple">remove_first_from_tuple</a>&lt; TupleT &gt;::type</td></tr>
<tr class="memdesc:a6567c7f10bb5d827f0df893e13698aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a tuple of types where the first type of the input tuple <code>TupleT</code> is removed.  <br /></td></tr>
<tr class="separator:a6567c7f10bb5d827f0df893e13698aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc4b7656b284a6b140d130326c384f" id="r_a6efc4b7656b284a6b140d130326c384f"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, typename IndexSequence &gt; </td></tr>
<tr class="memitem:a6efc4b7656b284a6b140d130326c384f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a6efc4b7656b284a6b140d130326c384f">Util::OffsetIndexSequence_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence">OffsetIndexSequence</a>&lt; Offset, IndexSequence &gt;::type</td></tr>
<tr class="memdesc:a6efc4b7656b284a6b140d130326c384f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for type contained in <code><a class="el" href="namespaceUtil.html#structUtil_1_1OffsetIndexSequence" title="Holds an alias for a std::index_sequence where all indices are shifted by an offset.">OffsetIndexSequence</a></code>.  <br /></td></tr>
<tr class="separator:a6efc4b7656b284a6b140d130326c384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0533638c16abf01f66d3397a281f73" id="r_abe0533638c16abf01f66d3397a281f73"><td class="memTemplParams" colspan="2">template&lt;size_t From, size_t To&gt; </td></tr>
<tr class="memitem:abe0533638c16abf01f66d3397a281f73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#abe0533638c16abf01f66d3397a281f73">Util::RangeIndexSequence_t</a> = typename <a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence">RangeIndexSequence</a>&lt; From, To &gt;::type</td></tr>
<tr class="memdesc:abe0533638c16abf01f66d3397a281f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for type contained in <code><a class="el" href="namespaceUtil.html#structUtil_1_1RangeIndexSequence" title="Holds an alias for a std::index_sequence spanning a certain range.">RangeIndexSequence</a></code>.  <br /></td></tr>
<tr class="separator:abe0533638c16abf01f66d3397a281f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab963e59ba11ee8e43e8e1fe3482fa377" id="r_ab963e59ba11ee8e43e8e1fe3482fa377"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ab963e59ba11ee8e43e8e1fe3482fa377">Util::TrimTrailingZeros</a> (const std::string &amp;Str)</td></tr>
<tr class="memdesc:ab963e59ba11ee8e43e8e1fe3482fa377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes trailing zeros ('\0') from a string.  <br /></td></tr>
<tr class="separator:ab963e59ba11ee8e43e8e1fe3482fa377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595e45049086b60cd1cc7ce79fff369b" id="r_a595e45049086b60cd1cc7ce79fff369b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a595e45049086b60cd1cc7ce79fff369b">Util::CurrentTimeAndDateString</a> ()</td></tr>
<tr class="memdesc:a595e45049086b60cd1cc7ce79fff369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable string describing the current time and date in the current time zone.  <br /></td></tr>
<tr class="separator:a595e45049086b60cd1cc7ce79fff369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd61e68ce03cc8686779f38d354d40" id="r_a25dd61e68ce03cc8686779f38d354d40"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a25dd61e68ce03cc8686779f38d354d40">Util::FilenameFromPath</a> (std::string Path)</td></tr>
<tr class="memdesc:a25dd61e68ce03cc8686779f38d354d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the filename from a path.  <br /></td></tr>
<tr class="separator:a25dd61e68ce03cc8686779f38d354d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f34c2470241f4648bf004d6b342005" id="r_ab6f34c2470241f4648bf004d6b342005"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ab6f34c2470241f4648bf004d6b342005">Util::RemoveExtFromPath</a> (std::string Path)</td></tr>
<tr class="memdesc:ab6f34c2470241f4648bf004d6b342005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the filename's extension from a path.  <br /></td></tr>
<tr class="separator:ab6f34c2470241f4648bf004d6b342005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8491d385f4f8671067e17da06244a9" id="r_a9e8491d385f4f8671067e17da06244a9"><td class="memItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a9e8491d385f4f8671067e17da06244a9">Util::operator&lt;=&gt;</a> (const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;lhs, const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9e8491d385f4f8671067e17da06244a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two program version types with each other.  <br /></td></tr>
<tr class="separator:a9e8491d385f4f8671067e17da06244a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b9b93456301284ca7d695c51a4001a" id="r_a68b9b93456301284ca7d695c51a4001a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a68b9b93456301284ca7d695c51a4001a">Util::VersionFromString</a> (std::string_view Str)</td></tr>
<tr class="memdesc:a68b9b93456301284ca7d695c51a4001a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a program version from a string.  <br /></td></tr>
<tr class="separator:a68b9b93456301284ca7d695c51a4001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3da43074568850d2691bfa052f1e445" id="r_ab3da43074568850d2691bfa052f1e445"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ab3da43074568850d2691bfa052f1e445">Util::ToStr</a> (const <a class="el" href="namespaceUtil.html#structUtil_1_1VersionType">VersionType</a> &amp;Version)</td></tr>
<tr class="memdesc:ab3da43074568850d2691bfa052f1e445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a program version to a string in the form specified by <code><a class="el" href="namespaceUtil.html#structUtil_1_1VersionType" title="Data type describing DynExp&#39;s program version in the form Major.Minor.Patch.">VersionType</a></code>.  <br /></td></tr>
<tr class="separator:ab3da43074568850d2691bfa052f1e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab692b76c2133b68d49b7da20510483" id="r_a7ab692b76c2133b68d49b7da20510483"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7ab692b76c2133b68d49b7da20510483"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; Ts... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a7ab692b76c2133b68d49b7da20510483">Util::ParseCSV</a> (const std::string &amp;CSVData, const char Delimiter=';', const size_t SkipLines=0)</td></tr>
<tr class="memdesc:a7ab692b76c2133b68d49b7da20510483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string containing comma-separated values (csv) and inserts each row as one tuple containing column data into a vector of tuples.  <br /></td></tr>
<tr class="separator:a7ab692b76c2133b68d49b7da20510483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3214377992588c6e7eabe298496544af" id="r_a3214377992588c6e7eabe298496544af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a3214377992588c6e7eabe298496544af">Util::ExceptionToStr</a> (const std::exception_ptr ExceptionPtr)</td></tr>
<tr class="memdesc:a3214377992588c6e7eabe298496544af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the what() information of an exception derived from std::exception and stored in an exception pointer.  <br /></td></tr>
<tr class="separator:a3214377992588c6e7eabe298496544af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c0b4a3ef36519bbcd9fe76cf68dde" id="r_aab8c0b4a3ef36519bbcd9fe76cf68dde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aab8c0b4a3ef36519bbcd9fe76cf68dde">Util::ToLower</a> (std::string_view Str)</td></tr>
<tr class="memdesc:aab8c0b4a3ef36519bbcd9fe76cf68dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a string into lower case.  <br /></td></tr>
<tr class="separator:aab8c0b4a3ef36519bbcd9fe76cf68dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bbe85073186161abeffadaa847827a" id="r_ae8bbe85073186161abeffadaa847827a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ae8bbe85073186161abeffadaa847827a">Util::FFT</a> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;Data, bool InverseTransform=false)</td></tr>
<tr class="memdesc:ae8bbe85073186161abeffadaa847827a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Fast Fourier Transform (FFT) a vector of complex values.  <br /></td></tr>
<tr class="separator:ae8bbe85073186161abeffadaa847827a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702d46b185233ad1fa56ee7033eabd41" id="r_a702d46b185233ad1fa56ee7033eabd41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1EventLogger.html">EventLogger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a702d46b185233ad1fa56ee7033eabd41">Util::EventLog</a> ()</td></tr>
<tr class="memdesc:a702d46b185233ad1fa56ee7033eabd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function holds a static <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance and returns a reference to it. DynExp uses only one <a class="el" href="classUtil_1_1EventLogger.html" title="Logs events like errors and writes them immediately to a HTML file in a human-readable format....">EventLogger</a> instance to log events from any thread. A local static object instead of a global object is employed to avoid initialization order problems.  <br /></td></tr>
<tr class="separator:a702d46b185233ad1fa56ee7033eabd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a132b3de3103b01ab172ee946b4ad0c96" id="r_a132b3de3103b01ab172ee946b4ad0c96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... ListTs&gt; </td></tr>
<tr class="memitem:a132b3de3103b01ab172ee946b4ad0c96"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a132b3de3103b01ab172ee946b4ad0c96">Util::is_contained_in_v</a> = <a class="el" href="structUtil_1_1is__contained__in.html">is_contained_in</a>&lt;T, ListTs...&gt;::value</td></tr>
<tr class="memdesc:a132b3de3103b01ab172ee946b4ad0c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type of <code><a class="el" href="structUtil_1_1is__contained__in.html" title="Checks whether a type T is contained in a template parameter pack of types ListTs.">is_contained_in</a></code>.  <br /></td></tr>
<tr class="separator:a132b3de3103b01ab172ee946b4ad0c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Conversion functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions can be used to convert between different number and string types. </p>
</td></tr>
<tr class="memitem:aac7f18dbdcac4a7036045cc4f93a283c" id="r_aac7f18dbdcac4a7036045cc4f93a283c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aac7f18dbdcac4a7036045cc4f93a283c">Util::seconds</a> = std::chrono::duration&lt; double &gt;</td></tr>
<tr class="memdesc:aac7f18dbdcac4a7036045cc4f93a283c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::chrono by a duration data type for seconds capable of storing fractions of seconds.  <br /></td></tr>
<tr class="separator:aac7f18dbdcac4a7036045cc4f93a283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99231f65c9cf8ce2d11f5768579cec5f" id="r_a99231f65c9cf8ce2d11f5768579cec5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a99231f65c9cf8ce2d11f5768579cec5f">Util::picoseconds</a> = std::chrono::duration&lt; double, std::pico &gt;</td></tr>
<tr class="memdesc:a99231f65c9cf8ce2d11f5768579cec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::chrono by a duration data type for picoseconds.  <br /></td></tr>
<tr class="separator:a99231f65c9cf8ce2d11f5768579cec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebbec01449b4b833a5c01b9e96b6ba8" id="r_adebbec01449b4b833a5c01b9e96b6ba8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adebbec01449b4b833a5c01b9e96b6ba8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#adebbec01449b4b833a5c01b9e96b6ba8">Util::operator&lt;&lt;</a> (std::ostream &amp;stream, const std::chrono::time_point&lt; T &gt; &amp;TimePoint)</td></tr>
<tr class="memdesc:adebbec01449b4b833a5c01b9e96b6ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a time point to a human-readable string describing the time in the current time zone and writes the string to a stream.  <br /></td></tr>
<tr class="separator:adebbec01449b4b833a5c01b9e96b6ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369758c59fefaaba87b25ba4c3d3d6c9" id="r_a369758c59fefaaba87b25ba4c3d3d6c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a369758c59fefaaba87b25ba4c3d3d6c9">Util::StrToT</a> (const std::string &amp;String)</td></tr>
<tr class="memdesc:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::string to a value of type <code>T</code> using operator&lt;&lt; of std::stringstream.  <br /></td></tr>
<tr class="separator:a369758c59fefaaba87b25ba4c3d3d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119393dd8b76c86ab5ec5993f2b2d568" id="r_a119393dd8b76c86ab5ec5993f2b2d568"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a119393dd8b76c86ab5ec5993f2b2d568"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a119393dd8b76c86ab5ec5993f2b2d568">Util::ToStr</a> (const T &amp;Value, int Precision=-1)</td></tr>
<tr class="memdesc:a119393dd8b76c86ab5ec5993f2b2d568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (numeric) value of type <code>T</code> to a std::string using operator&lt;&lt; of std::stringstream.  <br /></td></tr>
<tr class="separator:a119393dd8b76c86ab5ec5993f2b2d568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d745d985db64b4802ddb1676ebb7e" id="r_a716d745d985db64b4802ddb1676ebb7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716d745d985db64b4802ddb1676ebb7e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a716d745d985db64b4802ddb1676ebb7e">Util::ToStr</a> (const std::chrono::time_point&lt; T &gt; &amp;TimePoint)</td></tr>
<tr class="memdesc:a716d745d985db64b4802ddb1676ebb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a time point to a human-readable string describing the time in the current time zone.  <br /></td></tr>
<tr class="separator:a716d745d985db64b4802ddb1676ebb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f025c80e3fc21a12332d3cce451f0" id="r_a678f025c80e3fc21a12332d3cce451f0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a678f025c80e3fc21a12332d3cce451f0">Util::ToStr</a> (const char Value)</td></tr>
<tr class="memdesc:a678f025c80e3fc21a12332d3cce451f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>Value</code> to a std::string using operator&lt;&lt; of std::stringstream.  <br /></td></tr>
<tr class="separator:a678f025c80e3fc21a12332d3cce451f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f30c5ceb81ed16e4b2284ba799fea4" id="r_a98f30c5ceb81ed16e4b2284ba799fea4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a98f30c5ceb81ed16e4b2284ba799fea4">Util::ToStr</a> (const uint8_t Value)</td></tr>
<tr class="memdesc:a98f30c5ceb81ed16e4b2284ba799fea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>Value</code> to a std::string using operator&lt;&lt; of std::stringstream.    <br /></td></tr>
<tr class="separator:a98f30c5ceb81ed16e4b2284ba799fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5622dfde1ba9fbbc1706dafd4c515" id="r_a16a5622dfde1ba9fbbc1706dafd4c515"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a16a5622dfde1ba9fbbc1706dafd4c515">Util::ToStr</a> (const QString &amp;Str)</td></tr>
<tr class="memdesc:a16a5622dfde1ba9fbbc1706dafd4c515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Qt QString <code>Str</code> to a std::string.  <br /></td></tr>
<tr class="separator:a16a5622dfde1ba9fbbc1706dafd4c515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ced77b741ebc83b2a34a3d6950da5f" id="r_ac2ced77b741ebc83b2a34a3d6950da5f"><td class="memTemplParams" colspan="2">template&lt;typename ToT , typename FromT , std::enable_if_t&lt; std::is_integral_v&lt; ToT &gt; &amp;&amp;std::is_integral_v&lt; FromT &gt; &amp;&amp;std::is_same_v&lt; std::remove_cv_t&lt; ToT &gt;, std::remove_cv_t&lt; FromT &gt; &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="memTemplItemLeft" align="right" valign="top">ToT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ac2ced77b741ebc83b2a34a3d6950da5f">Util::NumToT</a> (const FromT Value)</td></tr>
<tr class="memdesc:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of a numeric type to a value of another numeric type checking the conversion for its bounds.  <br /></td></tr>
<tr class="separator:ac2ced77b741ebc83b2a34a3d6950da5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22b7f50701b786e792e23fe19776dce" id="r_ad22b7f50701b786e792e23fe19776dce"><td class="memTemplParams" colspan="2">template&lt;typename ToT , std::enable_if_t&lt; std::is_integral_v&lt; ToT &gt; &amp;&amp;!std::is_same_v&lt; std::remove_cv_t&lt; ToT &gt;, double &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad22b7f50701b786e792e23fe19776dce"><td class="memTemplItemLeft" align="right" valign="top">ToT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#ad22b7f50701b786e792e23fe19776dce">Util::NumToT</a> (const double Value)</td></tr>
<tr class="memdesc:ad22b7f50701b786e792e23fe19776dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of a numeric type to a value of another numeric type checking the conversion for its bounds.    <br /></td></tr>
<tr class="separator:ad22b7f50701b786e792e23fe19776dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82275ae53b547876518e83df7d911b20" id="r_a82275ae53b547876518e83df7d911b20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82275ae53b547876518e83df7d911b20"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a82275ae53b547876518e83df7d911b20">Util::ToUnitStr</a> ()</td></tr>
<tr class="memdesc:a82275ae53b547876518e83df7d911b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".  <br /></td></tr>
<tr class="separator:a82275ae53b547876518e83df7d911b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291cad87815f03694922382ba402222" id="r_a1291cad87815f03694922382ba402222"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1291cad87815f03694922382ba402222"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a1291cad87815f03694922382ba402222">Util::ToUnitStr&lt; std::chrono::seconds &gt;</a> ()</td></tr>
<tr class="memdesc:a1291cad87815f03694922382ba402222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".    <br /></td></tr>
<tr class="separator:a1291cad87815f03694922382ba402222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7c26e0facbdf4807120a4b504b80d" id="r_a9ff7c26e0facbdf4807120a4b504b80d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9ff7c26e0facbdf4807120a4b504b80d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a9ff7c26e0facbdf4807120a4b504b80d">Util::ToUnitStr&lt; std::chrono::milliseconds &gt;</a> ()</td></tr>
<tr class="memdesc:a9ff7c26e0facbdf4807120a4b504b80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".    <br /></td></tr>
<tr class="separator:a9ff7c26e0facbdf4807120a4b504b80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e914d8da02ba7dd5f5dbfc55315e6" id="r_af59e914d8da02ba7dd5f5dbfc55315e6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#af59e914d8da02ba7dd5f5dbfc55315e6">Util::ToUnitStr&lt; std::chrono::microseconds &gt;</a> ()</td></tr>
<tr class="memdesc:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".    <br /></td></tr>
<tr class="separator:af59e914d8da02ba7dd5f5dbfc55315e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa537adcf11f5849c1466e2e864352a0e" id="r_aa537adcf11f5849c1466e2e864352a0e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa537adcf11f5849c1466e2e864352a0e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aa537adcf11f5849c1466e2e864352a0e">Util::ToUnitStr&lt; std::chrono::nanoseconds &gt;</a> ()</td></tr>
<tr class="memdesc:aa537adcf11f5849c1466e2e864352a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".    <br /></td></tr>
<tr class="separator:aa537adcf11f5849c1466e2e864352a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe993b8fa1ecc1599afeee1dc7d0f00" id="r_aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#aefe993b8fa1ecc1599afeee1dc7d0f00">Util::ToUnitStr&lt; seconds &gt;</a> ()</td></tr>
<tr class="memdesc:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".    <br /></td></tr>
<tr class="separator:aefe993b8fa1ecc1599afeee1dc7d0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cde03413439d0e856d6b4d5e2f750e7" id="r_a4cde03413439d0e856d6b4d5e2f750e7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4cde03413439d0e856d6b4d5e2f750e7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtil.html#a4cde03413439d0e856d6b4d5e2f750e7">Util::ToUnitStr&lt; picoseconds &gt;</a> ()</td></tr>
<tr class="memdesc:a4cde03413439d0e856d6b4d5e2f750e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the physical unit associated with type <code>T</code>. For example, if <code>T</code> is std::chrono::milliseconds, the function returns the string "ms".    <br /></td></tr>
<tr class="separator:a4cde03413439d0e856d6b4d5e2f750e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides general utilities within DynExp's Util namespace. </p>

<p class="definition">Definition in file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01_4">&#9670;&#160;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const &gt;</div><p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.   </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00318">318</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a359414f7f25f418dbe2b32cfd996b98a" name="a359414f7f25f418dbe2b32cfd996b98a"></a>typedef tuple&lt; ArgumentTs... &gt;</td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa0c3334749702c89ddb6eb64ffdffad4" name="aa0c3334749702c89ddb6eb64ffdffad4"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae7be2e35117c9da11121a635279c76f1" name="ae7be2e35117c9da11121a635279c76f1"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01noexcept_01_4">&#9670;&#160;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) noexcept &gt;</div><p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.   </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00329">329</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abd5f067575b81ee90003fe0dc52e279e" name="abd5f067575b81ee90003fe0dc52e279e"></a>typedef tuple&lt; ArgumentTs... &gt;</td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8551dd7ff787aada7f593f6462aec9b4" name="a8551dd7ff787aada7f593f6462aec9b4"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a252d72b4bf9c71214ec38849242444cd" name="a252d72b4bf9c71214ec38849242444cd"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_01const_01noexcept_01_4">&#9670;&#160;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...) const noexcept &gt;</div><p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.   </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00340">340</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a57d1dbd6e1af56558b7f2bdb13d5e1a0" name="a57d1dbd6e1af56558b7f2bdb13d5e1a0"></a>typedef tuple&lt; ArgumentTs... &gt;</td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ad39776ff6486804499a93776ed9fd861" name="ad39776ff6486804499a93776ed9fd861"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a316ecfe7f2048362863abeed3386c045" name="a316ecfe7f2048362863abeed3386c045"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4" id="structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1member__fn__ptr__traits_3_01ReturnT_07ObjectT_1_1_5_08_07ArgumentTs_8_8_8_08_4">&#9670;&#160;</a></span>Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ReturnT, typename ObjectT, typename... ArgumentTs&gt;<br />
struct Util::member_fn_ptr_traits&lt; ReturnT(ObjectT::*)(ArgumentTs...)&gt;</div><p>Extracts the return value type, the class type the callable is member of, and the argument types of a callable type <code>CallableT</code> which is a member function of some class. The extracted types are stored using type aliases <code>return_type</code> and <code>instance_type</code> and an alias of a tuple of types <code>argument_types</code>.   </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00351">351</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a797b47ca0beb7a2fb8e455deed6b4d91" name="a797b47ca0beb7a2fb8e455deed6b4d91"></a>typedef tuple&lt; ArgumentTs... &gt;</td>
<td class="fieldname">
argument_types</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a00cd3fe658c233de4019c0e72d9ff755" name="a00cd3fe658c233de4019c0e72d9ff755"></a>typedef ObjectT</td>
<td class="fieldname">
instance_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a22312ae643f35e45189704ed2a092619" name="a22312ae643f35e45189704ed2a092619"></a>typedef ReturnT</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4" id="structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1remove__first__from__tuple_3_01std_1_1tuple_3_01FirstElementT_00_01ElementTs_8_8_8_01_4_01_4">&#9670;&#160;</a></span>Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename FirstElementT, typename... ElementTs&gt;<br />
struct Util::remove_first_from_tuple&lt; std::tuple&lt; FirstElementT, ElementTs... &gt; &gt;</div><p>Removes first type from a tuple of types <code>TupleT</code>.   </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00386">386</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a38acd6f45f6ede16e2091a3a58e12ff3" name="a38acd6f45f6ede16e2091a3a58e12ff3"></a>typedef tuple&lt; ElementTs... &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4" id="structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1OffsetIndexSequence_3_01Offset_00_01std_1_1index__sequence_3_01Indices_8_8_8_01_4_01_4">&#9670;&#160;</a></span>Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t Offset, size_t... Indices&gt;<br />
struct Util::OffsetIndexSequence&lt; Offset, std::index_sequence&lt; Indices... &gt; &gt;</div><p>Holds an alias for a std::index_sequence where all indices are shifted by an offset.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexSequence</td><td>Indices passes as template arguments to std::index_sequence </td></tr>
    <tr><td class="paramname">Offset</td><td>Offset added to all indices   </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00408">408</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a2264e7d262e0a58e4788c91500ad10a3" name="a2264e7d262e0a58e4788c91500ad10a3"></a>typedef index_sequence&lt; Indices+Offset... &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
Alias for offset index sequence. </td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1RangeIndexSequence" id="structUtil_1_1RangeIndexSequence"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1RangeIndexSequence">&#9670;&#160;</a></span>Util::RangeIndexSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::RangeIndexSequence</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t From, size_t To&gt;<br />
struct Util::RangeIndexSequence&lt; From, To &gt;</div><p>Holds an alias for a std::index_sequence spanning a certain range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">From</td><td>Start value the index sequency begins with </td></tr>
    <tr><td class="paramname">To</td><td>Last value contained in the index sequence </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00428">428</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="af945ff47b624ef31faa420f49a255a95" name="af945ff47b624ef31faa420f49a255a95"></a>typedef <a class="el" href="namespaceUtil.html#a6efc4b7656b284a6b140d130326c384f">OffsetIndexSequence_t</a>&lt; From, make_index_sequence&lt; To - From &gt; &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structUtil_1_1VersionType" id="structUtil_1_1VersionType"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structUtil_1_1VersionType">&#9670;&#160;</a></span>Util::VersionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Util::VersionType</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data type describing DynExp's program version in the form Major.Minor.Patch. </p>

<p class="definition">Definition at line <a class="el" href="Util_8h_source.html#l00858">858</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a6ad097a2ead91db7a7321452d34b703d" name="a6ad097a2ead91db7a7321452d34b703d"></a>unsigned int</td>
<td class="fieldname">
Major {}</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a84f1462fdbcf415382d3d3fc36fee5ca" name="a84f1462fdbcf415382d3d3fc36fee5ca"></a>unsigned int</td>
<td class="fieldname">
Minor {}</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="add57d9a4e11595bc40658b53acfbee5a" name="add57d9a4e11595bc40658b53acfbee5a"></a>unsigned int</td>
<td class="fieldname">
Patch {}</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_98d5be3c788e0a480c3b3129797a803d.html">DynExpManager</a></li><li class="navelem"><a class="el" href="Util_8h.html">Util.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
