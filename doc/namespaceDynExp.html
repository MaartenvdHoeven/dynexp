<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynExp: DynExp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="DynExp.ico"/></td>
  <td id="projectalign">
   <div id="projectname">DynExp
   </div>
   <div id="projectbrief">Highly flexible laboratory automation for dynamically changing experiments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceDynExp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">DynExp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>DynExp's main namespace contains the implementation of DynExp including classes to manage resources (DynExp objects like hardware adapters, instruments, and modules) as well as their dependencies and parameters.  
<a href="namespaceDynExp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ArriveAtLatchTask.html">ArriveAtLatchTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task which arrives at a <code>std::latch</code> when it is executed. This is useful to synchronize multiple instruments and make their execution block until a set of instruments has arrived at the latch. Refer to <a class="el" href="classDynExp_1_1InstrumentBase.html#a78bde85aa6b39370a739d38394e52f38" title="Enqueues a task which arrives at a latch when executed (instance of class ArriveAtLatchTask).">InstrumentBase::EnqueueArriveAtLatchTask()</a> and to <code><a class="el" href="namespaceDynExp.html#a502c1fd84645138b14d654a4c6336689" title="Blocks until every instrument passed to the function as a reference parameter has arrived at a synchr...">WaitForInstruments()</a></code>.  <a href="classDynExp_1_1ArriveAtLatchTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1CommonResourceManagerBase.html">CommonResourceManagerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for all derived <code><a class="el" href="classDynExp_1_1ResourceManagerBase.html" title="Typed resource manager base class deriving from class CommonResourceManagerBase.">ResourceManagerBase</a></code> classes. Logical const-ness: Only const functions can be called from objects possessing a const handle to the <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a></code> instance. To protect the resource manager, some functions which should be non-const by that argument (<a class="el" href="classDynExp_1_1ResourceManagerBase.html#aefe8374b841fd1c98d01b20bb1715afe" title="Starts all resources owned by the resource manager. For HardwareAdapterBase instances,...">ResourceManagerBase::Startup()</a>, <a class="el" href="classDynExp_1_1ResourceManagerBase.html#a9997916ad7c475a7823a1e6bb27e958a" title="Calls ShutdownChild() to terminate and clean up all resources stored in this resource manager.">ResourceManagerBase::Shutdown()</a>, <a class="el" href="classDynExp_1_1ResourceManagerBase.html#a335e644d5ad703609b965eeaec8c3947" title="Calls Object::Reset() on all resources stored in this resource manager which are in an error state (d...">ResourceManagerBase::ResetFailedResources()</a>) are still const. These functions indirectly call <a class="el" href="classDynExp_1_1Object.html#af6fde3f79ccf7e596889176af39ab6b2" title="Asserts that the call to this function is performed from the thread which constructed this Object ins...">Object::EnsureCallFromOwningThread()</a> to ensure that they are only called by the main user interface thread (from the <code><a class="el" href="classDynExpManager.html" title="Implements DynExp&#39;s main window as a Qt-based user interface (UI).">DynExpManager</a></code> instance through its <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a></code> instance). Also refer to <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a></code>.  <a href="classDynExp_1_1CommonResourceManagerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ConfiguratorBase.html">ConfiguratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configurator classes have the task to generate parameter objects (refer to <a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">DynExp::ParamsBase</a>) of the corresponding type for DynExp objects <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>. For each class derived from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, there must be a respective configurator derived from <a class="el" href="classDynExp_1_1ConfiguratorBase.html" title="The configurator classes have the task to generate parameter objects (refer to DynExp::ParamsBase) of...">ConfiguratorBase</a>.  <a href="classDynExp_1_1ConfiguratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1DefaultEvent.html">DefaultEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an event which consists of a receiver's member function and a set of arguments to call this function with. The first argument is expected to be of type <code>ModuleInstance*</code>. This argument is not included in <code>ArgTupleType</code>).  <a href="classDynExp_1_1DefaultEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDynExp_1_1DefaultLocaleSeparator.html">DefaultLocaleSeparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default number separators used within DynExp.  <a href="structDynExp_1_1DefaultLocaleSeparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1DefaultTask.html">DefaultTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default task which does not do anything. Though, calling it ensures that <a class="el" href="classDynExp_1_1TaskBase.html#acec8e4a2b180be9dbb6aa8c425c77e9c" title="This callback function is called after the task has finished (either successfully or not) with a refe...">TaskBase::CallbackFunc</a> gets called. This is required to avoid <a class="el" href="classDynExp_1_1InstrumentBase.html#ab98e876c26afcccb0d8f3555f7b7b9b5" title="Calls a (derived) instrument&#39;s function which inserts a task into the instrument&#39;s task queue synchro...">InstrumentBase::AsSyncTask()</a> getting stuck in an infinite loop. All functions overridden from meta instruments, which are expected to enqueue a task, must at least enqueue a <code><a class="el" href="classDynExp_1_1DefaultTask.html" title="Default task which does not do anything. Though, calling it ensures that TaskBase::CallbackFunc gets ...">DefaultTask</a></code> (by calling <code>MakeAndEnqueueTask&lt; DynExp::DefaultTask &gt;(CallbackFunc)</code>;)  <a href="classDynExp_1_1DefaultTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1DynExpCore.html">DynExpCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp's core class acts as the interface between the user interface and DynExp's internal data like all <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a> instances and their threads. There should only be one instance of this class. It owns all DynExp resources through the respective <code><a class="el" href="classDynExp_1_1ResourceManagerBase.html" title="Typed resource manager base class deriving from class CommonResourceManagerBase.">ResourceManagerBase</a></code> instances. Logical const-ness: Non-const functions (like functions to run/stop/reset/save/... the project) cannot be called from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a> instances possessing a const handle to the <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a></code> instance. Instead, these functions should be called through the user interface (from the <code><a class="el" href="classDynExpManager.html" title="Implements DynExp&#39;s main window as a Qt-based user interface (UI).">DynExpManager</a></code> instance).  <a href="classDynExp_1_1DynExpCore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1EventBase.html">EventBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for all events to store them in a FIFO queue to be invoked later.  <a href="classDynExp_1_1EventBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1EventListenersBase.html">EventListenersBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for all managers of event listeners of type <code><a class="el" href="classDynExp_1_1TypedEventListeners.html" title="Typed managers of event listeners class whose instances are owned by classes derived from InterModule...">TypedEventListeners</a></code>. <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instances are considered event listeners.  <a href="classDynExp_1_1EventListenersBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ExceptionContainer.html">ExceptionContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper holding a pointer to an exception and providing functionality for accessing it. Used to transfer exceptions between an instrument's task and the <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> module enqueuing the task. Refer to <a class="el" href="classDynExp_1_1TaskBase.html#a198aea8bb3935b1ac6556b23cc17d147" title="Type of a callback function which is invoked when a task has finished, failed or has been aborted....">TaskBase::CallbackType</a>.  <a href="classDynExp_1_1ExceptionContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ExitTaskBase.html">ExitTaskBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task for deinitializing an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by a deinitialization task class derived from <code><a class="el" href="classDynExp_1_1ExitTaskBase.html" title="Defines a task for deinitializing an instrument within an instrument inheritance hierarchy....">ExitTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1ExitTaskBase.html#ade32a093ce314c193622d5b36c68a826" title="Deinitializes the respective instrument within the instrument inheritance hierarchy....">ExitTaskBase::ExitFuncImpl()</a> of the derived instrument's deinitialization task class.  <a href="classDynExp_1_1ExitTaskBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connections to physical hardware.  <a href="classDynExp_1_1HardwareAdapterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterConfiguratorBase.html">HardwareAdapterConfiguratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code>.  <a href="classDynExp_1_1HardwareAdapterConfiguratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterLibrary.html">HardwareAdapterLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a hardware adapter library to generate instances of classes derived from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">DynExp::HardwareAdapterBase</a>.  <a href="classDynExp_1_1HardwareAdapterLibrary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterManager.html">HardwareAdapterManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDynExp_1_1Resource.html" title="Defines a DynExp resource, which mainly owns a DynExp::Object instance wrapping a pointer to it.">Resource</a> manager for <code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code> resources deriving from a specialized <code><a class="el" href="classDynExp_1_1ResourceManagerBase.html" title="Typed resource manager base class deriving from class CommonResourceManagerBase.">ResourceManagerBase</a></code> class.  <a href="classDynExp_1_1HardwareAdapterManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterParamsBase.html">HardwareAdapterParamsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code>.  <a href="classDynExp_1_1HardwareAdapterParamsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterSerialPort.html">HardwareAdapterSerialPort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a hardware adapter to communicate with text-based commands over COM ports.  <a href="classDynExp_1_1HardwareAdapterSerialPort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterSerialPortConfigurator.html">HardwareAdapterSerialPortConfigurator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1HardwareAdapterSerialPort.html" title="Implements a hardware adapter to communicate with text-based commands over COM ports.">HardwareAdapterSerialPort</a></code>.  <a href="classDynExp_1_1HardwareAdapterSerialPortConfigurator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterSerialPortParams.html">HardwareAdapterSerialPortParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1HardwareAdapterSerialPort.html" title="Implements a hardware adapter to communicate with text-based commands over COM ports.">HardwareAdapterSerialPort</a></code>.  <a href="classDynExp_1_1HardwareAdapterSerialPortParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterSerialPortWorker.html">HardwareAdapterSerialPortWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qt worker for serial/COM port communication in a separate thread.  <a href="classDynExp_1_1HardwareAdapterSerialPortWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterTcpSocket.html">HardwareAdapterTcpSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a hardware adapter to communicate with text-based commands over TCP sockets.  <a href="classDynExp_1_1HardwareAdapterTcpSocket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterTcpSocketConfigurator.html">HardwareAdapterTcpSocketConfigurator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1HardwareAdapterTcpSocket.html" title="Implements a hardware adapter to communicate with text-based commands over TCP sockets.">HardwareAdapterTcpSocket</a></code>.  <a href="classDynExp_1_1HardwareAdapterTcpSocketConfigurator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterTcpSocketParams.html">HardwareAdapterTcpSocketParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1HardwareAdapterTcpSocket.html" title="Implements a hardware adapter to communicate with text-based commands over TCP sockets.">HardwareAdapterTcpSocket</a></code>.  <a href="classDynExp_1_1HardwareAdapterTcpSocketParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterTcpSocketWorker.html">HardwareAdapterTcpSocketWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qt worker for network communication in a separate thread.  <a href="classDynExp_1_1HardwareAdapterTcpSocketWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InitTaskBase.html">InitTaskBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task for initializing an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by an initialization task class derived from <code><a class="el" href="classDynExp_1_1InitTaskBase.html" title="Defines a task for initializing an instrument within an instrument inheritance hierarchy....">InitTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1InitTaskBase.html#a1b2737990a3c0ecc97b9a8a2bef6cf65" title="Initializes the respective instrument within the instrument inheritance hierarchy....">InitTaskBase::InitFuncImpl()</a> of the derived instrument's initialization task class.  <a href="classDynExp_1_1InitTaskBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devices (instruments). While meta instruments are used by modules (<code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>) as an abstraction layer, physical instruments derive from meta instruments and make usually use of one hardware adapter (<code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code>) to communicate with the underlying hardware.  <a href="classDynExp_1_1InstrumentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentConfiguratorBase.html">InstrumentConfiguratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>.  <a href="classDynExp_1_1InstrumentConfiguratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentDataBase.html">InstrumentDataBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to contain data which is synchronized in between different threads. This is needed since the instrument thread, the threads of different modules, as well as the main thread might access the instrument at the same time. Every class (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by a instrument data class derived from <code><a class="el" href="classDynExp_1_1InstrumentDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">InstrumentDataBase</a></code>. <code><a class="el" href="classDynExp_1_1InstrumentDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">InstrumentDataBase</a></code> and derived classes contain data shared by the respective instrument, module and main threads. Data only used by the instrument itself should be private members of the instrument class.  <a href="classDynExp_1_1InstrumentDataBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentInstance.html">InstrumentInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines data for a thread belonging to a <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> instance. Refer to <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>.  <a href="classDynExp_1_1InstrumentInstance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentLibrary.html">InstrumentLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an instrument library to generate instances of classes derived from <a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">DynExp::InstrumentBase</a>.  <a href="classDynExp_1_1InstrumentLibrary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentManager.html">InstrumentManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDynExp_1_1Resource.html" title="Defines a DynExp resource, which mainly owns a DynExp::Object instance wrapping a pointer to it.">Resource</a> manager for <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> resources deriving from a specialized <code><a class="el" href="classDynExp_1_1ResourceManagerBase.html" title="Typed resource manager base class deriving from class CommonResourceManagerBase.">ResourceManagerBase</a></code> class.  <a href="classDynExp_1_1InstrumentManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InstrumentParamsBase.html">InstrumentParamsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>.  <a href="classDynExp_1_1InstrumentParamsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InterModuleEvent.html">InterModuleEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed base class for inter-module events to realize CRTP.  <a href="classDynExp_1_1InterModuleEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1InterModuleEventBase.html">InterModuleEventBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for all inter-module events.  <a href="classDynExp_1_1InterModuleEventBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classDynExp_1_1LibraryBase" id="r_classDynExp_1_1LibraryBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#classDynExp_1_1LibraryBase">LibraryBase</a></td></tr>
<tr class="memdesc:classDynExp_1_1LibraryBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for a library containing library entries (<a class="el" href="structDynExp_1_1LibraryEntry.html" title="Represents an entry in the library.">DynExp::LibraryEntry</a>).  <a href="namespaceDynExp.html#classDynExp_1_1LibraryBase">More...</a><br /></td></tr>
<tr class="separator:classDynExp_1_1LibraryBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LibraryBase_3_01ObjectTypeBasePtr_00_01LibraryObjectFactoryParamList_3_01ObjectTy36191797b46eff398a084c538e51bccd.html">LibraryBase&lt; ObjectTypeBasePtr, LibraryObjectFactoryParamList&lt; ObjectTypeBasePtr, ObjFactories... &gt;, LibraryConfigFactoryParamList&lt; ConfFactories... &gt;, LibraryStringParamList&lt; NameFuncs... &gt;, LibraryStringParamList&lt; CategoryFuncs... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the specialized base class for a library containing library entries (<a class="el" href="structDynExp_1_1LibraryEntry.html" title="Represents an entry in the library.">DynExp::LibraryEntry</a>).  <a href="classDynExp_1_1LibraryBase_3_01ObjectTypeBasePtr_00_01LibraryObjectFactoryParamList_3_01ObjectTy36191797b46eff398a084c538e51bccd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classDynExp_1_1LibraryConfigFactoryParamList" id="r_classDynExp_1_1LibraryConfigFactoryParamList"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#classDynExp_1_1LibraryConfigFactoryParamList">LibraryConfigFactoryParamList</a></td></tr>
<tr class="memdesc:classDynExp_1_1LibraryConfigFactoryParamList"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type consisting of function pointer types returning configurators for DynExp objects. Refer to <a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799" title="Alias for a pointer to the configurator base class ConfiguratorBase.">DynExp::ConfiguratorBasePtrType</a>.  <a href="namespaceDynExp.html#classDynExp_1_1LibraryConfigFactoryParamList">More...</a><br /></td></tr>
<tr class="separator:classDynExp_1_1LibraryConfigFactoryParamList"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an entry in the library.  <a href="structDynExp_1_1LibraryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classDynExp_1_1LibraryObjectFactoryParamList" id="r_classDynExp_1_1LibraryObjectFactoryParamList"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#classDynExp_1_1LibraryObjectFactoryParamList">LibraryObjectFactoryParamList</a></td></tr>
<tr class="memdesc:classDynExp_1_1LibraryObjectFactoryParamList"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type consisting of function pointer types instantiating DynExp objects. Refer to <a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a" title="Alias for a factory function pointer type that instantiates library entries to create DynExp objects ...">DynExp::LibraryObjectFactoryPtrType</a>.  <a href="namespaceDynExp.html#classDynExp_1_1LibraryObjectFactoryParamList">More...</a><br /></td></tr>
<tr class="separator:classDynExp_1_1LibraryObjectFactoryParamList"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classDynExp_1_1LibraryStringParamList" id="r_classDynExp_1_1LibraryStringParamList"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#classDynExp_1_1LibraryStringParamList">LibraryStringParamList</a></td></tr>
<tr class="memdesc:classDynExp_1_1LibraryStringParamList"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type consisting of function pointer types returning string literals. Refer to <a class="el" href="namespaceDynExp.html#acb97fc4ed081ca0cbe043aeb07ac5689" title="Pointer to a DynExp object&#39;s static constexpr function returning a string literal....">DynExp::LibraryStringParamPtrType</a>.  <a href="namespaceDynExp.html#classDynExp_1_1LibraryStringParamList">More...</a><br /></td></tr>
<tr class="separator:classDynExp_1_1LibraryStringParamList"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkBase.html">LinkBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class of link parameters (to be saved in project files) describing relations between multiple <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> (e.g. a module making use of an instrument).  <a href="classDynExp_1_1LinkBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html">LinkedObjectWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a shared_ptr to a resource (instance of class <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>) and lets the resource keep track of its usage count by increasing a respective counter of the resource on construction and by decreasing the counter on destruction of the <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance again. Not copyable in order not to mess up the usage counter stored in <a class="el" href="classDynExp_1_1LinkedObjectWrapper.html#aa172ce761a2230a212ffb855b82c4950" title="Target resource which is used by the Object instance LinkedObjectWrapperBase::Owner belongs to.">LinkedObjectWrapper::DestinyResource</a>. Only accessed via a thread's instance of class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code> in that thread. Also refer to <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>.  <a href="classDynExp_1_1LinkedObjectWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkedObjectWrapperBase.html">LinkedObjectWrapperBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic base class to allow storing <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> of any type in a single list.  <a href="classDynExp_1_1LinkedObjectWrapperBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html">LinkedObjectWrapperContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a pointer (<code><a class="el" href="classDynExp_1_1LinkedObjectWrapperPointer.html" title="This class describes a pointer to a LinkedObjectWrapper instance. It is a simple wrapper class which ...">LinkedObjectWrapperPointer</a></code>) to a <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code>. Intances of this class should be owned by classes derived from class <code><a class="el" href="classDynExp_1_1InstrumentDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">InstrumentDataBase</a></code> or class <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code>. These instances provide access to objects referenced by object link parameters. <code><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html" title="This class holds a pointer (LinkedObjectWrapperPointer) to a LinkedObjectWrapper. Intances of this cl...">LinkedObjectWrapperContainer</a></code> does not own the referenced <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code>. The <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> itself is owned by class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>. The pointer hold here is also set and managed by class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>. Also refer to class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>.  <a href="classDynExp_1_1LinkedObjectWrapperContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainerBase.html">LinkedObjectWrapperContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic base class to allow storing <code><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html" title="This class holds a pointer (LinkedObjectWrapperPointer) to a LinkedObjectWrapper. Intances of this cl...">LinkedObjectWrapperContainer</a></code> of any type in a single list.  <a href="classDynExp_1_1LinkedObjectWrapperContainerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainerList.html">LinkedObjectWrapperContainerList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a list of <code><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html" title="This class holds a pointer (LinkedObjectWrapperPointer) to a LinkedObjectWrapper. Intances of this cl...">LinkedObjectWrapperContainer</a></code> instances. The list owns the contained <code><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html" title="This class holds a pointer (LinkedObjectWrapperPointer) to a LinkedObjectWrapper. Intances of this cl...">LinkedObjectWrapperContainer</a></code> instances. Intances of this class should be owned by classes derived from class <code><a class="el" href="classDynExp_1_1InstrumentDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">InstrumentDataBase</a></code> or class <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code>. These instances provide access to objects referenced by object link list parameters (<code>ListParam</code>). The list's entries are exclusively managed by the respective instance of class <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>. <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code> stores references to list entries. Every list manipulation <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code> is not aware of might cause dangling references!  <a href="classDynExp_1_1LinkedObjectWrapperContainerList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1LinkedObjectWrapperPointer.html">LinkedObjectWrapperPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a pointer to a <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance. It is a simple wrapper class which only adds specific behavior like always returning a const pointer to a <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance wrapping a const <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <a href="classDynExp_1_1LinkedObjectWrapperPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structDynExp_1_1ManagerTypeOfObjectType" id="r_structDynExp_1_1ManagerTypeOfObjectType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#structDynExp_1_1ManagerTypeOfObjectType">ManagerTypeOfObjectType</a></td></tr>
<tr class="memdesc:structDynExp_1_1ManagerTypeOfObjectType"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait relating a type <code>ObjectType</code> derived from either class <code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code> or class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> to the resource manager type (derived from <a class="el" href="classDynExp_1_1CommonResourceManagerBase.html" title="Common base class for all derived ResourceManagerBase classes. Logical const-ness: Only const functio...">DynExp::CommonResourceManagerBase</a>) managing instances of the type <code>ObjectType</code>.  <a href="namespaceDynExp.html#structDynExp_1_1ManagerTypeOfObjectType">More...</a><br /></td></tr>
<tr class="separator:structDynExp_1_1ManagerTypeOfObjectType"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for modules. Modules implement programs on their own (e.g. measurement protocols or servers for ethernet communication). They might have a user interface. Modules make use of meta instruments (<code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code>) to implement e.g. measurement routines on a higher level, which renders the modules independent from physical devices from specific manufacturers. Derive from this class to implement modules without a user interface.  <a href="classDynExp_1_1ModuleBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleConfiguratorBase.html">ModuleConfiguratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>.  <a href="classDynExp_1_1ModuleConfiguratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleDataBase.html">ModuleDataBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to contain data which is synchronized in between different threads. This is needed since the module thread as well as the main thread might access the module at the same time. Every class (indirectly) derived from class <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> must be accompanied by a module data class derived from <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code>. <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code> and derived classes contain data shared by the respective module thread and the user interface (main) thread to e.g. visualize data. Data only used by the module thread should be private members of the module class. Data only used by the user interface should be private members of the module's widget class (derived from <code><a class="el" href="classDynExp_1_1QModuleWidget.html" title="Window class for Qt-based user interfaces belonging to DynExp modules. User interface Qt window class...">QModuleWidget</a></code>), respectively.  <a href="classDynExp_1_1ModuleDataBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines data for a thread belonging to a <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> instance. Refer to <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code>.  <a href="classDynExp_1_1ModuleInstance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleLibrary.html">ModuleLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a module library to generate instances of classes derived from <a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">DynExp::ModuleBase</a>.  <a href="classDynExp_1_1ModuleLibrary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleManager.html">ModuleManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDynExp_1_1Resource.html" title="Defines a DynExp resource, which mainly owns a DynExp::Object instance wrapping a pointer to it.">Resource</a> manager for <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> resources deriving from a specialized <code><a class="el" href="classDynExp_1_1ResourceManagerBase.html" title="Typed resource manager base class deriving from class CommonResourceManagerBase.">ResourceManagerBase</a></code> class.  <a href="classDynExp_1_1ModuleManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ModuleParamsBase.html">ModuleParamsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code>.  <a href="classDynExp_1_1ModuleParamsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1NetworkException.html">NetworkException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an exception caused by a hardware operation on an ethernet interface (e.g. reading/writing data to a TCP socket).  <a href="classDynExp_1_1NetworkException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1NetworkParamsExtension.html">NetworkParamsExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles several parameters to describe a network connection. Use in parameter classes.  <a href="classDynExp_1_1NetworkParamsExtension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all DynExp Objects like hardware adapters (<a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">DynExp::HardwareAdapterBase</a>), instruments (<a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">DynExp::InstrumentBase</a>) and modules (<a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">DynExp::ModuleBase</a>). Subclasses should also derive either form <a class="el" href="classUtil_1_1INonCopyable.html" title="Interface to delete copy constructor and copy assignment operator and thus make derived classes non-c...">Util::INonCopyable</a> or <a class="el" href="classUtil_1_1ILockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by providing...">Util::ILockable</a> since <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a> is not intended to be copied. Especially, it must not be moved to another thread (than the one creating it). Logical const-ness: const member functions can be called by other threads, non-const functions are visible only to main thread.  <a href="classDynExp_1_1Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ObjectLink.html">ObjectLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to define object link parameters as <a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">ParamsBase::Param</a>&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define object link list parameters as <a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1ListParam">ParamsBase::ListParam</a>&lt; ObjectLink&lt; ObjectT &gt; &gt;. Such parameters own (one or multiple) <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> instances and assign a resource to each instance. <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> instances hold a <code>std::weak_ptr</code> to the resource and lock this <code>weak_ptr</code> if requested returning a respective <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance. A new resource can be assigned to an <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> instance while <code>LinkedObjectWrapper(s)</code> exist since they hold an independent <code>shared_ptr</code> to the resource they have been created from. <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> does not need to be thread-safe itself. All operations on it are performed through the respective <a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">ParamsBase::Param</a> or <a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1ListParam">ParamsBase::ListParam</a> instance. To operate on those instances, the <code><a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">ParamsBase</a></code> instance owning the respective parameter needs to be locked which renders <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> implicitely thread-safe.  <a href="classDynExp_1_1ObjectLink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ObjectLinkBase.html">ObjectLinkBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for object link parameter types to allow SFINAE in <a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">ParamsBase::Param</a> for <code><a class="el" href="classDynExp_1_1ObjectLink.html" title="Type to define object link parameters as ParamsBase::Param&lt; ObjectLink&lt; ObjectT &gt; &gt; or to define obje...">ObjectLink</a></code> of any type.  <a href="classDynExp_1_1ObjectLinkBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ObjectUserList.html">ObjectUserList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to enable keeping track of instances of class <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> making use of the owner of the respective <a class="el" href="classDynExp_1_1ObjectUserList.html" title="Helper class to enable keeping track of instances of class Object making use of the owner of the resp...">ObjectUserList</a>'s instance. Instances of class <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> can register or deregister multiple times as an user which increments or decrements their respective registration count in <a class="el" href="classDynExp_1_1ObjectUserList.html#a6ac478743c2c6a6aacee323c02826f77" title="Map containing pointers to all users making use of this ObjectUserList instance&#39;s owner as keys and t...">ObjectUserList::UserList</a>.  <a href="classDynExp_1_1ObjectUserList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for object parameter classes. Each class derived from class <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> must be accompanied by a parameter class derived from <code><a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">ParamsBase</a></code>. These parameter classes are intended to contain the object's parameters (sub-classes of <code><a class="el" href="classDynExp_1_1ParamsBase_1_1ParamBase.html" title="Abstract base class for a single object parameter. Parameters derived from this class are automatical...">ParamsBase::ParamBase</a></code>) which are stored in DynExp project files and which can be configured in the respective object instance's settings dialog or programmatically. Parameter classes are synchronized in between different threads (e.g. the main thread and an instrument/module thread).  <a href="classDynExp_1_1ParamsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ProjectParams.html">ProjectParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a parameter class with parameters common to all DynExp projects.  <a href="classDynExp_1_1ProjectParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QModuleBase.html">QModuleBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for modules with a Qt-based user interface. Derive from this class to implement modules with a user interface.  <a href="classDynExp_1_1QModuleBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QModuleConfiguratorBase.html">QModuleConfiguratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1QModuleBase.html" title="Base class for modules with a Qt-based user interface. Derive from this class to implement modules wi...">QModuleBase</a></code>.  <a href="classDynExp_1_1QModuleConfiguratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QModuleDataBase.html">QModuleDataBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data class for <code><a class="el" href="classDynExp_1_1QModuleBase.html" title="Base class for modules with a Qt-based user interface. Derive from this class to implement modules wi...">QModuleBase</a></code>.  <a href="classDynExp_1_1QModuleDataBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QModuleDockWidget.html">QModuleDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a frame for <code><a class="el" href="classDynExp_1_1QModuleWidget.html" title="Window class for Qt-based user interfaces belonging to DynExp modules. User interface Qt window class...">QModuleWidget</a></code> windows, which are undocked from the <code><a class="el" href="classDynExpManager.html" title="Implements DynExp&#39;s main window as a Qt-based user interface (UI).">DynExpManager</a>'s</code> QMdiArea.  <a href="classDynExp_1_1QModuleDockWidget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QModuleParamsBase.html">QModuleParamsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1QModuleBase.html" title="Base class for modules with a Qt-based user interface. Derive from this class to implement modules wi...">QModuleBase</a></code>.  <a href="classDynExp_1_1QModuleParamsBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QModuleWidget.html">QModuleWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Window class for Qt-based user interfaces belonging to DynExp modules. User interface Qt window classes belonging to a module derived from <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> have to derive from this class.  <a href="classDynExp_1_1QModuleWidget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html">QSerialCommunicationHardwareAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> is based on a Qt communication object (wrapped by <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterWorker.html" title="Qt worker which performs actual serial communication hardware operations in a separate thread in orde...">QSerialCommunicationHardwareAdapterWorker</a></code>) which cannot be shared between different threads. Instead, it lives in a <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a>'s</code> worker thread. <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html" title="SerialCommunicationHardwareAdapter is based on a Qt communication object (wrapped by QSerialCommunica...">QSerialCommunicationHardwareAdapter</a></code> just pushes messages to it and allows the <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterWorker.html" title="Qt worker which performs actual serial communication hardware operations in a separate thread in orde...">QSerialCommunicationHardwareAdapterWorker</a></code> instance to communicate its state and data to the corresponding <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html" title="SerialCommunicationHardwareAdapter is based on a Qt communication object (wrapped by QSerialCommunica...">QSerialCommunicationHardwareAdapter</a></code> instance.  <a href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterConfigurator.html">QSerialCommunicationHardwareAdapterConfigurator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html" title="SerialCommunicationHardwareAdapter is based on a Qt communication object (wrapped by QSerialCommunica...">QSerialCommunicationHardwareAdapter</a></code>.  <a href="classDynExp_1_1QSerialCommunicationHardwareAdapterConfigurator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterParams.html">QSerialCommunicationHardwareAdapterParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html" title="SerialCommunicationHardwareAdapter is based on a Qt communication object (wrapped by QSerialCommunica...">QSerialCommunicationHardwareAdapter</a></code>.  <a href="classDynExp_1_1QSerialCommunicationHardwareAdapterParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterWorker.html">QSerialCommunicationHardwareAdapterWorker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qt worker which performs actual serial communication hardware operations in a separate thread in order not to interfer with processor time used to update the user interface. All functions are inherently thead-safe since they are only called by the worker thread the respective instance of this class lives in.  <a href="classDynExp_1_1QSerialCommunicationHardwareAdapterWorker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDynExp_1_1Resource.html">Resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a DynExp resource, which mainly owns a <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a> instance wrapping a pointer to it.  <a href="structDynExp_1_1Resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1ResourceManagerBase.html">ResourceManagerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed resource manager base class deriving from class <code><a class="el" href="classDynExp_1_1CommonResourceManagerBase.html" title="Common base class for all derived ResourceManagerBase classes. Logical const-ness: Only const functio...">CommonResourceManagerBase</a></code>.  <a href="classDynExp_1_1ResourceManagerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableInstance.html">RunnableInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines data for a thread belonging to a <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> instance. This data is only accessed by the <a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a> instance's thread. So, no synchronization mechanism is needed. Furthermore, this class is designed to exist only on the stack. <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code> instances are to be passed as a parameter to the respective thread functions. This ensures that a <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code> instances is deleted when its thread function returns. This class is responsible for locking an object link (list) parameter (<a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1Param">ParamsBase::Param</a>&lt; ObjectLink&lt; ObjectT &gt; &gt; or <a class="el" href="classDynExp_1_1ParamsBase.html#classDynExp_1_1ParamsBase_1_1ListParam">ParamsBase::ListParam</a>&lt; ObjectLink&lt; ObjectT &gt; &gt;) hold by a class derived (indirectly) from class <code><a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">ParamsBase</a></code> and for storing the locked resource in a <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance. In turn, the created <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance is stored in a <code><a class="el" href="classDynExp_1_1LinkedObjectWrapperContainer.html" title="This class holds a pointer (LinkedObjectWrapperPointer) to a LinkedObjectWrapper. Intances of this cl...">LinkedObjectWrapperContainer</a></code> instance hold by a class derived (indirectly) from <code><a class="el" href="classDynExp_1_1InstrumentDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">InstrumentDataBase</a></code> or from <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code>. Furthermore, this class is responsible for unlocking <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instances it created. Unlocking is triggered either on request or on destruction of the <code><a class="el" href="classDynExp_1_1RunnableInstance.html" title="Defines data for a thread belonging to a RunnableObject instance. This data is only accessed by the R...">RunnableInstance</a></code> instance owning the <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instance.  <a href="classDynExp_1_1RunnableInstance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObject.html">RunnableObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> which possesses a thread it runs in. The <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code> can be started and stopped as well as paused and resumed.  <a href="classDynExp_1_1RunnableObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObjectConfigurator.html">RunnableObjectConfigurator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code>.  <a href="classDynExp_1_1RunnableObjectConfigurator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1RunnableObjectParams.html">RunnableObjectParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1RunnableObject.html" title="Defines an Object which possesses a thread it runs in. The RunnableObject can be started and stopped ...">RunnableObject</a></code>.  <a href="classDynExp_1_1RunnableObjectParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationException.html">SerialCommunicationException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an exception caused by a serial communication operation of a hardware adapter.  <a href="classDynExp_1_1SerialCommunicationException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>.  <a href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterConfigurator.html">SerialCommunicationHardwareAdapterConfigurator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurator class for <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code>.  <a href="classDynExp_1_1SerialCommunicationHardwareAdapterConfigurator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html">SerialCommunicationHardwareAdapterParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter class for <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code>.  <a href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialPortException.html">SerialPortException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an exception caused by a hardware operation on a COM port (e.g. reading/writing data to a COM port).  <a href="classDynExp_1_1SerialPortException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1TaskBase.html">TaskBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all tasks being processed by instruments. The class must not contain public virtual functions since <a class="el" href="classDynExp_1_1TaskBase.html#acec8e4a2b180be9dbb6aa8c425c77e9c" title="This callback function is called after the task has finished (either successfully or not) with a refe...">TaskBase::CallbackFunc</a> could call them in <code><a class="el" href="classDynExp_1_1TaskBase.html" title="Base class for all tasks being processed by instruments. The class must not contain public virtual fu...">TaskBase</a>'s</code> destructor.  <a href="classDynExp_1_1TaskBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1TaskResultType.html">TaskResultType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the return type of task functions.  <a href="classDynExp_1_1TaskResultType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1TypedEventListeners.html">TypedEventListeners</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed managers of event listeners class whose instances are owned by classes derived from <code><a class="el" href="classDynExp_1_1InterModuleEvent.html" title="Typed base class for inter-module events to realize CRTP.">InterModuleEvent</a></code>. The class maps modules registering/subscribing to inter-module events to the respective event functions which are invoked when the related event occurs.  <a href="classDynExp_1_1TypedEventListeners.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1UpdateTaskBase.html">UpdateTaskBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a task for updating an instrument within an instrument inheritance hierarchy. Each instrument (indirectly) derived from class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> must be accompanied by an update task class derived from <code><a class="el" href="classDynExp_1_1UpdateTaskBase.html" title="Defines a task for updating an instrument within an instrument inheritance hierarchy....">UpdateTaskBase</a></code>. Even if the task does not do anything, at least it has to call <a class="el" href="classDynExp_1_1UpdateTaskBase.html#af23c4a712115c7b2375257a279c6efdb" title="Updates the respective instrument within the instrument inheritance hierarchy. Call UpdateFuncImpl() ...">UpdateTaskBase::UpdateFuncImpl()</a> of the derived instrument's update task class.  <a href="classDynExp_1_1UpdateTaskBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1WindowStyleParamsExtension.html">WindowStyleParamsExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles several parameters to describe a UI window's style. Use in parameter classes.  <a href="classDynExp_1_1WindowStyleParamsExtension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8b4c34da3bf02951070e7011bc438e38" id="r_a8b4c34da3bf02951070e7011bc438e38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a> = size_t</td></tr>
<tr class="memdesc:a8b4c34da3bf02951070e7011bc438e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID type of objects/items managed by DynExp.  <br /></td></tr>
<tr class="separator:a8b4c34da3bf02951070e7011bc438e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5ae1451b86061935d6fb2be9253dbf" id="r_aff5ae1451b86061935d6fb2be9253dbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#aff5ae1451b86061935d6fb2be9253dbf">HardwareAdapterPtrType</a> = std::shared_ptr&lt; <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a> &gt;</td></tr>
<tr class="memdesc:aff5ae1451b86061935d6fb2be9253dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to store a hardware adapter (<a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">DynExp::HardwareAdapterBase</a>) with.  <br /></td></tr>
<tr class="separator:aff5ae1451b86061935d6fb2be9253dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa73be1acbc98bff987351e6cfdf3c6" id="r_a3aa73be1acbc98bff987351e6cfdf3c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a3aa73be1acbc98bff987351e6cfdf3c6">InstrumentPtrType</a> = std::shared_ptr&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a> &gt;</td></tr>
<tr class="memdesc:a3aa73be1acbc98bff987351e6cfdf3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to store an instrument (<a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">DynExp::InstrumentBase</a>) with.  <br /></td></tr>
<tr class="separator:a3aa73be1acbc98bff987351e6cfdf3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d65e509999f772d18a74946aa7082a" id="r_a61d65e509999f772d18a74946aa7082a"><td class="memTemplParams" colspan="2">template&lt;typename ObjectTypeBasePtr &gt; </td></tr>
<tr class="memitem:a61d65e509999f772d18a74946aa7082a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a">LibraryObjectFactoryPtrType</a> = ObjectTypeBasePtr(*)(const std::thread::id, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a61d65e509999f772d18a74946aa7082a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a factory function pointer type that instantiates library entries to create DynExp objects derived from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>. As arguments, it expects the thread ID of the thread owning the resource and a reference to the resource's parameters to take ownership of. Compatible e.g. to <a class="el" href="namespaceDynExp.html#a4cf294132f114f6832a56c5cc83444cc" title="Factory function to generate a module of a specific type.">DynExp::MakeModule()</a>.  <br /></td></tr>
<tr class="separator:a61d65e509999f772d18a74946aa7082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68b31d1e54e5a1a1aa36ae4738a695f" id="r_ae68b31d1e54e5a1a1aa36ae4738a695f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#ae68b31d1e54e5a1a1aa36ae4738a695f">LibraryConfigFactoryPtrType</a> = <a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a>(*)()</td></tr>
<tr class="memdesc:ae68b31d1e54e5a1a1aa36ae4738a695f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a factory function pointer type that creates a configurator for a specific library entry. Compatible e.g. to <a class="el" href="namespaceDynExp.html#a21da3ccf9adc0ec1cbc385df6cd751f6" title="Factory function to generate a configurator for a specific module type.">DynExp::MakeModuleConfig()</a>.  <br /></td></tr>
<tr class="separator:ae68b31d1e54e5a1a1aa36ae4738a695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea8b939b183b3e513ebd1de057d9330" id="r_a5ea8b939b183b3e513ebd1de057d9330"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a5ea8b939b183b3e513ebd1de057d9330">LibraryStringType</a> = const char *</td></tr>
<tr class="memdesc:a5ea8b939b183b3e513ebd1de057d9330"><td class="mdescLeft">&#160;</td><td class="mdescRight">String type used for library entry descriptors.  <br /></td></tr>
<tr class="separator:a5ea8b939b183b3e513ebd1de057d9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb97fc4ed081ca0cbe043aeb07ac5689" id="r_acb97fc4ed081ca0cbe043aeb07ac5689"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#acb97fc4ed081ca0cbe043aeb07ac5689">LibraryStringParamPtrType</a> = <a class="el" href="namespaceDynExp.html#a5ea8b939b183b3e513ebd1de057d9330">LibraryStringType</a>(*)()</td></tr>
<tr class="memdesc:acb97fc4ed081ca0cbe043aeb07ac5689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a DynExp object's static constexpr function returning a string literal. Used for the Name() and Category() functions which are required for classes derived from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a> to become library entries.  <br /></td></tr>
<tr class="separator:acb97fc4ed081ca0cbe043aeb07ac5689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc4588c310da85b99f3363780f01451" id="r_a5bc4588c310da85b99f3363780f01451"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a5bc4588c310da85b99f3363780f01451">HardwareAdapterLibraryVectorType</a> = std::vector&lt; <a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a>&lt; <a class="el" href="namespaceDynExp.html#aff5ae1451b86061935d6fb2be9253dbf">HardwareAdapterPtrType</a> &gt; &gt;</td></tr>
<tr class="memdesc:a5bc4588c310da85b99f3363780f01451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the vector type containing entries of a hardware adapter library.  <br /></td></tr>
<tr class="separator:a5bc4588c310da85b99f3363780f01451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c56e28d92a00626f91bec4dbd155ec6" id="r_a3c56e28d92a00626f91bec4dbd155ec6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a3c56e28d92a00626f91bec4dbd155ec6">InstrumentLibraryVectorType</a> = std::vector&lt; <a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a>&lt; <a class="el" href="namespaceDynExp.html#a3aa73be1acbc98bff987351e6cfdf3c6">InstrumentPtrType</a> &gt; &gt;</td></tr>
<tr class="memdesc:a3c56e28d92a00626f91bec4dbd155ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the vector type containing entries of a instrument library.  <br /></td></tr>
<tr class="separator:a3c56e28d92a00626f91bec4dbd155ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2956076623f7a88282d7a50d2735aca" id="r_af2956076623f7a88282d7a50d2735aca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#af2956076623f7a88282d7a50d2735aca">ModuleLibraryVectorType</a> = std::vector&lt; <a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a>&lt; <a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9">ModulePtrType</a> &gt; &gt;</td></tr>
<tr class="memdesc:af2956076623f7a88282d7a50d2735aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the vector type containing entries of a module library.  <br /></td></tr>
<tr class="separator:af2956076623f7a88282d7a50d2735aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d7ea9098c19de0aad2785fddec7fd9" id="r_ac2d7ea9098c19de0aad2785fddec7fd9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9">ModulePtrType</a> = std::unique_ptr&lt; <a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a> &gt;</td></tr>
<tr class="memdesc:ac2d7ea9098c19de0aad2785fddec7fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to store a module (<a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">DynExp::ModuleBase</a>) with.  <br /></td></tr>
<tr class="separator:ac2d7ea9098c19de0aad2785fddec7fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37893554d836c991669b035a366e132f" id="r_a37893554d836c991669b035a366e132f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a37893554d836c991669b035a366e132f">ItemIDListType</a> = std::vector&lt; <a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a> &gt;</td></tr>
<tr class="memdesc:a37893554d836c991669b035a366e132f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a list of IDs belonging to objects managed by DynExp.  <br /></td></tr>
<tr class="separator:a37893554d836c991669b035a366e132f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34083b4ae1bb40c60d166a6ba170137" id="r_ab34083b4ae1bb40c60d166a6ba170137"><td class="memTemplParams" colspan="2">template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:ab34083b4ae1bb40c60d166a6ba170137"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#ab34083b4ae1bb40c60d166a6ba170137">ManagerTypeOfObjectType_t</a> = typename <a class="el" href="namespaceDynExp.html#structDynExp_1_1ManagerTypeOfObjectType">ManagerTypeOfObjectType</a>&lt; ObjectType &gt;::type</td></tr>
<tr class="memdesc:ab34083b4ae1bb40c60d166a6ba170137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a resource manager type (derived from <a class="el" href="classDynExp_1_1CommonResourceManagerBase.html" title="Common base class for all derived ResourceManagerBase classes. Logical const-ness: Only const functio...">DynExp::CommonResourceManagerBase</a>) managing resources of type <code>ObjectType</code>.  <br /></td></tr>
<tr class="separator:ab34083b4ae1bb40c60d166a6ba170137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7330bf5931734173d955c5c2cca169d3" id="r_a7330bf5931734173d955c5c2cca169d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> = std::unique_ptr&lt; <a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a> &gt;</td></tr>
<tr class="memdesc:a7330bf5931734173d955c5c2cca169d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a pointer to the parameter system base class <code><a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">ParamsBase</a></code>.  <br /></td></tr>
<tr class="separator:a7330bf5931734173d955c5c2cca169d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e8eb7d596ba9acd056adac00cf799" id="r_ae21e8eb7d596ba9acd056adac00cf799"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a> = std::shared_ptr&lt; <a class="el" href="classDynExp_1_1ConfiguratorBase.html">ConfiguratorBase</a> &gt;</td></tr>
<tr class="memdesc:ae21e8eb7d596ba9acd056adac00cf799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a pointer to the configurator base class <code><a class="el" href="classDynExp_1_1ConfiguratorBase.html" title="The configurator classes have the task to generate parameter objects (refer to DynExp::ParamsBase) of...">ConfiguratorBase</a></code>.  <br /></td></tr>
<tr class="separator:ae21e8eb7d596ba9acd056adac00cf799"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeeaa5a8928ddbba6c58c54eac7ef6394" id="r_aeeaa5a8928ddbba6c58c54eac7ef6394"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: ItemIDType { <a class="el" href="namespaceDynExp.html#aeeaa5a8928ddbba6c58c54eac7ef6394abaa1ecd403ec41d0670bc3cb185f5daf">ItemIDNotSet</a> = 0
 }</td></tr>
<tr class="memdesc:aeeaa5a8928ddbba6c58c54eac7ef6394"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of an non-existent object/item.  <a href="namespaceDynExp.html#aeeaa5a8928ddbba6c58c54eac7ef6394">More...</a><br /></td></tr>
<tr class="separator:aeeaa5a8928ddbba6c58c54eac7ef6394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d4939794961e9a821f6c7baf263e5e" id="r_a03d4939794961e9a821f6c7baf263e5e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5e">TextUsageType</a> { <a class="el" href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5eaeb6d8ae6f20283755b339c0dc273988b">Standard</a>
, <a class="el" href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5eaac70412e939d72a9234cdebb1af5867b">Path</a>
, <a class="el" href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5eaca0dbad92a874b2f69b549293387925e">Code</a>
 }</td></tr>
<tr class="memdesc:a03d4939794961e9a821f6c7baf263e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the usage of a text-type parameter. Setting the right usage allows the <code><a class="el" href="classParamsConfigDialog.html" title="Defines the configuration dialog. The dialog must be displayed by calling ParamsConfigDialog::Display...">ParamsConfigDialog</a></code> to add specific functionality to a text field to edit the parameter's value.  <a href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5e">More...</a><br /></td></tr>
<tr class="separator:a03d4939794961e9a821f6c7baf263e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab434a81b50f75cef55863aa9a8838deb" id="r_ab434a81b50f75cef55863aa9a8838deb"><td class="memTemplParams" colspan="2">template&lt;typename HardwareAdapterT &gt; </td></tr>
<tr class="memitem:ab434a81b50f75cef55863aa9a8838deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#ab434a81b50f75cef55863aa9a8838deb">MakeHardwareAdapterConfig</a> ()</td></tr>
<tr class="memdesc:ab434a81b50f75cef55863aa9a8838deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate a configurator for a specific hardware adapter type.  <br /></td></tr>
<tr class="separator:ab434a81b50f75cef55863aa9a8838deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a9d65cc5abe12037f0c65f1d80485e" id="r_a05a9d65cc5abe12037f0c65f1d80485e"><td class="memTemplParams" colspan="2">template&lt;typename HardwareAdapterT &gt; </td></tr>
<tr class="memitem:a05a9d65cc5abe12037f0c65f1d80485e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#aff5ae1451b86061935d6fb2be9253dbf">HardwareAdapterPtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a05a9d65cc5abe12037f0c65f1d80485e">MakeHardwareAdapter</a> (const std::thread::id OwnerThreadID, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;Params)</td></tr>
<tr class="memdesc:a05a9d65cc5abe12037f0c65f1d80485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate a hardware adapter of a specific type.  <br /></td></tr>
<tr class="separator:a05a9d65cc5abe12037f0c65f1d80485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6985987f0ba5cd7ab42caef76ac995c9" id="r_a6985987f0ba5cd7ab42caef76ac995c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a6985987f0ba5cd7ab42caef76ac995c9">InstrumentThreadMain</a> (<a class="el" href="classDynExp_1_1InstrumentInstance.html">InstrumentInstance</a> Instance, <a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a> *const Instrument)</td></tr>
<tr class="memdesc:a6985987f0ba5cd7ab42caef76ac995c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruments run in their own thread. This is the instrument thread's main function.  <br /></td></tr>
<tr class="separator:a6985987f0ba5cd7ab42caef76ac995c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1752e52520c8dae87e1ab78390b21" id="r_aa0c1752e52520c8dae87e1ab78390b21"><td class="memTemplParams" colspan="2">template&lt;typename InstrumentT &gt; </td></tr>
<tr class="memitem:aa0c1752e52520c8dae87e1ab78390b21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#aa0c1752e52520c8dae87e1ab78390b21">MakeInstrumentConfig</a> ()</td></tr>
<tr class="memdesc:aa0c1752e52520c8dae87e1ab78390b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate a configurator for a specific instrument type.  <br /></td></tr>
<tr class="separator:aa0c1752e52520c8dae87e1ab78390b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a665bfe105d8132ce8a28e3cb6fc2" id="r_a006a665bfe105d8132ce8a28e3cb6fc2"><td class="memTemplParams" colspan="2">template&lt;typename InstrumentT &gt; </td></tr>
<tr class="memitem:a006a665bfe105d8132ce8a28e3cb6fc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#a3aa73be1acbc98bff987351e6cfdf3c6">InstrumentPtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a006a665bfe105d8132ce8a28e3cb6fc2">MakeInstrument</a> (const std::thread::id OwnerThreadID, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;Params)</td></tr>
<tr class="memdesc:a006a665bfe105d8132ce8a28e3cb6fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate an instrument of a specific type.  <br /></td></tr>
<tr class="separator:a006a665bfe105d8132ce8a28e3cb6fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92837960e2b88977b310d2f3eeb28561" id="r_a92837960e2b88977b310d2f3eeb28561"><td class="memTemplParams" colspan="2">template&lt;typename TaskT , typename... ArgTs&gt; </td></tr>
<tr class="memitem:a92837960e2b88977b310d2f3eeb28561"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; TaskT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a92837960e2b88977b310d2f3eeb28561">MakeTask</a> (ArgTs &amp;&amp;...Args)</td></tr>
<tr class="memdesc:a92837960e2b88977b310d2f3eeb28561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a task to be enqueued in an instrument's task queue.  <br /></td></tr>
<tr class="separator:a92837960e2b88977b310d2f3eeb28561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61022ff90ef9e457ae6706823883a601" id="r_a61022ff90ef9e457ae6706823883a601"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , std::enable_if_t&lt; std::is_same_v&lt; <a class="el" href="classDynExp_1_1InstrumentDataBase.html">InstrumentDataBase</a>, std::remove_cv_t&lt; From &gt; &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a61022ff90ef9e457ae6706823883a601"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a61022ff90ef9e457ae6706823883a601">dynamic_InstrumentData_cast</a> (<a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; From &gt; &amp;&amp;InstrumentDataPtr)</td></tr>
<tr class="memdesc:a61022ff90ef9e457ae6706823883a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the data base class <code>From</code> into a derived <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a>'s</code> (<code>To</code>) data class keeping the data locked by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> for thread-safe casting.  <br /></td></tr>
<tr class="separator:a61022ff90ef9e457ae6706823883a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502c1fd84645138b14d654a4c6336689" id="r_a502c1fd84645138b14d654a4c6336689"><td class="memTemplParams" colspan="2">template&lt;typename... InstrTs&gt; </td></tr>
<tr class="memitem:a502c1fd84645138b14d654a4c6336689"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a502c1fd84645138b14d654a4c6336689">WaitForInstruments</a> (InstrTs &amp;... Instruments)</td></tr>
<tr class="memdesc:a502c1fd84645138b14d654a4c6336689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until every instrument passed to the function as a reference parameter has arrived at a synchronization point.  <br /></td></tr>
<tr class="separator:a502c1fd84645138b14d654a4c6336689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5902149e2f07daa50dd1050ce5c9962d" id="r_a5902149e2f07daa50dd1050ce5c9962d"><td class="memTemplParams" colspan="2">template&lt;typename LibraryVectorT &gt; </td></tr>
<tr class="memitem:a5902149e2f07daa50dd1050ce5c9962d"><td class="memTemplItemLeft" align="right" valign="top">const LibraryVectorT::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a5902149e2f07daa50dd1050ce5c9962d">FindInLibraryVector</a> (const LibraryVectorT &amp;LibraryVector, const std::string &amp;Category, const std::string &amp;Name)</td></tr>
<tr class="memdesc:a5902149e2f07daa50dd1050ce5c9962d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entry in a library vector by category and name.  <br /></td></tr>
<tr class="separator:a5902149e2f07daa50dd1050ce5c9962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd637f0e67b9a2815532b5a7e1754bd2" id="r_acd637f0e67b9a2815532b5a7e1754bd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#acd637f0e67b9a2815532b5a7e1754bd2">ModuleThreadMain</a> (<a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a> Instance, <a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a> *const Module)</td></tr>
<tr class="memdesc:acd637f0e67b9a2815532b5a7e1754bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modules run in their own thread. This is the module thread's main function.  <br /></td></tr>
<tr class="separator:acd637f0e67b9a2815532b5a7e1754bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21da3ccf9adc0ec1cbc385df6cd751f6" id="r_a21da3ccf9adc0ec1cbc385df6cd751f6"><td class="memTemplParams" colspan="2">template&lt;typename ModuleT &gt; </td></tr>
<tr class="memitem:a21da3ccf9adc0ec1cbc385df6cd751f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a21da3ccf9adc0ec1cbc385df6cd751f6">MakeModuleConfig</a> ()</td></tr>
<tr class="memdesc:a21da3ccf9adc0ec1cbc385df6cd751f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate a configurator for a specific module type.  <br /></td></tr>
<tr class="separator:a21da3ccf9adc0ec1cbc385df6cd751f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf294132f114f6832a56c5cc83444cc" id="r_a4cf294132f114f6832a56c5cc83444cc"><td class="memTemplParams" colspan="2">template&lt;typename ModuleT &gt; </td></tr>
<tr class="memitem:a4cf294132f114f6832a56c5cc83444cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9">ModulePtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a4cf294132f114f6832a56c5cc83444cc">MakeModule</a> (const std::thread::id OwnerThreadID, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;Params)</td></tr>
<tr class="memdesc:a4cf294132f114f6832a56c5cc83444cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate a module of a specific type.  <br /></td></tr>
<tr class="separator:a4cf294132f114f6832a56c5cc83444cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f0f5b615c5d99ff4325ab785735a7a" id="r_a95f0f5b615c5d99ff4325ab785735a7a"><td class="memTemplParams" colspan="2">template&lt;typename ReceiverType , typename... ArgsTs&gt; </td></tr>
<tr class="memitem:a95f0f5b615c5d99ff4325ab785735a7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a95f0f5b615c5d99ff4325ab785735a7a">MakeEvent</a> (ReceiverType *Receiver, typename <a class="el" href="classDynExp_1_1DefaultEvent.html">DefaultEvent</a>&lt; ReceiverType, std::tuple&lt; std::remove_reference_t&lt; ArgsTs &gt;... &gt; &gt;::EventFuncPtrType EventFuncPtr, ArgsTs &amp;&amp;...Args)</td></tr>
<tr class="memdesc:a95f0f5b615c5d99ff4325ab785735a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event of type <code><a class="el" href="classDynExp_1_1DefaultEvent.html" title="Describes an event which consists of a receiver&#39;s member function and a set of arguments to call this...">DefaultEvent</a></code>.  <br /></td></tr>
<tr class="separator:a95f0f5b615c5d99ff4325ab785735a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4acf049b2d034a8d328a14c2794676" id="r_a9e4acf049b2d034a8d328a14c2794676"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , std::enable_if_t&lt; std::is_same_v&lt; <a class="el" href="classDynExp_1_1ModuleDataBase.html">ModuleDataBase</a>, std::remove_cv_t&lt; From &gt; &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9e4acf049b2d034a8d328a14c2794676"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a9e4acf049b2d034a8d328a14c2794676">dynamic_ModuleData_cast</a> (<a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; From &gt; &amp;&amp;ModuleDataPtr)</td></tr>
<tr class="memdesc:a9e4acf049b2d034a8d328a14c2794676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the data base class <code>From</code> into a derived <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> (<code>To</code>) data class keeping the data locked by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> for thread-safe casting.  <br /></td></tr>
<tr class="separator:a9e4acf049b2d034a8d328a14c2794676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ef89aa207a8a443a9ee31eff70e34b" id="r_a62ef89aa207a8a443a9ee31eff70e34b"><td class="memTemplParams" colspan="2">template&lt;typename ParamType &gt; </td></tr>
<tr class="memitem:a62ef89aa207a8a443a9ee31eff70e34b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a62ef89aa207a8a443a9ee31eff70e34b">operator==</a> (const <a class="el" href="classDynExp_1_1ParamsBase_1_1TypedParamBase.html">ParamsBase::TypedParamBase</a>&lt; ParamType &gt; &amp;lhs, const ParamType &amp;rhs)</td></tr>
<tr class="memdesc:a62ef89aa207a8a443a9ee31eff70e34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides (in)equality comparison operators for two parameters. Since C++20, inequality operators (operator!=) are generated by compiler.  <br /></td></tr>
<tr class="separator:a62ef89aa207a8a443a9ee31eff70e34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cf28afdeaacd5734cfd0fe76834fe6" id="r_a36cf28afdeaacd5734cfd0fe76834fe6"><td class="memTemplParams" colspan="2">template&lt;typename ParamType &gt; </td></tr>
<tr class="memitem:a36cf28afdeaacd5734cfd0fe76834fe6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a36cf28afdeaacd5734cfd0fe76834fe6">operator&lt;=&gt;</a> (const <a class="el" href="classDynExp_1_1ParamsBase_1_1TypedParamBase.html">ParamsBase::TypedParamBase</a>&lt; ParamType &gt; &amp;lhs, const ParamType &amp;rhs)</td></tr>
<tr class="memdesc:a36cf28afdeaacd5734cfd0fe76834fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides three-way comparison for two parameters.  <br /></td></tr>
<tr class="separator:a36cf28afdeaacd5734cfd0fe76834fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a30aba6b175de7d3ac849c1a599a6da" id="r_a1a30aba6b175de7d3ac849c1a599a6da"><td class="memTemplParams" colspan="2">template&lt;typename ConfiguratorT &gt; </td></tr>
<tr class="memitem:a1a30aba6b175de7d3ac849c1a599a6da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a1a30aba6b175de7d3ac849c1a599a6da">MakeParams</a> (<a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a> ID, const <a class="el" href="classDynExp_1_1DynExpCore.html">DynExpCore</a> &amp;Core)</td></tr>
<tr class="memdesc:a1a30aba6b175de7d3ac849c1a599a6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to generate an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> parameters.  <br /></td></tr>
<tr class="separator:a1a30aba6b175de7d3ac849c1a599a6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee65daefbed082223d98441525bca7d9" id="r_aee65daefbed082223d98441525bca7d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee65daefbed082223d98441525bca7d9"><td class="memTemplItemLeft" align="right" valign="top">T::ParamsType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#aee65daefbed082223d98441525bca7d9">dynamic_Params_cast</a> (ParamsBasePtrType::element_type *Params)</td></tr>
<tr class="memdesc:aee65daefbed082223d98441525bca7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the parameter base class to a derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> parameter class.  <br /></td></tr>
<tr class="separator:aee65daefbed082223d98441525bca7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225bdbe81e29bfd95f3bcdb7c8f74b5f" id="r_a225bdbe81e29bfd95f3bcdb7c8f74b5f"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , std::enable_if_t&lt; std::is_same_v&lt; <a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a>, std::remove_cv_t&lt; From &gt; &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a225bdbe81e29bfd95f3bcdb7c8f74b5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a225bdbe81e29bfd95f3bcdb7c8f74b5f">dynamic_Params_cast</a> (<a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; From &gt; &amp;&amp;ParamsPtr)</td></tr>
<tr class="memdesc:a225bdbe81e29bfd95f3bcdb7c8f74b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the parameter base class <code>From</code> to a derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> (<code>To</code>) parameter class keeping the parameters locked by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> for thread-safe casting.  <br /></td></tr>
<tr class="separator:a225bdbe81e29bfd95f3bcdb7c8f74b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad068b36864d5ca8d5c17a7fc923c6c2c" id="r_ad068b36864d5ca8d5c17a7fc923c6c2c"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, To &gt; &amp;&amp;std::is_base_of_v&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, From &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad068b36864d5ca8d5c17a7fc923c6c2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#ad068b36864d5ca8d5c17a7fc923c6c2c">dynamic_Object_cast</a> (From *Obj)</td></tr>
<tr class="memdesc:ad068b36864d5ca8d5c17a7fc923c6c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to a derived type.  <br /></td></tr>
<tr class="separator:ad068b36864d5ca8d5c17a7fc923c6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5fd9f6f673e5fd9c6adf9861625b7776" id="r_a5fd9f6f673e5fd9c6adf9861625b7776"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a5fd9f6f673e5fd9c6adf9861625b7776">DynExpName</a> = &quot;DynExp&quot;</td></tr>
<tr class="memdesc:a5fd9f6f673e5fd9c6adf9861625b7776"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp's name string  <br /></td></tr>
<tr class="separator:a5fd9f6f673e5fd9c6adf9861625b7776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9742fc6e15cef2f50c35c0fc54d3865" id="r_af9742fc6e15cef2f50c35c0fc54d3865"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#af9742fc6e15cef2f50c35c0fc54d3865">DynExpVersion</a> = &quot;@PROJECT_VERSION@&quot;</td></tr>
<tr class="memdesc:af9742fc6e15cef2f50c35c0fc54d3865"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp's version string  <br /></td></tr>
<tr class="separator:af9742fc6e15cef2f50c35c0fc54d3865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03c3ef997e69242a5fe720893572bc1" id="r_aa03c3ef997e69242a5fe720893572bc1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#aa03c3ef997e69242a5fe720893572bc1">DynExpDescription</a> = &quot;Highly flexible laboratory automation for dynamically changing experiments.&quot;</td></tr>
<tr class="memdesc:aa03c3ef997e69242a5fe720893572bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynExp's description string  <br /></td></tr>
<tr class="separator:aa03c3ef997e69242a5fe720893572bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ec5d80a19a6f7d920a383ff529578a" id="r_a50ec5d80a19a6f7d920a383ff529578a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDynExp.html#a50ec5d80a19a6f7d920a383ff529578a">DefaultLocale</a> = &quot;en_US.UTF8&quot;</td></tr>
<tr class="memdesc:a50ec5d80a19a6f7d920a383ff529578a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default locale string.  <br /></td></tr>
<tr class="separator:a50ec5d80a19a6f7d920a383ff529578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>DynExp's main namespace contains the implementation of DynExp including classes to manage resources (DynExp objects like hardware adapters, instruments, and modules) as well as their dependencies and parameters. </p>
<p>DynExp's main namespace contains DynExp's core functionality. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classDynExp_1_1LibraryBase" id="classDynExp_1_1LibraryBase"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classDynExp_1_1LibraryBase">&#9670;&#160;</a></span>DynExp::LibraryBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class DynExp::LibraryBase</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ObjectTypeBasePtr, typename ObjFactories, typename ConfFactories, typename ObjNames, typename ObjCategories&gt;<br />
class DynExp::LibraryBase&lt; ObjectTypeBasePtr, ObjFactories, ConfFactories, ObjNames, ObjCategories &gt;</div><p>Represents the base class for a library containing library entries (<a class="el" href="structDynExp_1_1LibraryEntry.html" title="Represents an entry in the library.">DynExp::LibraryEntry</a>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectTypeBasePtr</td><td>Refer to <a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a" title="Alias for a factory function pointer type that instantiates library entries to create DynExp objects ...">DynExp::LibraryObjectFactoryPtrType</a>. </td></tr>
    <tr><td class="paramname">ObjFactories</td><td>Type of multiple object factory pointers </td></tr>
    <tr><td class="paramname">ConfFactories</td><td>Type of multiple configurator factory pointers </td></tr>
    <tr><td class="paramname">ObjNames</td><td>Type of multiple function pointers returning the entry names </td></tr>
    <tr><td class="paramname">ObjCategories</td><td>Type of multiple function pointers returning the entry categories </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00112">112</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>
</div>
</div>
</div>
<a name="classDynExp_1_1LibraryConfigFactoryParamList" id="classDynExp_1_1LibraryConfigFactoryParamList"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classDynExp_1_1LibraryConfigFactoryParamList">&#9670;&#160;</a></span>DynExp::LibraryConfigFactoryParamList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class DynExp::LibraryConfigFactoryParamList</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;LibraryConfigFactoryPtrType...&gt;<br />
class DynExp::LibraryConfigFactoryParamList&lt;... &gt;</div><p>Type consisting of function pointer types returning configurators for DynExp objects. Refer to <a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799" title="Alias for a pointer to the configurator base class ConfiguratorBase.">DynExp::ConfiguratorBasePtrType</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...</td><td>Function pointer types </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00059">59</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>
</div>
</div>
</div>
<a name="classDynExp_1_1LibraryObjectFactoryParamList" id="classDynExp_1_1LibraryObjectFactoryParamList"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classDynExp_1_1LibraryObjectFactoryParamList">&#9670;&#160;</a></span>DynExp::LibraryObjectFactoryParamList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class DynExp::LibraryObjectFactoryParamList</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ObjectTypeBasePtr, <a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a">LibraryObjectFactoryPtrType</a>&lt; ObjectTypeBasePtr &gt; ...&gt;<br />
class DynExp::LibraryObjectFactoryParamList&lt; ObjectTypeBasePtr,... &gt;</div><p>Type consisting of function pointer types instantiating DynExp objects. Refer to <a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a" title="Alias for a factory function pointer type that instantiates library entries to create DynExp objects ...">DynExp::LibraryObjectFactoryPtrType</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectTypeBasePtr</td><td>Refer to <a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a" title="Alias for a factory function pointer type that instantiates library entries to create DynExp objects ...">DynExp::LibraryObjectFactoryPtrType</a>. </td></tr>
    <tr><td class="paramname">...</td><td>Function pointer types </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00051">51</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>
</div>
</div>
</div>
<a name="classDynExp_1_1LibraryStringParamList" id="classDynExp_1_1LibraryStringParamList"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classDynExp_1_1LibraryStringParamList">&#9670;&#160;</a></span>DynExp::LibraryStringParamList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class DynExp::LibraryStringParamList</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;LibraryStringParamPtrType...&gt;<br />
class DynExp::LibraryStringParamList&lt;... &gt;</div><p>Type consisting of function pointer types returning string literals. Refer to <a class="el" href="namespaceDynExp.html#acb97fc4ed081ca0cbe043aeb07ac5689" title="Pointer to a DynExp object&#39;s static constexpr function returning a string literal....">DynExp::LibraryStringParamPtrType</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...</td><td>Function pointer types </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00067">67</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>
</div>
</div>
</div>
<a name="structDynExp_1_1ManagerTypeOfObjectType" id="structDynExp_1_1ManagerTypeOfObjectType"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structDynExp_1_1ManagerTypeOfObjectType">&#9670;&#160;</a></span>DynExp::ManagerTypeOfObjectType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct DynExp::ManagerTypeOfObjectType</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ObjectType, std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a>, ObjectType &gt;||std::is_base_of_v&lt; <a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a>, ObjectType &gt;, int &gt; = 0&gt;<br />
struct DynExp::ManagerTypeOfObjectType&lt; ObjectType, &gt;</div><p>Type trait relating a type <code>ObjectType</code> derived from either class <code><a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">HardwareAdapterBase</a></code> or class <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> to the resource manager type (derived from <a class="el" href="classDynExp_1_1CommonResourceManagerBase.html" title="Common base class for all derived ResourceManagerBase classes. Logical const-ness: Only const functio...">DynExp::CommonResourceManagerBase</a>) managing instances of the type <code>ObjectType</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>Type to relate to a corresponding resource manager </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l00054">54</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a0197ff151b88ea475918890e7d29fe4f" name="a0197ff151b88ea475918890e7d29fe4f"></a>typedef conditional_t&lt; is_base_of_v&lt; <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a>, ObjectType &gt;, <a class="el" href="classDynExp_1_1HardwareAdapterManager.html">HardwareAdapterManager</a>, <a class="el" href="classDynExp_1_1InstrumentManager.html">InstrumentManager</a> &gt;</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<a class="el" href="structDynExp_1_1Resource.html" title="Defines a DynExp resource, which mainly owns a DynExp::Object instance wrapping a pointer to it.">Resource</a> manager type managing instances of type <code>ObjectType</code>. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae21e8eb7d596ba9acd056adac00cf799" name="ae21e8eb7d596ba9acd056adac00cf799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21e8eb7d596ba9acd056adac00cf799">&#9670;&#160;</a></span>ConfiguratorBasePtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">DynExp::ConfiguratorBasePtrType</a> = typedef std::shared_ptr&lt;<a class="el" href="classDynExp_1_1ConfiguratorBase.html">ConfiguratorBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a pointer to the configurator base class <code><a class="el" href="classDynExp_1_1ConfiguratorBase.html" title="The configurator classes have the task to generate parameter objects (refer to DynExp::ParamsBase) of...">ConfiguratorBase</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01959">1959</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a5bc4588c310da85b99f3363780f01451" name="a5bc4588c310da85b99f3363780f01451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc4588c310da85b99f3363780f01451">&#9670;&#160;</a></span>HardwareAdapterLibraryVectorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a5bc4588c310da85b99f3363780f01451">DynExp::HardwareAdapterLibraryVectorType</a> = typedef std::vector&lt;<a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a>&lt;<a class="el" href="namespaceDynExp.html#aff5ae1451b86061935d6fb2be9253dbf">HardwareAdapterPtrType</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the vector type containing entries of a hardware adapter library. </p>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00204">204</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="aff5ae1451b86061935d6fb2be9253dbf" name="aff5ae1451b86061935d6fb2be9253dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5ae1451b86061935d6fb2be9253dbf">&#9670;&#160;</a></span>HardwareAdapterPtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#aff5ae1451b86061935d6fb2be9253dbf">DynExp::HardwareAdapterPtrType</a> = typedef std::shared_ptr&lt;<a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer type to store a hardware adapter (<a class="el" href="classDynExp_1_1HardwareAdapterBase.html" title="Defines the base class for a hardware adapter object. Hardware adapters describe interfaces/connectio...">DynExp::HardwareAdapterBase</a>) with. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00022">22</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a3c56e28d92a00626f91bec4dbd155ec6" name="a3c56e28d92a00626f91bec4dbd155ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c56e28d92a00626f91bec4dbd155ec6">&#9670;&#160;</a></span>InstrumentLibraryVectorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a3c56e28d92a00626f91bec4dbd155ec6">DynExp::InstrumentLibraryVectorType</a> = typedef std::vector&lt;<a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a>&lt;<a class="el" href="namespaceDynExp.html#a3aa73be1acbc98bff987351e6cfdf3c6">InstrumentPtrType</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the vector type containing entries of a instrument library. </p>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00225">225</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="a3aa73be1acbc98bff987351e6cfdf3c6" name="a3aa73be1acbc98bff987351e6cfdf3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa73be1acbc98bff987351e6cfdf3c6">&#9670;&#160;</a></span>InstrumentPtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a3aa73be1acbc98bff987351e6cfdf3c6">DynExp::InstrumentPtrType</a> = typedef std::shared_ptr&lt;<a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer type to store an instrument (<a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">DynExp::InstrumentBase</a>) with. </p>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00026">26</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a37893554d836c991669b035a366e132f" name="a37893554d836c991669b035a366e132f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37893554d836c991669b035a366e132f">&#9670;&#160;</a></span>ItemIDListType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a37893554d836c991669b035a366e132f">DynExp::ItemIDListType</a> = typedef std::vector&lt;<a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a list of IDs belonging to objects managed by DynExp. </p>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l00040">40</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a8b4c34da3bf02951070e7011bc438e38" name="a8b4c34da3bf02951070e7011bc438e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4c34da3bf02951070e7011bc438e38">&#9670;&#160;</a></span>ItemIDType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">DynExp::ItemIDType</a> = typedef size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ID type of objects/items managed by DynExp. </p>

<p class="definition">Definition at line <a class="el" href="DynExpDefinitions_8h_8in_source.html#l00050">50</a> of file <a class="el" href="DynExpDefinitions_8h_8in_source.html">DynExpDefinitions.h.in</a>.</p>

</div>
</div>
<a id="ae68b31d1e54e5a1a1aa36ae4738a695f" name="ae68b31d1e54e5a1a1aa36ae4738a695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68b31d1e54e5a1a1aa36ae4738a695f">&#9670;&#160;</a></span>LibraryConfigFactoryPtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#ae68b31d1e54e5a1a1aa36ae4738a695f">DynExp::LibraryConfigFactoryPtrType</a> = typedef <a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a>(*)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a factory function pointer type that creates a configurator for a specific library entry. Compatible e.g. to <a class="el" href="namespaceDynExp.html#a21da3ccf9adc0ec1cbc385df6cd751f6" title="Factory function to generate a configurator for a specific module type.">DynExp::MakeModuleConfig()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00030">30</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="a61d65e509999f772d18a74946aa7082a" name="a61d65e509999f772d18a74946aa7082a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d65e509999f772d18a74946aa7082a">&#9670;&#160;</a></span>LibraryObjectFactoryPtrType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectTypeBasePtr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a61d65e509999f772d18a74946aa7082a">DynExp::LibraryObjectFactoryPtrType</a> = typedef ObjectTypeBasePtr(*)(const std::thread::id, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a>&amp;&amp;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a factory function pointer type that instantiates library entries to create DynExp objects derived from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>. As arguments, it expects the thread ID of the thread owning the resource and a reference to the resource's parameters to take ownership of. Compatible e.g. to <a class="el" href="namespaceDynExp.html#a4cf294132f114f6832a56c5cc83444cc" title="Factory function to generate a module of a specific type.">DynExp::MakeModule()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectTypeBasePtr</td><td>Pointer to the base type of a certain DynExp resource (e.g. <a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9" title="Pointer type to store a module (DynExp::ModuleBase) with.">DynExp::ModulePtrType</a>) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00024">24</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="acb97fc4ed081ca0cbe043aeb07ac5689" name="acb97fc4ed081ca0cbe043aeb07ac5689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb97fc4ed081ca0cbe043aeb07ac5689">&#9670;&#160;</a></span>LibraryStringParamPtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#acb97fc4ed081ca0cbe043aeb07ac5689">DynExp::LibraryStringParamPtrType</a> = typedef <a class="el" href="namespaceDynExp.html#a5ea8b939b183b3e513ebd1de057d9330">LibraryStringType</a>(*)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a DynExp object's static constexpr function returning a string literal. Used for the Name() and Category() functions which are required for classes derived from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a> to become library entries. </p>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00042">42</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="a5ea8b939b183b3e513ebd1de057d9330" name="a5ea8b939b183b3e513ebd1de057d9330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea8b939b183b3e513ebd1de057d9330">&#9670;&#160;</a></span>LibraryStringType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a5ea8b939b183b3e513ebd1de057d9330">DynExp::LibraryStringType</a> = typedef const char*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String type used for library entry descriptors. </p>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00035">35</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="ab34083b4ae1bb40c60d166a6ba170137" name="ab34083b4ae1bb40c60d166a6ba170137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34083b4ae1bb40c60d166a6ba170137">&#9670;&#160;</a></span>ManagerTypeOfObjectType_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#ab34083b4ae1bb40c60d166a6ba170137">DynExp::ManagerTypeOfObjectType_t</a> = typedef typename <a class="el" href="namespaceDynExp.html#structDynExp_1_1ManagerTypeOfObjectType">ManagerTypeOfObjectType</a>&lt;ObjectType&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a resource manager type (derived from <a class="el" href="classDynExp_1_1CommonResourceManagerBase.html" title="Common base class for all derived ResourceManagerBase classes. Logical const-ness: Only const functio...">DynExp::CommonResourceManagerBase</a>) managing resources of type <code>ObjectType</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>Refer to <a class="el" href="namespaceDynExp.html#structDynExp_1_1ManagerTypeOfObjectType" title="Type trait relating a type ObjectType derived from either class HardwareAdapterBase or class Instrume...">DynExp::ManagerTypeOfObjectType</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l00072">72</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="af2956076623f7a88282d7a50d2735aca" name="af2956076623f7a88282d7a50d2735aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2956076623f7a88282d7a50d2735aca">&#9670;&#160;</a></span>ModuleLibraryVectorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#af2956076623f7a88282d7a50d2735aca">DynExp::ModuleLibraryVectorType</a> = typedef std::vector&lt;<a class="el" href="structDynExp_1_1LibraryEntry.html">LibraryEntry</a>&lt;<a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9">ModulePtrType</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the vector type containing entries of a module library. </p>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00246">246</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="ac2d7ea9098c19de0aad2785fddec7fd9" name="ac2d7ea9098c19de0aad2785fddec7fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d7ea9098c19de0aad2785fddec7fd9">&#9670;&#160;</a></span>ModulePtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9">DynExp::ModulePtrType</a> = typedef std::unique_ptr&lt;<a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer type to store a module (<a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">DynExp::ModuleBase</a>) with. </p>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00023">23</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a7330bf5931734173d955c5c2cca169d3" name="a7330bf5931734173d955c5c2cca169d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7330bf5931734173d955c5c2cca169d3">&#9670;&#160;</a></span>ParamsBasePtrType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">DynExp::ParamsBasePtrType</a> = typedef std::unique_ptr&lt;<a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for a pointer to the parameter system base class <code><a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">ParamsBase</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01807">1807</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aeeaa5a8928ddbba6c58c54eac7ef6394" name="aeeaa5a8928ddbba6c58c54eac7ef6394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeaa5a8928ddbba6c58c54eac7ef6394">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : <a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ID of an non-existent object/item. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeeaa5a8928ddbba6c58c54eac7ef6394abaa1ecd403ec41d0670bc3cb185f5daf" name="aeeaa5a8928ddbba6c58c54eac7ef6394abaa1ecd403ec41d0670bc3cb185f5daf"></a>ItemIDNotSet&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DynExpDefinitions_8h_8in_source.html#l00055">55</a> of file <a class="el" href="DynExpDefinitions_8h_8in_source.html">DynExpDefinitions.h.in</a>.</p>

</div>
</div>
<a id="a03d4939794961e9a821f6c7baf263e5e" name="a03d4939794961e9a821f6c7baf263e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d4939794961e9a821f6c7baf263e5e">&#9670;&#160;</a></span>TextUsageType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5e">DynExp::TextUsageType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the usage of a text-type parameter. Setting the right usage allows the <code><a class="el" href="classParamsConfigDialog.html" title="Defines the configuration dialog. The dialog must be displayed by calling ParamsConfigDialog::Display...">ParamsConfigDialog</a></code> to add specific functionality to a text field to edit the parameter's value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a03d4939794961e9a821f6c7baf263e5eaeb6d8ae6f20283755b339c0dc273988b" name="a03d4939794961e9a821f6c7baf263e5eaeb6d8ae6f20283755b339c0dc273988b"></a>Standard&#160;</td><td class="fielddoc"><p>Plain text, no functionality is added. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03d4939794961e9a821f6c7baf263e5eaac70412e939d72a9234cdebb1af5867b" name="a03d4939794961e9a821f6c7baf263e5eaac70412e939d72a9234cdebb1af5867b"></a>Path&#160;</td><td class="fielddoc"><p>Interprets the text as a file path and adds a 'browse' button. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03d4939794961e9a821f6c7baf263e5eaca0dbad92a874b2f69b549293387925e" name="a03d4939794961e9a821f6c7baf263e5eaca0dbad92a874b2f69b549293387925e"></a>Code&#160;</td><td class="fielddoc"><p>Behaves like <a class="el" href="namespaceDynExp.html#a03d4939794961e9a821f6c7baf263e5eaac70412e939d72a9234cdebb1af5867b">TextUsageType::Path</a>, but also adds a button to open a text editor to edit the code file the text (interpreted as a file path) points to. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ParamsConfig_8h_source.html#l00028">28</a> of file <a class="el" href="ParamsConfig_8h_source.html">ParamsConfig.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a61022ff90ef9e457ae6706823883a601" name="a61022ff90ef9e457ae6706823883a601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61022ff90ef9e457ae6706823883a601">&#9670;&#160;</a></span>dynamic_InstrumentData_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , std::enable_if_t&lt; std::is_same_v&lt; <a class="el" href="classDynExp_1_1InstrumentDataBase.html">InstrumentDataBase</a>, std::remove_cv_t&lt; From &gt; &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::dynamic_InstrumentData_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; From &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>InstrumentDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the data base class <code>From</code> into a derived <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a>'s</code> (<code>To</code>) data class keeping the data locked by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> for thread-safe casting. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>Type derived from <code><a class="el" href="classDynExp_1_1InstrumentBase.html" title="Base class for instruments. Instruments comprise virtual devices (meta instruments) and physial devic...">InstrumentBase</a></code> into whose data class type to cast. <code>const</code> is added to <code>To</code> if <code>From</code> is <code>const</code>. </td></tr>
    <tr><td class="paramname">From</td><td>Data class type to cast from (must be <code><a class="el" href="classDynExp_1_1InstrumentDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">InstrumentDataBase</a></code>). This type is automatically deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstrumentDataPtr</td><td>Locked data class to cast from. <code>InstrumentDataPtr</code> is empty after the cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Locked data class cast to the data class belonging to <code>To</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>InstrumentDataPtr</code> is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1TypeErrorException.html" title="Thrown when an attempt was made to convert two incompatible types into each other.">Util::TypeErrorException</a></td><td>is thrown if the cast fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00810">810</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a9e4acf049b2d034a8d328a14c2794676" name="a9e4acf049b2d034a8d328a14c2794676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4acf049b2d034a8d328a14c2794676">&#9670;&#160;</a></span>dynamic_ModuleData_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , std::enable_if_t&lt; std::is_same_v&lt; <a class="el" href="classDynExp_1_1ModuleDataBase.html">ModuleDataBase</a>, std::remove_cv_t&lt; From &gt; &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::dynamic_ModuleData_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; From &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ModuleDataPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the data base class <code>From</code> into a derived <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a>'s</code> (<code>To</code>) data class keeping the data locked by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> for thread-safe casting. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>Type derived from <code><a class="el" href="classDynExp_1_1ModuleBase.html" title="Base class for modules. Modules implement programs on their own (e.g. measurement protocols or server...">ModuleBase</a></code> into whose data class type to cast. <code>const</code> is added to <code>To</code> if <code>From</code> is <code>const</code>. </td></tr>
    <tr><td class="paramname">From</td><td>Data class type to cast from (must be <code><a class="el" href="classDynExp_1_1ModuleDataBase.html" title="Data structure to contain data which is synchronized in between different threads....">ModuleDataBase</a></code>). This type is automatically deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ModuleDataPtr</td><td>Locked data class to cast from. <code>ModuleDataPtr</code> is empty after the cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Locked data class cast to the data class belonging to <code>To</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>ModuleDataPtr</code> is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1TypeErrorException.html" title="Thrown when an attempt was made to convert two incompatible types into each other.">Util::TypeErrorException</a></td><td>is thrown if the cast fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00851">851</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="ad068b36864d5ca8d5c17a7fc923c6c2c" name="ad068b36864d5ca8d5c17a7fc923c6c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad068b36864d5ca8d5c17a7fc923c6c2c">&#9670;&#160;</a></span>dynamic_Object_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, To &gt; &amp;&amp;std::is_base_of_v&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, From &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::dynamic_Object_cast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to a derived type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>Type derived from <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to cast to. <code>const</code> is added to <code>To</code> if <code>From</code> is <code>const</code>. </td></tr>
    <tr><td class="paramname">From</td><td>Type derived from <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to cast from. This type is automatically deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj</td><td>Pointer to the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the cast <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l02333">2333</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="aee65daefbed082223d98441525bca7d9" name="aee65daefbed082223d98441525bca7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee65daefbed082223d98441525bca7d9">&#9670;&#160;</a></span>dynamic_Params_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T::ParamsType * DynExp::dynamic_Params_cast </td>
          <td>(</td>
          <td class="paramtype">ParamsBasePtrType::element_type *&#160;</td>
          <td class="paramname"><em>Params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the parameter base class to a derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> parameter class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type derived from <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to whose parameter type to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Params</td><td>Pointer to the parameter base class </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the cast parameter class. Returns nullptr if <code>Params</code> is nullptr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1TypeErrorException.html" title="Thrown when an attempt was made to convert two incompatible types into each other.">Util::TypeErrorException</a></td><td>is thrown if the cast fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01835">1835</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a225bdbe81e29bfd95f3bcdb7c8f74b5f" name="a225bdbe81e29bfd95f3bcdb7c8f74b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225bdbe81e29bfd95f3bcdb7c8f74b5f">&#9670;&#160;</a></span>dynamic_Params_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , std::enable_if_t&lt; std::is_same_v&lt; <a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a>, std::remove_cv_t&lt; From &gt; &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::dynamic_Params_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; From &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ParamsPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the parameter base class <code>From</code> to a derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> (<code>To</code>) parameter class keeping the parameters locked by <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> for thread-safe casting. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>Type derived from <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to whose parameter type to cast. <code>const</code> is added to <code>To</code> if <code>From</code> is <code>const</code>. </td></tr>
    <tr><td class="paramname">From</td><td>Parameter type to cast from (must be <code><a class="el" href="classDynExp_1_1ParamsBase.html" title="Abstract base class for object parameter classes. Each class derived from class Object must be accomp...">ParamsBase</a></code>). This type is automatically deduced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ParamsPtr</td><td>Locked parameters to cast from. <code>ParamsPtr</code> is empty after the cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Locked parameters cast to the parameter class belonging to <code>To</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>ParamsPtr</code> is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="classUtil_1_1TypeErrorException.html" title="Thrown when an attempt was made to convert two incompatible types into each other.">Util::TypeErrorException</a></td><td>is thrown if the cast fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01862">1862</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a5902149e2f07daa50dd1050ce5c9962d" name="a5902149e2f07daa50dd1050ce5c9962d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5902149e2f07daa50dd1050ce5c9962d">&#9670;&#160;</a></span>FindInLibraryVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LibraryVectorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const LibraryVectorT::value_type &amp; DynExp::FindInLibraryVector </td>
          <td>(</td>
          <td class="paramtype">const LibraryVectorT &amp;&#160;</td>
          <td class="paramname"><em>LibraryVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an entry in a library vector by category and name. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LibraryVectorT</td><td>Type of the library vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LibraryVector</td><td>Library vector to search in </td></tr>
    <tr><td class="paramname">Category</td><td>Category to search for </td></tr>
    <tr><td class="paramname">Name</td><td>Name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the found entry. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1NotFoundException.html" title="Thrown when a requested ressource does not exist.">Util::NotFoundException</a></td><td>is thrown if the entry is not found. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Libraries_8h_source.html#l00258">258</a> of file <a class="el" href="Libraries_8h_source.html">Libraries.h</a>.</p>

</div>
</div>
<a id="a6985987f0ba5cd7ab42caef76ac995c9" name="a6985987f0ba5cd7ab42caef76ac995c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6985987f0ba5cd7ab42caef76ac995c9">&#9670;&#160;</a></span>InstrumentThreadMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DynExp::InstrumentThreadMain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1InstrumentInstance.html">InstrumentInstance</a>&#160;</td>
          <td class="paramname"><em>Instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1InstrumentBase.html">InstrumentBase</a> *const&#160;</td>
          <td class="paramname"><em>Instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruments run in their own thread. This is the instrument thread's main function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the instrument thread's data related to the instrument running this thread. The instrument thread is expected to let the lifetime of <code>Instance</code> expire upon termination. </td></tr>
    <tr><td class="paramname">Instrument</td><td>Pointer to the instrument running this thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57a0902dabc399ef983a70150b54f735e24">Util::DynExpErrorCodes::NoError</a> if the thread terminated without an error, the respective error code otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8cpp_source.html#l00008">8</a> of file <a class="el" href="Instrument_8cpp_source.html">Instrument.cpp</a>.</p>

</div>
</div>
<a id="a95f0f5b615c5d99ff4325ab785735a7a" name="a95f0f5b615c5d99ff4325ab785735a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f0f5b615c5d99ff4325ab785735a7a">&#9670;&#160;</a></span>MakeEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiverType , typename... ArgsTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::MakeEvent </td>
          <td>(</td>
          <td class="paramtype">ReceiverType *&#160;</td>
          <td class="paramname"><em>Receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classDynExp_1_1DefaultEvent.html">DefaultEvent</a>&lt; ReceiverType, std::tuple&lt; std::remove_reference_t&lt; ArgsTs &gt;... &gt; &gt;::EventFuncPtrType&#160;</td>
          <td class="paramname"><em>EventFuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an event of type <code><a class="el" href="classDynExp_1_1DefaultEvent.html" title="Describes an event which consists of a receiver&#39;s member function and a set of arguments to call this...">DefaultEvent</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReceiverType</td><td>Module type to receive this event. </td></tr>
    <tr><td class="paramname">...ArgsTs</td><td>Types of arguments passed to the event function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Receiver</td><td>Pointer to module receiving this event. </td></tr>
    <tr><td class="paramname">EventFuncPtr</td><td>Event function to be invoked (member function of ReceiverType expected). </td></tr>
    <tr><td class="paramname">...Args</td><td>Arguments to pass to the event function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>EventFuncPtr</code> is nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00763">763</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a05a9d65cc5abe12037f0c65f1d80485e" name="a05a9d65cc5abe12037f0c65f1d80485e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a9d65cc5abe12037f0c65f1d80485e">&#9670;&#160;</a></span>MakeHardwareAdapter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HardwareAdapterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#aff5ae1451b86061935d6fb2be9253dbf">HardwareAdapterPtrType</a> DynExp::MakeHardwareAdapter </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id&#160;</td>
          <td class="paramname"><em>OwnerThreadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate a hardware adapter of a specific type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HardwareAdapterT</td><td>Type of the hardware adapter to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OwnerThreadID</td><td>ID of the thread owning the hardware adapter </td></tr>
    <tr><td class="paramname">Params</td><td>Reference to the hardware adapter's parameters to take ownership of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the hardware adapter of the specified type </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00043">43</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="ab434a81b50f75cef55863aa9a8838deb" name="ab434a81b50f75cef55863aa9a8838deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab434a81b50f75cef55863aa9a8838deb">&#9670;&#160;</a></span>MakeHardwareAdapterConfig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HardwareAdapterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a> DynExp::MakeHardwareAdapterConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate a configurator for a specific hardware adapter type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HardwareAdapterT</td><td>Type of the hardware adapter to generate a configurator for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the configurator for the specified hardware adapter type </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00030">30</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a006a665bfe105d8132ce8a28e3cb6fc2" name="a006a665bfe105d8132ce8a28e3cb6fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006a665bfe105d8132ce8a28e3cb6fc2">&#9670;&#160;</a></span>MakeInstrument()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InstrumentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#a3aa73be1acbc98bff987351e6cfdf3c6">InstrumentPtrType</a> DynExp::MakeInstrument </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id&#160;</td>
          <td class="paramname"><em>OwnerThreadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate an instrument of a specific type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InstrumentT</td><td>Type of the instrument to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OwnerThreadID</td><td>ID of the thread owning the instrument </td></tr>
    <tr><td class="paramname">Params</td><td>Reference to theinstrument's parameters to take ownership of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the instrument of the specified type </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00047">47</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="aa0c1752e52520c8dae87e1ab78390b21" name="aa0c1752e52520c8dae87e1ab78390b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1752e52520c8dae87e1ab78390b21">&#9670;&#160;</a></span>MakeInstrumentConfig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InstrumentT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a> DynExp::MakeInstrumentConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate a configurator for a specific instrument type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InstrumentT</td><td>Type of the instrument to generate a configurator for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the configurator for the specified instrument type </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00034">34</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="a4cf294132f114f6832a56c5cc83444cc" name="a4cf294132f114f6832a56c5cc83444cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf294132f114f6832a56c5cc83444cc">&#9670;&#160;</a></span>MakeModule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#ac2d7ea9098c19de0aad2785fddec7fd9">ModulePtrType</a> DynExp::MakeModule </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id&#160;</td>
          <td class="paramname"><em>OwnerThreadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate a module of a specific type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ModuleT</td><td>Type of the module to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OwnerThreadID</td><td>ID of the thread owning the module </td></tr>
    <tr><td class="paramname">Params</td><td>Reference to the module's parameters to take ownership of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the module of the specified type </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00044">44</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a21da3ccf9adc0ec1cbc385df6cd751f6" name="a21da3ccf9adc0ec1cbc385df6cd751f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21da3ccf9adc0ec1cbc385df6cd751f6">&#9670;&#160;</a></span>MakeModuleConfig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#ae21e8eb7d596ba9acd056adac00cf799">ConfiguratorBasePtrType</a> DynExp::MakeModuleConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate a configurator for a specific module type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ModuleT</td><td>Type of the module to generate a configurator for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the configurator for the specified module type </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8h_source.html#l00031">31</a> of file <a class="el" href="Module_8h_source.html">Module.h</a>.</p>

</div>
</div>
<a id="a1a30aba6b175de7d3ac849c1a599a6da" name="a1a30aba6b175de7d3ac849c1a599a6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a30aba6b175de7d3ac849c1a599a6da">&#9670;&#160;</a></span>MakeParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConfiguratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> DynExp::MakeParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a>&#160;</td>
          <td class="paramname"><em>ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDynExp_1_1DynExpCore.html">DynExpCore</a> &amp;&#160;</td>
          <td class="paramname"><em>Core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to generate an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConfiguratorT</td><td>The object type is determined by the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> configurator derived from <code><a class="el" href="classDynExp_1_1ConfiguratorBase.html" title="The configurator classes have the task to generate parameter objects (refer to DynExp::ParamsBase) of...">ConfiguratorBase</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td>ID of the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> to generate parameters for </td></tr>
    <tr><td class="paramname">Core</td><td>Reference to DynExp's core </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> parameters </dd></dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01818">1818</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a92837960e2b88977b310d2f3eeb28561" name="a92837960e2b88977b310d2f3eeb28561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92837960e2b88977b310d2f3eeb28561">&#9670;&#160;</a></span>MakeTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TaskT , typename... ArgTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; TaskT &gt; DynExp::MakeTask </td>
          <td>(</td>
          <td class="paramtype">ArgTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function to create a task to be enqueued in an instrument's task queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TaskT</td><td>Type of a task derived from class <code><a class="el" href="classDynExp_1_1TaskBase.html" title="Base class for all tasks being processed by instruments. The class must not contain public virtual fu...">TaskBase</a></code> </td></tr>
    <tr><td class="paramname">...ArgTs</td><td>Types of the arguments to forward to the task's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...Args</td><td>Arguments to forward to the task's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the task of the specified type </dd></dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l00063">63</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<a id="acd637f0e67b9a2815532b5a7e1754bd2" name="acd637f0e67b9a2815532b5a7e1754bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd637f0e67b9a2815532b5a7e1754bd2">&#9670;&#160;</a></span>ModuleThreadMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DynExp::ModuleThreadMain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleInstance.html">ModuleInstance</a>&#160;</td>
          <td class="paramname"><em>Instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1ModuleBase.html">ModuleBase</a> *const&#160;</td>
          <td class="paramname"><em>Module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modules run in their own thread. This is the module thread's main function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Instance</td><td>Handle to the module thread's data related to the module running this thread. The module thread is expected to let the lifetime of <code>Instance</code> expire upon termination. </td></tr>
    <tr><td class="paramname">Module</td><td>Pointer to the module running this thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceUtil_1_1DynExpErrorCodes.html#a49da632c21753f06d241c7269a24ae57a0902dabc399ef983a70150b54f735e24">Util::DynExpErrorCodes::NoError</a> if the thread terminated without an error, the respective error code otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Module_8cpp_source.html#l00010">10</a> of file <a class="el" href="Module_8cpp_source.html">Module.cpp</a>.</p>

</div>
</div>
<a id="a36cf28afdeaacd5734cfd0fe76834fe6" name="a36cf28afdeaacd5734cfd0fe76834fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cf28afdeaacd5734cfd0fe76834fe6">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynExp_1_1ParamsBase_1_1TypedParamBase.html">ParamsBase::TypedParamBase</a>&lt; ParamType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParamType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides three-way comparison for two parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParamType</td><td>Underlying parameter value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side of the comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of a three-way comparison between the values of <code>lhs</code> and <code>rhs</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01802">1802</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a62ef89aa207a8a443a9ee31eff70e34b" name="a62ef89aa207a8a443a9ee31eff70e34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ef89aa207a8a443a9ee31eff70e34b">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynExp_1_1ParamsBase_1_1TypedParamBase.html">ParamsBase::TypedParamBase</a>&lt; ParamType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParamType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides (in)equality comparison operators for two parameters. Since C++20, inequality operators (operator!=) are generated by compiler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ParamType</td><td>Underlying parameter value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side of the comparison </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the value of <code>lhs</code> equals the value of <code>rhs</code>, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Object_8h_source.html#l01792">1792</a> of file <a class="el" href="Object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<a id="a502c1fd84645138b14d654a4c6336689" name="a502c1fd84645138b14d654a4c6336689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502c1fd84645138b14d654a4c6336689">&#9670;&#160;</a></span>WaitForInstruments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... InstrTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::WaitForInstruments </td>
          <td>(</td>
          <td class="paramtype">InstrTs &amp;...&#160;</td>
          <td class="paramname"><em>Instruments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until every instrument passed to the function as a reference parameter has arrived at a synchronization point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...InstrTs</td><td>Types of the instruments passed to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...Instruments</td><td>Instruments to synchronize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Instrument_8h_source.html#l01234">1234</a> of file <a class="el" href="Instrument_8h_source.html">Instrument.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a50ec5d80a19a6f7d920a383ff529578a" name="a50ec5d80a19a6f7d920a383ff529578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ec5d80a19a6f7d920a383ff529578a">&#9670;&#160;</a></span>DefaultLocale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto DynExp::DefaultLocale = &quot;en_US.UTF8&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default locale string. </p>

<p class="definition">Definition at line <a class="el" href="DynExpDefinitions_8h_8in_source.html#l00036">36</a> of file <a class="el" href="DynExpDefinitions_8h_8in_source.html">DynExpDefinitions.h.in</a>.</p>

</div>
</div>
<a id="aa03c3ef997e69242a5fe720893572bc1" name="aa03c3ef997e69242a5fe720893572bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03c3ef997e69242a5fe720893572bc1">&#9670;&#160;</a></span>DynExpDescription</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto DynExp::DynExpDescription = &quot;Highly flexible laboratory automation for dynamically changing experiments.&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DynExp's description string </p>

<p class="definition">Definition at line <a class="el" href="DynExpDefinitions_8h_8in_source.html#l00031">31</a> of file <a class="el" href="DynExpDefinitions_8h_8in_source.html">DynExpDefinitions.h.in</a>.</p>

</div>
</div>
<a id="a5fd9f6f673e5fd9c6adf9861625b7776" name="a5fd9f6f673e5fd9c6adf9861625b7776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd9f6f673e5fd9c6adf9861625b7776">&#9670;&#160;</a></span>DynExpName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto DynExp::DynExpName = &quot;DynExp&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DynExp's name string </p>

<p class="definition">Definition at line <a class="el" href="DynExpDefinitions_8h_8in_source.html#l00021">21</a> of file <a class="el" href="DynExpDefinitions_8h_8in_source.html">DynExpDefinitions.h.in</a>.</p>

</div>
</div>
<a id="af9742fc6e15cef2f50c35c0fc54d3865" name="af9742fc6e15cef2f50c35c0fc54d3865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9742fc6e15cef2f50c35c0fc54d3865">&#9670;&#160;</a></span>DynExpVersion</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto DynExp::DynExpVersion = &quot;@PROJECT_VERSION@&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DynExp's version string </p>

<p class="definition">Definition at line <a class="el" href="DynExpDefinitions_8h_8in_source.html#l00026">26</a> of file <a class="el" href="DynExpDefinitions_8h_8in_source.html">DynExpDefinitions.h.in</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDynExp.html">DynExp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
