<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DynExp: DynExp::SerialCommunicationHardwareAdapter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="DynExp.ico"/></td>
  <td id="projectalign">
   <div id="projectname">DynExp
   </div>
   <div id="projectbrief">Highly flexible laboratory automation for dynamically changing experiments.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classDynExp_1_1SerialCommunicationHardwareAdapter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDynExp_1_1SerialCommunicationHardwareAdapter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DynExp::SerialCommunicationHardwareAdapter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>.  
 <a href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DynExp::SerialCommunicationHardwareAdapter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDynExp_1_1SerialCommunicationHardwareAdapter__inherit__graph.svg" width="507" height="447"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl" id="r_structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl">endl</a></td></tr>
<tr class="memdesc:structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type denoting the end of a line when piped to <code>operator&lt;&lt;(endl)</code>  <a href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl">More...</a><br /></td></tr>
<tr class="separator:structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afcd142ed67a1e576bc19ba5ebba4d7a1" id="r_afcd142ed67a1e576bc19ba5ebba4d7a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#afcd142ed67a1e576bc19ba5ebba4d7a1">ParamsType</a> = <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html">SerialCommunicationHardwareAdapterParams</a></td></tr>
<tr class="memdesc:afcd142ed67a1e576bc19ba5ebba4d7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. "   <br /></td></tr>
<tr class="separator:afcd142ed67a1e576bc19ba5ebba4d7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488a1757adf93393a9c0c77b8c8c583" id="r_af488a1757adf93393a9c0c77b8c8c583"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#af488a1757adf93393a9c0c77b8c8c583">ConfigType</a> = <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterConfigurator.html">SerialCommunicationHardwareAdapterConfigurator</a></td></tr>
<tr class="memdesc:af488a1757adf93393a9c0c77b8c8c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.    <br /></td></tr>
<tr class="separator:af488a1757adf93393a9c0c77b8c8c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDynExp_1_1HardwareAdapterBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classDynExp_1_1HardwareAdapterBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">DynExp::HardwareAdapterBase</a></td></tr>
<tr class="memitem:a0c3974db18bd1e01d47af56eb3d40ccb inherit pub_types_classDynExp_1_1HardwareAdapterBase" id="r_a0c3974db18bd1e01d47af56eb3d40ccb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a0c3974db18bd1e01d47af56eb3d40ccb">ParamsType</a> = <a class="el" href="classDynExp_1_1HardwareAdapterParamsBase.html">HardwareAdapterParamsBase</a></td></tr>
<tr class="memdesc:a0c3974db18bd1e01d47af56eb3d40ccb inherit pub_types_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. "   <br /></td></tr>
<tr class="separator:a0c3974db18bd1e01d47af56eb3d40ccb inherit pub_types_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada089423187f34db0d2226db6b6c167d inherit pub_types_classDynExp_1_1HardwareAdapterBase" id="r_ada089423187f34db0d2226db6b6c167d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#ada089423187f34db0d2226db6b6c167d">ConfigType</a> = <a class="el" href="classDynExp_1_1HardwareAdapterConfiguratorBase.html">HardwareAdapterConfiguratorBase</a></td></tr>
<tr class="memdesc:ada089423187f34db0d2226db6b6c167d inherit pub_types_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.    <br /></td></tr>
<tr class="separator:ada089423187f34db0d2226db6b6c167d inherit pub_types_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object" id="r_ab643ce7c882f3e7c8d8f9dc46644d284"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> = <a class="el" href="classDynExp_1_1ParamsBase.html">ParamsBase</a></td></tr>
<tr class="memdesc:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <br /></td></tr>
<tr class="separator:ab643ce7c882f3e7c8d8f9dc46644d284 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object" id="r_af43ade18cb10c4fed6d8156aafd99fd3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; <a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> &gt;</td></tr>
<tr class="memdesc:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a>. Parameters wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <br /></td></tr>
<tr class="separator:af43ade18cb10c4fed6d8156aafd99fd3 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object" id="r_a21824eb703ebc394637d957ba1c16e71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">ParamsConstTypeSyncPtrType</a> = <a class="el" href="classUtil_1_1SynchronizedPointer.html">Util::SynchronizedPointer</a>&lt; const <a class="el" href="classDynExp_1_1Object.html#ab643ce7c882f3e7c8d8f9dc46644d284">ParamsType</a> &gt;</td></tr>
<tr class="memdesc:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the return type of Object::GetParams() const. Parameters wrapped into <a class="el" href="classUtil_1_1SynchronizedPointer.html" title="Pointer to lock a class derived from ISynchronizedPointerLockable for synchronizing between threads....">Util::SynchronizedPointer</a> can be accessed in a thread-safe way.  <br /></td></tr>
<tr class="separator:a21824eb703ebc394637d957ba1c16e71 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object" id="r_a1e4cd6bac98bce47b148e267079f21e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1e4cd6bac98bce47b148e267079f21e9">ConfigType</a> = <a class="el" href="classDynExp_1_1ConfiguratorBase.html">ConfiguratorBase</a></td></tr>
<tr class="memdesc:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.  <br /></td></tr>
<tr class="separator:a1e4cd6bac98bce47b148e267079f21e9 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object" id="r_a935874e227bc5bcb039052df45cad956"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a935874e227bc5bcb039052df45cad956">ParamsGetterType</a> = <a class="el" href="classUtil_1_1CallableMemberWrapper.html">Util::CallableMemberWrapper</a>&lt; <a class="el" href="classDynExp_1_1Object.html">Object</a>, decltype(&amp;<a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">Object::GetParams</a>)&gt;</td></tr>
<tr class="memdesc:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoking an instance of this alias is supposed to call <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a> of the instance the <a class="el" href="classUtil_1_1CallableMemberWrapper.html" title="Wraps a member function of some object and stores its default arguments. Moving from CallableMemberWr...">Util::CallableMemberWrapper</a> has been constructed with.  <br /></td></tr>
<tr class="separator:a935874e227bc5bcb039052df45cad956 inherit pub_types_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0aa6d42d6970774974bf22ed9b2b406" id="r_af0aa6d42d6970774974bf22ed9b2b406"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#af0aa6d42d6970774974bf22ed9b2b406">SerialCommunicationHardwareAdapter</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:af0aa6d42d6970774974bf22ed9b2b406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a hardware adapter instance.    <br /></td></tr>
<tr class="separator:af0aa6d42d6970774974bf22ed9b2b406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241155fefbb86909a8b5548ddb8a1410" id="r_a241155fefbb86909a8b5548ddb8a1410"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a241155fefbb86909a8b5548ddb8a1410">~SerialCommunicationHardwareAdapter</a> ()=0</td></tr>
<tr class="separator:a241155fefbb86909a8b5548ddb8a1410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc083ed9de08fdd5d285405c168189c9" id="r_acc083ed9de08fdd5d285405c168189c9"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#acc083ed9de08fdd5d285405c168189c9">GetName</a> () const override</td></tr>
<tr class="memdesc:acc083ed9de08fdd5d285405c168189c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type.  <br /></td></tr>
<tr class="separator:acc083ed9de08fdd5d285405c168189c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2277fa4e11acfbcb0e5f9e585b492d" id="r_acc2277fa4e11acfbcb0e5f9e585b492d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#acc2277fa4e11acfbcb0e5f9e585b492d">GetCategory</a> () const override</td></tr>
<tr class="memdesc:acc2277fa4e11acfbcb0e5f9e585b492d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the category of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type.  <br /></td></tr>
<tr class="separator:acc2277fa4e11acfbcb0e5f9e585b492d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf72d37b2ea8553fceec4139d73a1a41" id="r_acf72d37b2ea8553fceec4139d73a1a41"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#acf72d37b2ea8553fceec4139d73a1a41">GetLineEnding</a> () const</td></tr>
<tr class="memdesc:acf72d37b2ea8553fceec4139d73a1a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a>. Thread-safe since <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a> only changes when <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a> is called (itself calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl(dispatch_tag&lt;HardwareAdapterBase&gt;)</a></code> which calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a09a3d8172998a31436e7db99c7dcd32a" title="Initializes the instance at construction or in case Object::Reset() is called.">Init()</a></code>). <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a> is still std::atomic since <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterWorker.html" title="Qt worker which performs actual serial communication hardware operations in a separate thread in orde...">QSerialCommunicationHardwareAdapterWorker</a></code> running in <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a>'s</code> worker thread might read it anytime - even if there is no <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance which makes use of this hardware adapter instance.  <br /></td></tr>
<tr class="separator:acf72d37b2ea8553fceec4139d73a1a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7ca9facc8d95d2cf8cf9cba8358bca" id="r_a4f7ca9facc8d95d2cf8cf9cba8358bca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4f7ca9facc8d95d2cf8cf9cba8358bca">ReadLine</a> () const</td></tr>
<tr class="memdesc:a4f7ca9facc8d95d2cf8cf9cba8358bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a" title="Calls Read() to retrieve data from the underlying hardware interface. Writes the retrieved data to th...">ReadIntoBuffer()</a></code> before it extracts the first line from the read buffer.  <br /></td></tr>
<tr class="separator:a4f7ca9facc8d95d2cf8cf9cba8358bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe32a08ae697f8deb1f10a343ca1712" id="r_a6fe32a08ae697f8deb1f10a343ca1712"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a6fe32a08ae697f8deb1f10a343ca1712">ReadAll</a> () const</td></tr>
<tr class="memdesc:a6fe32a08ae697f8deb1f10a343ca1712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a" title="Calls Read() to retrieve data from the underlying hardware interface. Writes the retrieved data to th...">ReadIntoBuffer()</a></code> before it extracts the entire content from the read buffer.  <br /></td></tr>
<tr class="separator:a6fe32a08ae697f8deb1f10a343ca1712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efe576a021abbac36c57ada9d92202c" id="r_a9efe576a021abbac36c57ada9d92202c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9efe576a021abbac36c57ada9d92202c">WaitForLine</a> (unsigned int NumTries=10, std::chrono::milliseconds DelayBetweenTries=std::chrono::milliseconds(10)) const</td></tr>
<tr class="memdesc:a9efe576a021abbac36c57ada9d92202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4f7ca9facc8d95d2cf8cf9cba8358bca" title="Calls ReadIntoBuffer() before it extracts the first line from the read buffer.">ReadLine()</a></code> for <code>NumTries</code> times until a line is received. Makes the calling thread sleep for <code>DelayBetweenTries</code> in between the calls to <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4f7ca9facc8d95d2cf8cf9cba8358bca" title="Calls ReadIntoBuffer() before it extracts the first line from the read buffer.">ReadLine()</a></code>.  <br /></td></tr>
<tr class="separator:a9efe576a021abbac36c57ada9d92202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ecd1a86aad2f6cf7111ef6f1e48809" id="r_aa5ecd1a86aad2f6cf7111ef6f1e48809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#aa5ecd1a86aad2f6cf7111ef6f1e48809">Clear</a> () const</td></tr>
<tr class="memdesc:aa5ecd1a86aad2f6cf7111ef6f1e48809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content and state flags of the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>) as well as possible internal buffers of the underlying hardware interface.  <br /></td></tr>
<tr class="separator:aa5ecd1a86aad2f6cf7111ef6f1e48809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d3014619dd3b769fb61796cb379ea" id="r_a282d3014619dd3b769fb61796cb379ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a282d3014619dd3b769fb61796cb379ea">Flush</a> () const</td></tr>
<tr class="memdesc:a282d3014619dd3b769fb61796cb379ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the underlying hardware interface and calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a" title="Calls Read() to retrieve data from the underlying hardware interface. Writes the retrieved data to th...">ReadIntoBuffer()</a></code>.  <br /></td></tr>
<tr class="separator:a282d3014619dd3b769fb61796cb379ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ca7d9dffd8647e9b9f09a660921c23" id="r_ac4ca7d9dffd8647e9b9f09a660921c23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ac4ca7d9dffd8647e9b9f09a660921c23">operator&gt;&gt;</a> (std::stringstream &amp;OutStream) const</td></tr>
<tr class="memdesc:ac4ca7d9dffd8647e9b9f09a660921c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the read buffer's content into <code>OutStream</code> calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a6fe32a08ae697f8deb1f10a343ca1712" title="Calls ReadIntoBuffer() before it extracts the entire content from the read buffer.">ReadAll()</a></code>.  <br /></td></tr>
<tr class="separator:ac4ca7d9dffd8647e9b9f09a660921c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a625a76b3bc64336efa914049fd1e18" id="r_a4a625a76b3bc64336efa914049fd1e18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4a625a76b3bc64336efa914049fd1e18">operator&lt;&lt;</a> (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl">endl</a>) const</td></tr>
<tr class="memdesc:a4a625a76b3bc64336efa914049fd1e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new line calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1742c137e628c8abbb8386ad518f2171" title="Writes end of the line characters to the underlying hardware interface.">Write_endl()</a></code>.  <br /></td></tr>
<tr class="separator:a4a625a76b3bc64336efa914049fd1e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab825bbd11c16d77a4a00de6deb13f8" id="r_a1ab825bbd11c16d77a4a00de6deb13f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ab825bbd11c16d77a4a00de6deb13f8">operator&lt;&lt;</a> (const std::stringstream &amp;InStream) const</td></tr>
<tr class="memdesc:a1ab825bbd11c16d77a4a00de6deb13f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.  <br /></td></tr>
<tr class="separator:a1ab825bbd11c16d77a4a00de6deb13f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ce9f3a1e409227bcdc7f9614fe76a5" id="r_ac6ce9f3a1e409227bcdc7f9614fe76a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ac6ce9f3a1e409227bcdc7f9614fe76a5">operator&lt;&lt;</a> (const std::string &amp;Text) const</td></tr>
<tr class="memdesc:ac6ce9f3a1e409227bcdc7f9614fe76a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.    <br /></td></tr>
<tr class="separator:ac6ce9f3a1e409227bcdc7f9614fe76a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dd97c8f10ae1d1da3aaaa2eaf84217" id="r_a90dd97c8f10ae1d1da3aaaa2eaf84217"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a90dd97c8f10ae1d1da3aaaa2eaf84217">operator&lt;&lt;</a> (const std::string_view Text) const</td></tr>
<tr class="memdesc:a90dd97c8f10ae1d1da3aaaa2eaf84217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.      <br /></td></tr>
<tr class="separator:a90dd97c8f10ae1d1da3aaaa2eaf84217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc4461231fdd0aa2067df4683293a3a" id="r_a0dc4461231fdd0aa2067df4683293a3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a0dc4461231fdd0aa2067df4683293a3a">operator&lt;&lt;</a> (const char *Text) const</td></tr>
<tr class="memdesc:a0dc4461231fdd0aa2067df4683293a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.      <br /></td></tr>
<tr class="separator:a0dc4461231fdd0aa2067df4683293a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097293472408bf3c21fbe7e23c24dc7" id="r_ae097293472408bf3c21fbe7e23c24dc7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ae097293472408bf3c21fbe7e23c24dc7">operator&lt;&lt;</a> (const char Char) const</td></tr>
<tr class="memdesc:ae097293472408bf3c21fbe7e23c24dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.    <br /></td></tr>
<tr class="separator:ae097293472408bf3c21fbe7e23c24dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb25409019f95d34413cc7b07af2965" id="r_acbb25409019f95d34413cc7b07af2965"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbb25409019f95d34413cc7b07af2965"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#acbb25409019f95d34413cc7b07af2965">operator&lt;&lt;</a> (const T &amp;Value) const</td></tr>
<tr class="memdesc:acbb25409019f95d34413cc7b07af2965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.    <br /></td></tr>
<tr class="separator:acbb25409019f95d34413cc7b07af2965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDynExp_1_1HardwareAdapterBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDynExp_1_1HardwareAdapterBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">DynExp::HardwareAdapterBase</a></td></tr>
<tr class="memitem:a04b16c535d3ae5d17823aacd049b1f92 inherit pub_methods_classDynExp_1_1HardwareAdapterBase" id="r_a04b16c535d3ae5d17823aacd049b1f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a04b16c535d3ae5d17823aacd049b1f92">HardwareAdapterBase</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a04b16c535d3ae5d17823aacd049b1f92 inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a hardware adapter instance.  <br /></td></tr>
<tr class="separator:a04b16c535d3ae5d17823aacd049b1f92 inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e18d5acf5b30845c42b21d17fc660 inherit pub_methods_classDynExp_1_1HardwareAdapterBase" id="r_a547e18d5acf5b30845c42b21d17fc660"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a547e18d5acf5b30845c42b21d17fc660">~HardwareAdapterBase</a> ()=0</td></tr>
<tr class="separator:a547e18d5acf5b30845c42b21d17fc660 inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae741688c843e3618b7897750bdda3cdc inherit pub_methods_classDynExp_1_1HardwareAdapterBase" id="r_ae741688c843e3618b7897750bdda3cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#ae741688c843e3618b7897750bdda3cdc">ResetException</a> () const</td></tr>
<tr class="memdesc:ae741688c843e3618b7897750bdda3cdc inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a98cfcc71d301d36972095bdb2c7816f4" title="Stores the most recent exception caused by a hardware operation.">LastException</a> to nullptr in a thread-safe way.  <br /></td></tr>
<tr class="separator:ae741688c843e3618b7897750bdda3cdc inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a4c5f0b23bf6dbc21bf470ee55541a inherit pub_methods_classDynExp_1_1HardwareAdapterBase" id="r_a56a4c5f0b23bf6dbc21bf470ee55541a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a56a4c5f0b23bf6dbc21bf470ee55541a">IsConnected</a> () const noexcept</td></tr>
<tr class="memdesc:a56a4c5f0b23bf6dbc21bf470ee55541a inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the connection status of the hardware interface.  <br /></td></tr>
<tr class="separator:a56a4c5f0b23bf6dbc21bf470ee55541a inherit pub_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classUtil_1_1INonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classUtil_1_1INonCopyable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memitem:ad1604a205a9a18f20c51f04327079243 inherit pub_methods_classUtil_1_1INonCopyable" id="r_ad1604a205a9a18f20c51f04327079243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#ad1604a205a9a18f20c51f04327079243">INonCopyable</a> (const <a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:ad1604a205a9a18f20c51f04327079243 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843d52330591d8fab5bfb7d2d981b478 inherit pub_methods_classUtil_1_1INonCopyable" id="r_a843d52330591d8fab5bfb7d2d981b478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a843d52330591d8fab5bfb7d2d981b478">operator=</a> (const <a class="el" href="classUtil_1_1INonCopyable.html">INonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:a843d52330591d8fab5bfb7d2d981b478 inherit pub_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object" id="r_a3d16fbb9394b595905e28ba9291ac402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDynExp.html#a8b4c34da3bf02951070e7011bc438e38">ItemIDType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a3d16fbb9394b595905e28ba9291ac402">GetID</a> () const noexcept</td></tr>
<tr class="memdesc:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. Thread-safe since ID is const.  <br /></td></tr>
<tr class="separator:a3d16fbb9394b595905e28ba9291ac402 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object" id="r_a1a9d46583b415dabe8a41b774f5e0db9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1a9d46583b415dabe8a41b774f5e0db9">GetCategoryAndName</a> () const</td></tr>
<tr class="memdesc:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string from an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> category and name to allow the user to identify an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> type.    <br /></td></tr>
<tr class="separator:a1a9d46583b415dabe8a41b774f5e0db9 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object" id="r_ac5061381dd74b8278624d6f004021db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5061381dd74b8278624d6f004021db8">EnsureReadyState</a> (bool IsAutomaticStartup)</td></tr>
<tr class="memdesc:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready by possibly starting its worker thread or by opening connections to hardware devices.  <br /></td></tr>
<tr class="separator:ac5061381dd74b8278624d6f004021db8 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object" id="r_afd2469a30700f322ae28374cf48a8ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#afd2469a30700f322ae28374cf48a8ba7">CheckLinkedObjectStates</a> () const</td></tr>
<tr class="memdesc:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instances this instance uses are in a ready state. Override <code><a class="el" href="classDynExp_1_1Object.html#a8a0fd11d2dc276253b9ec9d710acb864" title="Override to implement a check whether linked objects are in a ready state.">CheckLinkedObjectStatesChild()</a></code> to implement this behavior.  <br /></td></tr>
<tr class="separator:afd2469a30700f322ae28374cf48a8ba7 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object" id="r_a837a8e8daa7853003474b458a3fe0a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46">Reset</a> ()</td></tr>
<tr class="memdesc:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance (including all its derived classes) by calling <code><a class="el" href="classDynExp_1_1Object.html#a53b82dbe7ee6bb4e9b948c462fffc964" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code>. A reset implies that the derived classes reload all their parameters from <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> and that all <code><a class="el" href="classDynExp_1_1LinkedObjectWrapper.html" title="Holds a shared_ptr to a resource (instance of class Object) and lets the resource keep track of its u...">LinkedObjectWrapper</a></code> instances owned by this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance become invalidated.  <br /></td></tr>
<tr class="separator:a837a8e8daa7853003474b458a3fe0a46 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object" id="r_a5ad8b51f8e38c57a48a408b0ee813143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a5ad8b51f8e38c57a48a408b0ee813143">BlockIfUnused</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>)</td></tr>
<tr class="memdesc:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance setting <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a> to true. Refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a> for the consequences.  <br /></td></tr>
<tr class="separator:a5ad8b51f8e38c57a48a408b0ee813143 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object" id="r_a13f5742205cff37ac598ab2ccb39ca18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#a21824eb703ebc394637d957ba1c16e71">ParamsConstTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18">GetParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the parameter class instance <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a>.  <br /></td></tr>
<tr class="separator:a13f5742205cff37ac598ab2ccb39ca18 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object" id="r_a96ef443e2da7a0c95eccbdf0a5d4d0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a96ef443e2da7a0c95eccbdf0a5d4d0c1">GetParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>)</td></tr>
<tr class="memdesc:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex of the parameter class instance <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a> assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance and returns a pointer to the locked <a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea" title="Pointer to the parameter class instance belonging to this Object instance.">Params</a>.    <br /></td></tr>
<tr class="separator:a96ef443e2da7a0c95eccbdf0a5d4d0c1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object" id="r_ad525cf93f649e6edc5c31c5f16476a43"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ad525cf93f649e6edc5c31c5f16476a43">GetObjectName</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <br /></td></tr>
<tr class="separator:ad525cf93f649e6edc5c31c5f16476a43 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object" id="r_acc8cf73407e49b40b7429bf9ad018235"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#acc8cf73407e49b40b7429bf9ad018235">IsSharedUsageEnabled</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether shared usage has been enabled for this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance. Refer to <a class="el" href="classDynExp_1_1ParamsBase.html#abad5385ae3558b535ee831ca37e16616" title="Determines whether an Object can be linked to only one (unique) or multiple (shared) other objects.">ParamsBase::UsageType</a>.  <br /></td></tr>
<tr class="separator:acc8cf73407e49b40b7429bf9ad018235 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object" id="r_a1244d53367db00489c98b06d1c3cf221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a1244d53367db00489c98b06d1c3cf221">SetWarning</a> (std::string Description, int ErrorCode) const</td></tr>
<tr class="memdesc:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>. Sets the warning by a description and an error code.  <br /></td></tr>
<tr class="separator:a1244d53367db00489c98b06d1c3cf221 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object" id="r_af8005025d4b226d97490c0a0581a610f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af8005025d4b226d97490c0a0581a610f">SetWarning</a> (const <a class="el" href="classUtil_1_1Exception.html">Util::Exception</a> &amp;e) const</td></tr>
<tr class="memdesc:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>. Sets the warning by retrieving the warning data from an exception <code>e</code>.  <br /></td></tr>
<tr class="separator:af8005025d4b226d97490c0a0581a610f inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object" id="r_a7584b53df46340e83301d76e5ca85ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a7584b53df46340e83301d76e5ca85ba3">ClearWarning</a> () const</td></tr>
<tr class="memdesc:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a>.  <br /></td></tr>
<tr class="separator:a7584b53df46340e83301d76e5ca85ba3 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object" id="r_aa696a7ed149a758d7ba5943834ca19f1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#aa696a7ed149a758d7ba5943834ca19f1">GetWarning</a> () const</td></tr>
<tr class="memdesc:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classDynExp_1_1Object.html#a28512c530eac29ecffe722050e035cfc" title="Last warning which occurred within this Object instance. (Logical const-ness: see above....">Object::Warning</a> in a thread-safe way by copying its internal data.  <br /></td></tr>
<tr class="separator:aa696a7ed149a758d7ba5943834ca19f1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object" id="r_ac5f18675231275acf933b5989b8811cc"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5f18675231275acf933b5989b8811cc">GetException</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the exception which has caused this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to fail.  <br /></td></tr>
<tr class="separator:ac5f18675231275acf933b5989b8811cc inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object" id="r_aab58ec8b7377ac5082e376bd9d82dba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#aab58ec8b7377ac5082e376bd9d82dba1">IsReady</a> () const</td></tr>
<tr class="memdesc:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wheter this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is ready (e.g. it is running or connected to a hardware device) and not blocked (refer to <a class="el" href="classDynExp_1_1Object.html#ac2ecbc1d3f9c6e133d722f4fe01e9452" title="This flag indicates whether this Object instance is blocked in order to be destroyed subsequently....">Object::IsBlocked</a>).  <br /></td></tr>
<tr class="separator:aab58ec8b7377ac5082e376bd9d82dba1 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object" id="r_a41b950acea065c13b4899d7c9a12048d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a41b950acea065c13b4899d7c9a12048d">GetUseCount</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the registered useres in a thread-safe way.    <br /></td></tr>
<tr class="separator:a41b950acea065c13b4899d7c9a12048d inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object" id="r_a73f9e22dafdeab31ebeb6859c51da546"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a73f9e22dafdeab31ebeb6859c51da546">IsUnused</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is used by other instances.  <br /></td></tr>
<tr class="separator:a73f9e22dafdeab31ebeb6859c51da546 inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object" id="r_a393f14bb1759eef2fe956a792243dc8b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a393f14bb1759eef2fe956a792243dc8b">GetUserIDs</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the IDs of the registered users in a thread-safe way.    <br /></td></tr>
<tr class="separator:a393f14bb1759eef2fe956a792243dc8b inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object" id="r_a542639f48d6826b0546362fb4078256b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a542639f48d6826b0546362fb4078256b">GetUserNamesString</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string describing which users are registered containing their object names, categories and type names in a thread-safe way.    <br /></td></tr>
<tr class="separator:a542639f48d6826b0546362fb4078256b inherit pub_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae3c1ca890dd95d03687b2256c4280b39" id="r_ae3c1ca890dd95d03687b2256c4280b39"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ae3c1ca890dd95d03687b2256c4280b39">Name</a> () noexcept</td></tr>
<tr class="memdesc:ae3c1ca890dd95d03687b2256c4280b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every derived class has to redefine this function.  <br /></td></tr>
<tr class="separator:ae3c1ca890dd95d03687b2256c4280b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a86ea485d20722978fb1140ac317eaa" id="r_a7a86ea485d20722978fb1140ac317eaa"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a7a86ea485d20722978fb1140ac317eaa">Category</a> () noexcept</td></tr>
<tr class="memdesc:a7a86ea485d20722978fb1140ac317eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every derived class has to redefine this function.    <br /></td></tr>
<tr class="separator:a7a86ea485d20722978fb1140ac317eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5e181196a2f145148839bae1590e23" id="r_a3e5e181196a2f145148839bae1590e23"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; char, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a3e5e181196a2f145148839bae1590e23">LineEndingToChar</a> (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be">SerialCommunicationHardwareAdapterParams::LineEndingType</a> <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a">LineEnding</a>) noexcept</td></tr>
<tr class="memdesc:a3e5e181196a2f145148839bae1590e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be" title="Possible line endings sent after writing a line and used to determine the end of a line while reading...">SerialCommunicationHardwareAdapterParams::LineEndingType</a> to two characters being used as the respective line ending.  <br /></td></tr>
<tr class="separator:a3e5e181196a2f145148839bae1590e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85fed961fc7f298e15638154d95769" id="r_a0d85fed961fc7f298e15638154d95769"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a0d85fed961fc7f298e15638154d95769">GetLineEndingLength</a> (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be">SerialCommunicationHardwareAdapterParams::LineEndingType</a> <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a">LineEnding</a>) noexcept</td></tr>
<tr class="memdesc:a0d85fed961fc7f298e15638154d95769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the amount of characters required to express a line ending type defined by <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be" title="Possible line endings sent after writing a line and used to determine the end of a line while reading...">SerialCommunicationHardwareAdapterParams::LineEndingType</a>.  <br /></td></tr>
<tr class="separator:a0d85fed961fc7f298e15638154d95769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198ad3a42fa3f897363190ebb01525ff" id="r_a198ad3a42fa3f897363190ebb01525ff"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a198ad3a42fa3f897363190ebb01525ff">GetMaxBufferSize</a> () noexcept</td></tr>
<tr class="memdesc:a198ad3a42fa3f897363190ebb01525ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the maximal size of the hardware adapter's (read) buffer.  <br /></td></tr>
<tr class="separator:a198ad3a42fa3f897363190ebb01525ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classDynExp_1_1HardwareAdapterBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classDynExp_1_1HardwareAdapterBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">DynExp::HardwareAdapterBase</a></td></tr>
<tr class="memitem:ac835338e0b0cd23f3b6ef19d78350aa9 inherit pub_static_methods_classDynExp_1_1HardwareAdapterBase" id="r_ac835338e0b0cd23f3b6ef19d78350aa9"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#ac835338e0b0cd23f3b6ef19d78350aa9">Category</a> () noexcept</td></tr>
<tr class="memdesc:ac835338e0b0cd23f3b6ef19d78350aa9 inherit pub_static_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every derived class has to redefine this function.  <br /></td></tr>
<tr class="separator:ac835338e0b0cd23f3b6ef19d78350aa9 inherit pub_static_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object" id="r_af55298b0589b9239ff3076d540c97449"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af55298b0589b9239ff3076d540c97449">CategoryAndNameToStr</a> (const std::string &amp;Category, const std::string &amp;Name)</td></tr>
<tr class="memdesc:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a string from an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> category and name to allow the user to identify an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> type.  <br /></td></tr>
<tr class="separator:af55298b0589b9239ff3076d540c97449 inherit pub_static_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4ed51efc1c439140495cf8120e4f43cf" id="r_a4ed51efc1c439140495cf8120e4f43cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4ed51efc1c439140495cf8120e4f43cf">InsertIntoBuffer</a> (const std::string &amp;String) const</td></tr>
<tr class="memdesc:a4ed51efc1c439140495cf8120e4f43cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method can be called from derived classes to manually insert data into the read buffer. This can be especially useful if there is some callback mechanism which notifies the derived object as soon as data is available. If this mechanism is used, it is fine to let the overridden <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a80fe34afc54c0c0b58bc5f08479c8869" title="Reads a string from the underlying hardware interface.">Read()</a></code> method just return en empty string. This function is thread-safe.  <br /></td></tr>
<tr class="separator:a4ed51efc1c439140495cf8120e4f43cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDynExp_1_1HardwareAdapterBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDynExp_1_1HardwareAdapterBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">DynExp::HardwareAdapterBase</a></td></tr>
<tr class="memitem:a2bbd89a95f821c2c51649b33c6444ad5 inherit pro_methods_classDynExp_1_1HardwareAdapterBase" id="r_a2bbd89a95f821c2c51649b33c6444ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a2bbd89a95f821c2c51649b33c6444ad5">ThrowException</a> (std::exception_ptr Exception) const</td></tr>
<tr class="memdesc:a2bbd89a95f821c2c51649b33c6444ad5 inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <code>Exception</code> in <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a98cfcc71d301d36972095bdb2c7816f4" title="Stores the most recent exception caused by a hardware operation.">LastException</a>, wraps it in a <a class="el" href="classUtil_1_1ForwardedException.html" title="Class to forward an Exception instance from one DynExp::Object instance to another DynExp::Object ins...">Util::ForwardedException</a> and throws the wrapped excetion by calling <a class="el" href="namespaceUtil.html#a2a9f0d5782cf60eccacaa216ea9d1fa8" title="Wraps the exception passed to the function in a ForwardedException and throws the ForwardedException....">Util::ForwardException()</a>.  <br /></td></tr>
<tr class="separator:a2bbd89a95f821c2c51649b33c6444ad5 inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8d09b378758ccb80b0c946e5f0e27d inherit pro_methods_classDynExp_1_1HardwareAdapterBase" id="r_aae8d09b378758ccb80b0c946e5f0e27d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#aae8d09b378758ccb80b0c946e5f0e27d">ThrowExceptionUnsafe</a> (std::exception_ptr Exception) const</td></tr>
<tr class="memdesc:aae8d09b378758ccb80b0c946e5f0e27d inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <code>Exception</code> in <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a98cfcc71d301d36972095bdb2c7816f4" title="Stores the most recent exception caused by a hardware operation.">LastException</a>, wraps it in a <a class="el" href="classUtil_1_1ForwardedException.html" title="Class to forward an Exception instance from one DynExp::Object instance to another DynExp::Object ins...">Util::ForwardedException</a> and throws the wrapped excetion by calling <a class="el" href="namespaceUtil.html#a2a9f0d5782cf60eccacaa216ea9d1fa8" title="Wraps the exception passed to the function in a ForwardedException and throws the ForwardedException....">Util::ForwardException()</a>.    <br /></td></tr>
<tr class="separator:aae8d09b378758ccb80b0c946e5f0e27d inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669d67a8b162a30c5099996a20c00e28 inherit pro_methods_classDynExp_1_1HardwareAdapterBase" id="r_a669d67a8b162a30c5099996a20c00e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a669d67a8b162a30c5099996a20c00e28">SetExceptionUnsafe</a> (std::exception_ptr Exception) const</td></tr>
<tr class="memdesc:a669d67a8b162a30c5099996a20c00e28 inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores <code>Exception</code> in <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a98cfcc71d301d36972095bdb2c7816f4" title="Stores the most recent exception caused by a hardware operation.">LastException</a>.  <br /></td></tr>
<tr class="separator:a669d67a8b162a30c5099996a20c00e28 inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f70091b0c2a6992236855484933afe inherit pro_methods_classDynExp_1_1HardwareAdapterBase" id="r_ab2f70091b0c2a6992236855484933afe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#ab2f70091b0c2a6992236855484933afe">GetExceptionUnsafe</a> () const</td></tr>
<tr class="memdesc:ab2f70091b0c2a6992236855484933afe inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a98cfcc71d301d36972095bdb2c7816f4" title="Stores the most recent exception caused by a hardware operation.">LastException</a>.  <br /></td></tr>
<tr class="separator:ab2f70091b0c2a6992236855484933afe inherit pro_methods_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classUtil_1_1ILockable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classUtil_1_1ILockable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classUtil_1_1ILockable.html">Util::ILockable</a></td></tr>
<tr class="memitem:a04652b293bf19ce1feff5eb96d35bcbe inherit pro_methods_classUtil_1_1ILockable" id="r_a04652b293bf19ce1feff5eb96d35bcbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html#a04652b293bf19ce1feff5eb96d35bcbe">ILockable</a> ()=default</td></tr>
<tr class="separator:a04652b293bf19ce1feff5eb96d35bcbe inherit pro_methods_classUtil_1_1ILockable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb758a703054bb360a2df53bfb7f1774 inherit pro_methods_classUtil_1_1ILockable" id="r_aeb758a703054bb360a2df53bfb7f1774"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html#aeb758a703054bb360a2df53bfb7f1774">~ILockable</a> ()=default</td></tr>
<tr class="separator:aeb758a703054bb360a2df53bfb7f1774 inherit pro_methods_classUtil_1_1ILockable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17baa047909f2477f601d5b582ebd10a inherit pro_methods_classUtil_1_1ILockable" id="r_a17baa047909f2477f601d5b582ebd10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1ILockable.html#a8caa30f3b848739671f3add151a9c0ef">LockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html#a17baa047909f2477f601d5b582ebd10a">AcquireLock</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">DefaultTimeout</a>) const</td></tr>
<tr class="memdesc:a17baa047909f2477f601d5b582ebd10a inherit pro_methods_classUtil_1_1ILockable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the internal mutex. Blocks until the mutex is locked or until the timeout duration is exceeded.  <br /></td></tr>
<tr class="separator:a17baa047909f2477f601d5b582ebd10a inherit pro_methods_classUtil_1_1ILockable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classUtil_1_1INonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classUtil_1_1INonCopyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classUtil_1_1INonCopyable.html">Util::INonCopyable</a></td></tr>
<tr class="memitem:a4442a7fe15262e3ad291220b0af2cd0b inherit pro_methods_classUtil_1_1INonCopyable" id="r_a4442a7fe15262e3ad291220b0af2cd0b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a4442a7fe15262e3ad291220b0af2cd0b">INonCopyable</a> ()=default</td></tr>
<tr class="separator:a4442a7fe15262e3ad291220b0af2cd0b inherit pro_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f837dbc82c4bbf3905900ed59d30152 inherit pro_methods_classUtil_1_1INonCopyable" id="r_a8f837dbc82c4bbf3905900ed59d30152"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1INonCopyable.html#a8f837dbc82c4bbf3905900ed59d30152">~INonCopyable</a> ()=default</td></tr>
<tr class="separator:a8f837dbc82c4bbf3905900ed59d30152 inherit pro_methods_classUtil_1_1INonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object" id="r_a10164159ffa218cb580e98cbdc1d49a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a10164159ffa218cb580e98cbdc1d49a2">Object</a> (const std::thread::id <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd">OwnerThreadID</a>, <a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;<a class="el" href="classDynExp_1_1Object.html#a8a6b4b40c17413b386e01049fd7c40ea">Params</a>)</td></tr>
<tr class="memdesc:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <br /></td></tr>
<tr class="separator:a10164159ffa218cb580e98cbdc1d49a2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477148f8a4a1b829edbb96ca03bfaaa2 inherit pro_methods_classDynExp_1_1Object" id="r_a477148f8a4a1b829edbb96ca03bfaaa2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a477148f8a4a1b829edbb96ca03bfaaa2">~Object</a> ()=0</td></tr>
<tr class="separator:a477148f8a4a1b829edbb96ca03bfaaa2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object" id="r_af6fde3f79ccf7e596889176af39ab6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af6fde3f79ccf7e596889176af39ab6b2">EnsureCallFromOwningThread</a> () const</td></tr>
<tr class="memdesc:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the call to this function is performed from the thread which constructed this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance (the thread with the id stored in <a class="el" href="classDynExp_1_1Object.html#a4dda5f98fa0fa73f4f247db90771befd" title="Thread id of the thread which has constructed (and owns) this Object instance.">Object::OwnerThreadID</a>).  <br /></td></tr>
<tr class="separator:af6fde3f79ccf7e596889176af39ab6b2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object" id="r_a98a7bb1553e393adbc62d28911d82f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object.html#af43ade18cb10c4fed6d8156aafd99fd3">ParamsTypeSyncPtrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a98a7bb1553e393adbc62d28911d82f42">GetNonConstParams</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a>) const</td></tr>
<tr class="memdesc:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows derived <code>Objects</code> to edit their own parameters - even in const task functions (for instruments) or event functions (for modules).  <br /></td></tr>
<tr class="separator:a98a7bb1553e393adbc62d28911d82f42 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object" id="r_af6f3ec1d9b22c4699e344d58ab7a873c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#af6f3ec1d9b22c4699e344d58ab7a873c">LockUserList</a> (const std::chrono::milliseconds Timeout=<a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">Util::ILockable::DefaultTimeout</a>)</td></tr>
<tr class="memdesc:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the user list for thread-safe manipulation.    <br /></td></tr>
<tr class="separator:af6f3ec1d9b22c4699e344d58ab7a873c inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object" id="r_ac5f51f73ef153e261856790b5a9e8870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ac5f51f73ef153e261856790b5a9e8870">DeregisterAllUnsafe</a> ()</td></tr>
<tr class="memdesc:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregisters all users and notifies them that they need to check the states of their used linked objects.    <br /></td></tr>
<tr class="separator:ac5f51f73ef153e261856790b5a9e8870 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0517857d7390e4a40c0bfbf47ac85e2 inherit pro_methods_classDynExp_1_1Object" id="r_ab0517857d7390e4a40c0bfbf47ac85e2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#ab0517857d7390e4a40c0bfbf47ac85e2">GetUseCountUnsafe</a> ()</td></tr>
<tr class="separator:ab0517857d7390e4a40c0bfbf47ac85e2 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b2f15f8129c30d4d3525b187e7ed2b inherit pro_methods_classDynExp_1_1Object" id="r_a76b2f15f8129c30d4d3525b187e7ed2b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a76b2f15f8129c30d4d3525b187e7ed2b">GetUserNamesStringUnsafe</a> () const</td></tr>
<tr class="separator:a76b2f15f8129c30d4d3525b187e7ed2b inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object" id="r_a61de80a7326bf7bf35700e9e76d7ea45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a61de80a7326bf7bf35700e9e76d7ea45">IsUnusedUnsafe</a> ()</td></tr>
<tr class="memdesc:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance is used by other instances (not thread-safe).  <br /></td></tr>
<tr class="separator:a61de80a7326bf7bf35700e9e76d7ea45 inherit pro_methods_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a09a3d8172998a31436e7db99c7dcd32a" id="r_a09a3d8172998a31436e7db99c7dcd32a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a09a3d8172998a31436e7db99c7dcd32a">Init</a> ()</td></tr>
<tr class="memdesc:a09a3d8172998a31436e7db99c7dcd32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the instance at construction or in case <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a> is called.  <br /></td></tr>
<tr class="separator:a09a3d8172998a31436e7db99c7dcd32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89597c476064b560bc904458045a5b4a" id="r_a89597c476064b560bc904458045a5b4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a">ResetImpl</a> (<a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a> &gt;) override final</td></tr>
<tr class="memdesc:a89597c476064b560bc904458045a5b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.    <br /></td></tr>
<tr class="separator:a89597c476064b560bc904458045a5b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb18c141388cca797626c7522dc9bbf" id="r_a4fb18c141388cca797626c7522dc9bbf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4fb18c141388cca797626c7522dc9bbf">ResetImpl</a> (<a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &gt;)</td></tr>
<tr class="memdesc:a4fb18c141388cca797626c7522dc9bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.      <br /></td></tr>
<tr class="separator:a4fb18c141388cca797626c7522dc9bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Not thread-safe</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="el" href="classUtil_1_1ILockable.html#a17baa047909f2477f601d5b582ebd10a" title="Locks the internal mutex. Blocks until the mutex is locked or until the timeout duration is exceeded.">AcquireLock()</a> has to be called manually before and returned LockType has to be still in scope. </p>
</div></td></tr>
<tr class="memitem:a9d18782a4996258f8d7ee7345e84a84a" id="r_a9d18782a4996258f8d7ee7345e84a84a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a">ReadIntoBuffer</a> () const</td></tr>
<tr class="memdesc:a9d18782a4996258f8d7ee7345e84a84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a80fe34afc54c0c0b58bc5f08479c8869" title="Reads a string from the underlying hardware interface.">Read()</a></code> to retrieve data from the underlying hardware interface. Writes the retrieved data to the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>).  <br /></td></tr>
<tr class="separator:a9d18782a4996258f8d7ee7345e84a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc3b35131fd0e1892604f9497a06ee6" id="r_adbc3b35131fd0e1892604f9497a06ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#adbc3b35131fd0e1892604f9497a06ee6">ClearReadBuffer</a> () const</td></tr>
<tr class="memdesc:adbc3b35131fd0e1892604f9497a06ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content and state flags of the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>)  <br /></td></tr>
<tr class="separator:adbc3b35131fd0e1892604f9497a06ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1efe5e11afed8ca75e176ecbfa70d" id="r_a1db1efe5e11afed8ca75e176ecbfa70d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1db1efe5e11afed8ca75e176ecbfa70d">CheckOverflow</a> () const</td></tr>
<tr class="memdesc:a1db1efe5e11afed8ca75e176ecbfa70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the length of the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>) exceeds the maximal allowed length given by <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a198ad3a42fa3f897363190ebb01525ff" title="Defines the maximal size of the hardware adapter&#39;s (read) buffer.">GetMaxBufferSize()</a></code>.  <br /></td></tr>
<tr class="separator:a1db1efe5e11afed8ca75e176ecbfa70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Override, not thread-safe</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Override by derived classes. <a class="el" href="classUtil_1_1ILockable.html#a17baa047909f2477f601d5b582ebd10a" title="Locks the internal mutex. Blocks until the mutex is locked or until the timeout duration is exceeded.">AcquireLock()</a> has to be called manually before and returned LockType has to be still in scope. </p>
</div></td></tr>
<tr class="memitem:a2231a2dd13a97e0e51c4d7ba1ce6f90d" id="r_a2231a2dd13a97e0e51c4d7ba1ce6f90d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a2231a2dd13a97e0e51c4d7ba1ce6f90d">ClearChild</a> () const</td></tr>
<tr class="memdesc:a2231a2dd13a97e0e51c4d7ba1ce6f90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears internal buffers of the underlying hardware interface.  <br /></td></tr>
<tr class="separator:a2231a2dd13a97e0e51c4d7ba1ce6f90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab592179059efb20a8940421c655409" id="r_a1ab592179059efb20a8940421c655409"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ab592179059efb20a8940421c655409">FlushChild</a> () const</td></tr>
<tr class="memdesc:a1ab592179059efb20a8940421c655409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the underlying hardware interface.  <br /></td></tr>
<tr class="separator:a1ab592179059efb20a8940421c655409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fe34afc54c0c0b58bc5f08479c8869" id="r_a80fe34afc54c0c0b58bc5f08479c8869"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a80fe34afc54c0c0b58bc5f08479c8869">Read</a> () const =0</td></tr>
<tr class="memdesc:a80fe34afc54c0c0b58bc5f08479c8869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from the underlying hardware interface.  <br /></td></tr>
<tr class="separator:a80fe34afc54c0c0b58bc5f08479c8869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac6d500500af528b261724e879ebd5c" id="r_a1ac6d500500af528b261724e879ebd5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c">Write</a> (const std::string &amp;String) const =0</td></tr>
<tr class="memdesc:a1ac6d500500af528b261724e879ebd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string to the underlying hardware interface.  <br /></td></tr>
<tr class="separator:a1ac6d500500af528b261724e879ebd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1742c137e628c8abbb8386ad518f2171" id="r_a1742c137e628c8abbb8386ad518f2171"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1742c137e628c8abbb8386ad518f2171">Write_endl</a> () const =0</td></tr>
<tr class="memdesc:a1742c137e628c8abbb8386ad518f2171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes end of the line characters to the underlying hardware interface.  <br /></td></tr>
<tr class="separator:a1742c137e628c8abbb8386ad518f2171"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a854223ba2f88d4c5babe73be150a1b1a" id="r_a854223ba2f88d4c5babe73be150a1b1a"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be">SerialCommunicationHardwareAdapterParams::LineEndingType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a">LineEnding</a> = <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34bead9f6ee53899960277b1353135edb73c0">SerialCommunicationHardwareAdapterParams::LineEndingType::LF</a></td></tr>
<tr class="memdesc:a854223ba2f88d4c5babe73be150a1b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a8c1e0102030743a24ec5aeee76bb9295" title="Parameter storing the line ending type for serial communication.">SerialCommunicationHardwareAdapterParams::LineEnding</a> to avoid locking the corresponding <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html" title="Parameter class for SerialCommunicationHardwareAdapter.">SerialCommunicationHardwareAdapterParams</a></code> instance every time data is read or sent. Refer to <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#acf72d37b2ea8553fceec4139d73a1a41" title="Getter for LineEnding. Thread-safe since LineEnding only changes when Object::Reset() is called (itse...">GetLineEnding()</a></code>.  <br /></td></tr>
<tr class="separator:a854223ba2f88d4c5babe73be150a1b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f456279e9da90be4149f4fb1ecf556b" id="r_a1f456279e9da90be4149f4fb1ecf556b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1f456279e9da90be4149f4fb1ecf556b">LineEndingString</a></td></tr>
<tr class="memdesc:a1f456279e9da90be4149f4fb1ecf556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">String corresponding to <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a>. Refer to <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a3e5e181196a2f145148839bae1590e23" title="Converts SerialCommunicationHardwareAdapterParams::LineEndingType to two characters being used as the...">LineEndingToChar()</a></code>  <br /></td></tr>
<tr class="separator:a1f456279e9da90be4149f4fb1ecf556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6621341e6f4361fa4c2694a1a5c3d84" id="r_ad6621341e6f4361fa4c2694a1a5c3d84"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84">ReadBuffer</a></td></tr>
<tr class="memdesc:ad6621341e6f4361fa4c2694a1a5c3d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer storing data read from the underlying physical hardware.  <br /></td></tr>
<tr class="separator:ad6621341e6f4361fa4c2694a1a5c3d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object" id="r_a4428d406d0477fc605a2d27dc4ac409c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDynExp_1_1Object_1_1LinkedObjectWrapperOnlyType.html">LinkedObjectWrapperOnlyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a4428d406d0477fc605a2d27dc4ac409c">LinkedObjectWrapperOnly</a></td></tr>
<tr class="memdesc:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow exclusive access to some of <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a>'s</code> private methods to any LinkedObjectWrapper&lt;T&gt;.    <br /></td></tr>
<tr class="separator:a4428d406d0477fc605a2d27dc4ac409c inherit pub_attribs_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classDynExp_1_1HardwareAdapterBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classDynExp_1_1HardwareAdapterBase')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">DynExp::HardwareAdapterBase</a></td></tr>
<tr class="memitem:a693ab75499954efe9e468505fb214c6a inherit pub_static_attribs_classDynExp_1_1HardwareAdapterBase" id="r_a693ab75499954efe9e468505fb214c6a"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a693ab75499954efe9e468505fb214c6a">ShortTimeoutDefault</a> = std::chrono::milliseconds(10)</td></tr>
<tr class="memdesc:a693ab75499954efe9e468505fb214c6a inherit pub_static_attribs_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout e.g. used as a default for calls to <a class="el" href="classDynExp_1_1Object.html#ac5f18675231275acf933b5989b8811cc" title="Returns a pointer to the exception which has caused this Object instance to fail.">Object::GetException()</a>.  <br /></td></tr>
<tr class="separator:a693ab75499954efe9e468505fb214c6a inherit pub_static_attribs_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa320f60248bb34134be381035b1de033 inherit pub_static_attribs_classDynExp_1_1HardwareAdapterBase" id="r_aa320f60248bb34134be381035b1de033"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1HardwareAdapterBase.html#aa320f60248bb34134be381035b1de033">HardwareOperationTimeout</a> = std::chrono::milliseconds(100)</td></tr>
<tr class="memdesc:aa320f60248bb34134be381035b1de033 inherit pub_static_attribs_classDynExp_1_1HardwareAdapterBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout used to lock the mutex provided by the base class <a class="el" href="classUtil_1_1ILockable.html" title="Interface to allow synchronizing the access to derived classes between different threads by providing...">Util::ILockable</a> to synchronize access to the hardware interface in between multiple instrument threads.  <br /></td></tr>
<tr class="separator:aa320f60248bb34134be381035b1de033 inherit pub_static_attribs_classDynExp_1_1HardwareAdapterBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classUtil_1_1ILockable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classUtil_1_1ILockable')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classUtil_1_1ILockable.html">Util::ILockable</a></td></tr>
<tr class="memitem:ad11852fe3b22d9e1227c79f210f93980 inherit pub_static_attribs_classUtil_1_1ILockable" id="r_ad11852fe3b22d9e1227c79f210f93980"><td class="memItemLeft" align="right" valign="top">static constexpr std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html#ad11852fe3b22d9e1227c79f210f93980">DefaultTimeout</a> = std::chrono::milliseconds(10)</td></tr>
<tr class="memdesc:ad11852fe3b22d9e1227c79f210f93980 inherit pub_static_attribs_classUtil_1_1ILockable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration which is used as a default timeout within all methods of this class if no different duration is passed to them.  <br /></td></tr>
<tr class="separator:ad11852fe3b22d9e1227c79f210f93980 inherit pub_static_attribs_classUtil_1_1ILockable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classDynExp_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classDynExp_1_1Object')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classDynExp_1_1Object.html">DynExp::Object</a></td></tr>
<tr class="memitem:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object" id="r_a8e6abc80a7c35d4fca2ebfa1b1f141f0"><td class="memItemLeft" align="right" valign="top">static constexpr std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDynExp_1_1Object.html#a8e6abc80a7c35d4fca2ebfa1b1f141f0">GetParamsTimeoutDefault</a> = std::chrono::milliseconds(100)</td></tr>
<tr class="memdesc:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default timeout used by <a class="el" href="classDynExp_1_1Object.html#a13f5742205cff37ac598ab2ccb39ca18" title="Locks the mutex of the parameter class instance Params assigned to this Object instance and returns a...">Object::GetParams()</a> to lock the mutex of the parameter instance assigned to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance.  <br /></td></tr>
<tr class="separator:a8e6abc80a7c35d4fca2ebfa1b1f141f0 inherit pub_static_attribs_classDynExp_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classUtil_1_1ILockable"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classUtil_1_1ILockable')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classUtil_1_1ILockable.html">Util::ILockable</a></td></tr>
<tr class="memitem:a57f74e4420176822ccd4ffe1d26d20a7 inherit pro_types_classUtil_1_1ILockable" id="r_a57f74e4420176822ccd4ffe1d26d20a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html#a57f74e4420176822ccd4ffe1d26d20a7">MutexType</a> = std::timed_mutex</td></tr>
<tr class="separator:a57f74e4420176822ccd4ffe1d26d20a7 inherit pro_types_classUtil_1_1ILockable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caa30f3b848739671f3add151a9c0ef inherit pro_types_classUtil_1_1ILockable" id="r_a8caa30f3b848739671f3add151a9c0ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil_1_1ILockable.html#a8caa30f3b848739671f3add151a9c0ef">LockType</a> = std::unique_lock&lt; <a class="el" href="classUtil_1_1ILockable.html#a57f74e4420176822ccd4ffe1d26d20a7">MutexType</a> &gt;</td></tr>
<tr class="separator:a8caa30f3b848739671f3add151a9c0ef inherit pro_types_classUtil_1_1ILockable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00261">261</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl" id="structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl">&#9670;&#160;</a></span>DynExp::SerialCommunicationHardwareAdapter::endl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct DynExp::SerialCommunicationHardwareAdapter::endl</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Type denoting the end of a line when piped to <code>operator&lt;&lt;(endl)</code> </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00270">270</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>
</div>
</div>
</div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af488a1757adf93393a9c0c77b8c8c583" name="af488a1757adf93393a9c0c77b8c8c583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af488a1757adf93393a9c0c77b8c8c583">&#9670;&#160;</a></span>ConfigType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#af488a1757adf93393a9c0c77b8c8c583">DynExp::SerialCommunicationHardwareAdapter::ConfigType</a> =  <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterConfigurator.html">SerialCommunicationHardwareAdapterConfigurator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the configurator class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective configurator class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>.   </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00265">265</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="afcd142ed67a1e576bc19ba5ebba4d7a1" name="afcd142ed67a1e576bc19ba5ebba4d7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd142ed67a1e576bc19ba5ebba4d7a1">&#9670;&#160;</a></span>ParamsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#afcd142ed67a1e576bc19ba5ebba4d7a1">DynExp::SerialCommunicationHardwareAdapter::ParamsType</a> =  <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html">SerialCommunicationHardwareAdapterParams</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the parameter class belonging to this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. Declare this alias in every derived class with the respective parameter class accompanying the derived <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code>. "  </p>
<p>"  </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00264">264</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0aa6d42d6970774974bf22ed9b2b406" name="af0aa6d42d6970774974bf22ed9b2b406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0aa6d42d6970774974bf22ed9b2b406">&#9670;&#160;</a></span>SerialCommunicationHardwareAdapter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynExp::SerialCommunicationHardwareAdapter::SerialCommunicationHardwareAdapter </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id&#160;</td>
          <td class="paramname"><em>OwnerThreadID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDynExp.html#a7330bf5931734173d955c5c2cca169d3">ParamsBasePtrType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a hardware adapter instance.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OwnerThreadID</td><td>Thread id of the thread owning the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to be constructed. </td></tr>
    <tr><td class="paramname">Params</td><td>Parameter class instance to be assigned to the <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance to be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidArgException.html" title="An invalid argument like a null pointer has been passed to a function.">Util::InvalidArgException</a></td><td>is thrown if <code>OwnerThreadID</code> is an invalid thread id or if <code>Params</code> is nullptr.     </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00140">140</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a241155fefbb86909a8b5548ddb8a1410" name="a241155fefbb86909a8b5548ddb8a1410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241155fefbb86909a8b5548ddb8a1410">&#9670;&#160;</a></span>~SerialCommunicationHardwareAdapter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynExp::SerialCommunicationHardwareAdapter::~SerialCommunicationHardwareAdapter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00136">136</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a86ea485d20722978fb1140ac317eaa" name="a7a86ea485d20722978fb1140ac317eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a86ea485d20722978fb1140ac317eaa">&#9670;&#160;</a></span>Category()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto DynExp::SerialCommunicationHardwareAdapter::Category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Every derived class has to redefine this function.   </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the category of this hardware adapter type.   </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00278">278</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a1db1efe5e11afed8ca75e176ecbfa70d" name="a1db1efe5e11afed8ca75e176ecbfa70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1efe5e11afed8ca75e176ecbfa70d">&#9670;&#160;</a></span>CheckOverflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DynExp::SerialCommunicationHardwareAdapter::CheckOverflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the length of the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>) exceeds the maximal allowed length given by <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a198ad3a42fa3f897363190ebb01525ff" title="Defines the maximal size of the hardware adapter&#39;s (read) buffer.">GetMaxBufferSize()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns false in case of an overflow, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00327">327</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="aa5ecd1a86aad2f6cf7111ef6f1e48809" name="aa5ecd1a86aad2f6cf7111ef6f1e48809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ecd1a86aad2f6cf7111ef6f1e48809">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content and state flags of the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>) as well as possible internal buffers of the underlying hardware interface. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00194">194</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a2231a2dd13a97e0e51c4d7ba1ce6f90d" name="a2231a2dd13a97e0e51c4d7ba1ce6f90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2231a2dd13a97e0e51c4d7ba1ce6f90d">&#9670;&#160;</a></span>ClearChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::SerialCommunicationHardwareAdapter::ClearChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears internal buffers of the underlying hardware interface. </p>

<p>Reimplemented in <a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#a5d1ee215ad074207ffbe396bbc74d1fe">DynExp::QSerialCommunicationHardwareAdapter</a>.</p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00467">467</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="adbc3b35131fd0e1892604f9497a06ee6" name="adbc3b35131fd0e1892604f9497a06ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc3b35131fd0e1892604f9497a06ee6">&#9670;&#160;</a></span>ClearReadBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::ClearReadBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the content and state flags of the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>) </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00321">321</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a282d3014619dd3b769fb61796cb379ea" name="a282d3014619dd3b769fb61796cb379ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282d3014619dd3b769fb61796cb379ea">&#9670;&#160;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the underlying hardware interface and calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a" title="Calls Read() to retrieve data from the underlying hardware interface. Writes the retrieved data to th...">ReadIntoBuffer()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00202">202</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a1ab592179059efb20a8940421c655409" name="a1ab592179059efb20a8940421c655409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab592179059efb20a8940421c655409">&#9670;&#160;</a></span>FlushChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::SerialCommunicationHardwareAdapter::FlushChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes the underlying hardware interface. </p>

<p>Reimplemented in <a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#ac4858618e95b936f20cc1155175e68a5">DynExp::QSerialCommunicationHardwareAdapter</a>.</p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00468">468</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="acc2277fa4e11acfbcb0e5f9e585b492d" name="acc2277fa4e11acfbcb0e5f9e585b492d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2277fa4e11acfbcb0e5f9e585b492d">&#9670;&#160;</a></span>GetCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string DynExp::SerialCommunicationHardwareAdapter::GetCategory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the category of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. </p>

<p>Reimplemented from <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#a758a1a13e984dbfac143159756420ab8">DynExp::HardwareAdapterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00311">311</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="acf72d37b2ea8553fceec4139d73a1a41" name="acf72d37b2ea8553fceec4139d73a1a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf72d37b2ea8553fceec4139d73a1a41">&#9670;&#160;</a></span>GetLineEnding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto DynExp::SerialCommunicationHardwareAdapter::GetLineEnding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a>. Thread-safe since <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a> only changes when <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a> is called (itself calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl(dispatch_tag&lt;HardwareAdapterBase&gt;)</a></code> which calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a09a3d8172998a31436e7db99c7dcd32a" title="Initializes the instance at construction or in case Object::Reset() is called.">Init()</a></code>). <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a> is still std::atomic since <code><a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapterWorker.html" title="Qt worker which performs actual serial communication hardware operations in a separate thread in orde...">QSerialCommunicationHardwareAdapterWorker</a></code> running in <code><a class="el" href="classDynExp_1_1DynExpCore.html" title="DynExp&#39;s core class acts as the interface between the user interface and DynExp&#39;s internal data like ...">DynExpCore</a>'s</code> worker thread might read it anytime - even if there is no <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> instance which makes use of this hardware adapter instance. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00321">321</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a0d85fed961fc7f298e15638154d95769" name="a0d85fed961fc7f298e15638154d95769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d85fed961fc7f298e15638154d95769">&#9670;&#160;</a></span>GetLineEndingLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int DynExp::SerialCommunicationHardwareAdapter::GetLineEndingLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be">SerialCommunicationHardwareAdapterParams::LineEndingType</a>&#160;</td>
          <td class="paramname"><em>LineEnding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the amount of characters required to express a line ending type defined by <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be" title="Possible line endings sent after writing a line and used to determine the end of a line while reading...">SerialCommunicationHardwareAdapterParams::LineEndingType</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LineEnding</td><td>Line ending type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of char(acters) the specified line ending consists of </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00510">510</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a198ad3a42fa3f897363190ebb01525ff" name="a198ad3a42fa3f897363190ebb01525ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198ad3a42fa3f897363190ebb01525ff">&#9670;&#160;</a></span>GetMaxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto DynExp::SerialCommunicationHardwareAdapter::GetMaxBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the maximal size of the hardware adapter's (read) buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns a buffer length of 100 MB. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00301">301</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="acc083ed9de08fdd5d285405c168189c9" name="acc083ed9de08fdd5d285405c168189c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc083ed9de08fdd5d285405c168189c9">&#9670;&#160;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string DynExp::SerialCommunicationHardwareAdapter::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this <code><a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">Object</a></code> type. </p>

<p>Implements <a class="el" href="classDynExp_1_1Object.html#a057f86e9ceec0f7e709e720f66cbb7fb">DynExp::Object</a>.</p>

<p>Reimplemented in <a class="el" href="classDynExp_1_1HardwareAdapterTcpSocket.html#adeb21711c2b1a2f16e288c6d1222fa4b">DynExp::HardwareAdapterTcpSocket</a>, and <a class="el" href="classDynExp_1_1HardwareAdapterSerialPort.html#ad8c13c751a80f1f885648b3356494fcc">DynExp::HardwareAdapterSerialPort</a>.</p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00310">310</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a09a3d8172998a31436e7db99c7dcd32a" name="a09a3d8172998a31436e7db99c7dcd32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a3d8172998a31436e7db99c7dcd32a">&#9670;&#160;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the instance at construction or in case <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">Object::Reset()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00291">291</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a4ed51efc1c439140495cf8120e4f43cf" name="a4ed51efc1c439140495cf8120e4f43cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed51efc1c439140495cf8120e4f43cf">&#9670;&#160;</a></span>InsertIntoBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::InsertIntoBuffer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>String</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method can be called from derived classes to manually insert data into the read buffer. This can be especially useful if there is some callback mechanism which notifies the derived object as soon as data is available. If this mechanism is used, it is fine to let the overridden <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a80fe34afc54c0c0b58bc5f08479c8869" title="Reads a string from the underlying hardware interface.">Read()</a></code> method just return en empty string. This function is thread-safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">String</td><td>String to write to the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidStateException.html" title="An operation cannot be performed currently since the related object is in an invalid state like an er...">Util::InvalidStateException</a></td><td>is thrown if fail flags of <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a> are set after writing to it. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00276">276</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a3e5e181196a2f145148839bae1590e23" name="a3e5e181196a2f145148839bae1590e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5e181196a2f145148839bae1590e23">&#9670;&#160;</a></span>LineEndingToChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; char, 2 &gt; DynExp::SerialCommunicationHardwareAdapter::LineEndingToChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be">SerialCommunicationHardwareAdapterParams::LineEndingType</a>&#160;</td>
          <td class="paramname"><em>LineEnding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be" title="Possible line endings sent after writing a line and used to determine the end of a line while reading...">SerialCommunicationHardwareAdapterParams::LineEndingType</a> to two characters being used as the respective line ending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LineEnding</td><td>Line ending type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of two char(acters) defining a line ending. If the respective line ending type consists of only one character, the second character in the returned array is '\0'. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00499">499</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="ae3c1ca890dd95d03687b2256c4280b39" name="ae3c1ca890dd95d03687b2256c4280b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c1ca890dd95d03687b2256c4280b39">&#9670;&#160;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto DynExp::SerialCommunicationHardwareAdapter::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Every derived class has to redefine this function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of this DynExp object type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00276">276</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a0dc4461231fdd0aa2067df4683293a3a" name="a0dc4461231fdd0aa2067df4683293a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc4461231fdd0aa2067df4683293a3a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.     </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Text</td><td>Text to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on   </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00256">256</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="ae097293472408bf3c21fbe7e23c24dc7" name="ae097293472408bf3c21fbe7e23c24dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae097293472408bf3c21fbe7e23c24dc7">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>Char</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Char</td><td>Single character to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00266">266</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="ac6ce9f3a1e409227bcdc7f9614fe76a5" name="ac6ce9f3a1e409227bcdc7f9614fe76a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ce9f3a1e409227bcdc7f9614fe76a5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Text</td><td>Text to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00236">236</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a90dd97c8f10ae1d1da3aaaa2eaf84217" name="a90dd97c8f10ae1d1da3aaaa2eaf84217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dd97c8f10ae1d1da3aaaa2eaf84217">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>Text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.     </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Text</td><td>Text to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on   </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00246">246</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a1ab825bbd11c16d77a4a00de6deb13f8" name="a1ab825bbd11c16d77a4a00de6deb13f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab825bbd11c16d77a4a00de6deb13f8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>InStream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InStream</td><td>Stream whose contents to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00226">226</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="acbb25409019f95d34413cc7b07af2965" name="acbb25409019f95d34413cc7b07af2965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb25409019f95d34413cc7b07af2965">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the input parameter calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1ac6d500500af528b261724e879ebd5c" title="Writes a string to the underlying hardware interface.">Write()</a></code>. Also writes <code>endl</code> at the end automatically.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Value to write converting it to a string with <a class="el" href="namespaceUtil.html#a119393dd8b76c86ab5ec5993f2b2d568" title="Converts a (numeric) value of type T to a std::string using operator&lt;&lt; of std::stringstream.">Util::ToStr()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00408">408</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a4a625a76b3bc64336efa914049fd1e18" name="a4a625a76b3bc64336efa914049fd1e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a625a76b3bc64336efa914049fd1e18">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#structDynExp_1_1SerialCommunicationHardwareAdapter_1_1endl">endl</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a new line calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a1742c137e628c8abbb8386ad518f2171" title="Writes end of the line characters to the underlying hardware interface.">Write_endl()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00217">217</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="ac4ca7d9dffd8647e9b9f09a660921c23" name="ac4ca7d9dffd8647e9b9f09a660921c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ca7d9dffd8647e9b9f09a660921c23">&#9670;&#160;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &amp; DynExp::SerialCommunicationHardwareAdapter::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>OutStream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the read buffer's content into <code>OutStream</code> calling <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a6fe32a08ae697f8deb1f10a343ca1712" title="Calls ReadIntoBuffer() before it extracts the entire content from the read buffer.">ReadAll()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutStream</td><td>Stream to write the read data to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html" title="Defines a hardware adapter for serial communication. Logical const-ness: see declaration of class Dyn...">SerialCommunicationHardwareAdapter</a></code> instance the function is invoked on </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00210">210</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a80fe34afc54c0c0b58bc5f08479c8869" name="a80fe34afc54c0c0b58bc5f08479c8869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fe34afc54c0c0b58bc5f08479c8869">&#9670;&#160;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string DynExp::SerialCommunicationHardwareAdapter::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a string from the underlying hardware interface. </p>
<dl class="section return"><dt>Returns</dt><dd>String read from the hardware interface </dd></dl>

<p>Implemented in <a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#a63254fa016253ef68d65c81c6d3d84c3">DynExp::QSerialCommunicationHardwareAdapter</a>.</p>

</div>
</div>
<a id="a6fe32a08ae697f8deb1f10a343ca1712" name="a6fe32a08ae697f8deb1f10a343ca1712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe32a08ae697f8deb1f10a343ca1712">&#9670;&#160;</a></span>ReadAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DynExp::SerialCommunicationHardwareAdapter::ReadAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a" title="Calls Read() to retrieve data from the underlying hardware interface. Writes the retrieved data to th...">ReadIntoBuffer()</a></code> before it extracts the entire content from the read buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Content of the read buffer </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00167">167</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a9d18782a4996258f8d7ee7345e84a84a" name="a9d18782a4996258f8d7ee7345e84a84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d18782a4996258f8d7ee7345e84a84a">&#9670;&#160;</a></span>ReadIntoBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::ReadIntoBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a80fe34afc54c0c0b58bc5f08479c8869" title="Reads a string from the underlying hardware interface.">Read()</a></code> to retrieve data from the underlying hardware interface. Writes the retrieved data to the read buffer (<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a>). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUtil_1_1InvalidStateException.html" title="An operation cannot be performed currently since the related object is in an invalid state like an er...">Util::InvalidStateException</a></td><td>is thrown if fail flags of <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#ad6621341e6f4361fa4c2694a1a5c3d84" title="Buffer storing data read from the underlying physical hardware.">ReadBuffer</a> are set after writing to it. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00307">307</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a4f7ca9facc8d95d2cf8cf9cba8358bca" name="a4f7ca9facc8d95d2cf8cf9cba8358bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7ca9facc8d95d2cf8cf9cba8358bca">&#9670;&#160;</a></span>ReadLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DynExp::SerialCommunicationHardwareAdapter::ReadLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a9d18782a4996258f8d7ee7345e84a84a" title="Calls Read() to retrieve data from the underlying hardware interface. Writes the retrieved data to th...">ReadIntoBuffer()</a></code> before it extracts the first line from the read buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>First line from the read buffer or an empty string if the read buffer does not contain a full line. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00146">146</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a89597c476064b560bc904458045a5b4a" name="a89597c476064b560bc904458045a5b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89597c476064b560bc904458045a5b4a">&#9670;&#160;</a></span>ResetImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DynExp::SerialCommunicationHardwareAdapter::ResetImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1HardwareAdapterBase.html">HardwareAdapterBase</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.   </p>

<p>Implements <a class="el" href="classDynExp_1_1HardwareAdapterBase.html#af200add612909e37efdd8a8278f5b5d3">DynExp::HardwareAdapterBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00299">299</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a4fb18c141388cca797626c7522dc9bbf" name="a4fb18c141388cca797626c7522dc9bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb18c141388cca797626c7522dc9bbf">&#9670;&#160;</a></span>ResetImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::SerialCommunicationHardwareAdapter::ResetImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynExp_1_1Object.html#structDynExp_1_1Object_1_1dispatch__tag">dispatch_tag</a>&lt; <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refer to <a class="el" href="classDynExp_1_1Object.html#a837a8e8daa7853003474b458a3fe0a46" title="Resets this Object instance (including all its derived classes) by calling ResetImpl()....">DynExp::Object::Reset()</a>. Using tag dispatch mechanism to ensure that <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a89597c476064b560bc904458045a5b4a" title="Refer to DynExp::Object::Reset(). Using tag dispatch mechanism to ensure that ResetImpl() of every de...">ResetImpl()</a></code> of every derived class gets called - starting from <a class="el" href="classDynExp_1_1Object.html" title="Base class for all DynExp Objects like hardware adapters (DynExp::HardwareAdapterBase),...">DynExp::Object</a>, descending the inheritance hierarchy.     </p>

<p>Reimplemented in <a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#aa96ee0a0bdc50fcf539a05fb892706a9">DynExp::QSerialCommunicationHardwareAdapter</a>.</p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00435">435</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a9efe576a021abbac36c57ada9d92202c" name="a9efe576a021abbac36c57ada9d92202c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efe576a021abbac36c57ada9d92202c">&#9670;&#160;</a></span>WaitForLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DynExp::SerialCommunicationHardwareAdapter::WaitForLine </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>NumTries</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>DelayBetweenTries</em> = <code>std::chrono::milliseconds(10)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4f7ca9facc8d95d2cf8cf9cba8358bca" title="Calls ReadIntoBuffer() before it extracts the first line from the read buffer.">ReadLine()</a></code> for <code>NumTries</code> times until a line is received. Makes the calling thread sleep for <code>DelayBetweenTries</code> in between the calls to <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a4f7ca9facc8d95d2cf8cf9cba8358bca" title="Calls ReadIntoBuffer() before it extracts the first line from the read buffer.">ReadLine()</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumTries</td><td>Number of attempts to read a line from the read buffer </td></tr>
    <tr><td class="paramname">DelayBetweenTries</td><td>Time to wait between subsequent attempts to read a line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First line from the read buffer or an empty string if the read buffer did not receive a full line during the read attempts. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8cpp_source.html#l00179">179</a> of file <a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a>.</p>

</div>
</div>
<a id="a1ac6d500500af528b261724e879ebd5c" name="a1ac6d500500af528b261724e879ebd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac6d500500af528b261724e879ebd5c">&#9670;&#160;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::SerialCommunicationHardwareAdapter::Write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>String</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a string to the underlying hardware interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">String</td><td>String to write </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#a975027de8123a3d40752fee466bfb36a">DynExp::QSerialCommunicationHardwareAdapter</a>.</p>

</div>
</div>
<a id="a1742c137e628c8abbb8386ad518f2171" name="a1742c137e628c8abbb8386ad518f2171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1742c137e628c8abbb8386ad518f2171">&#9670;&#160;</a></span>Write_endl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DynExp::SerialCommunicationHardwareAdapter::Write_endl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes end of the line characters to the underlying hardware interface. </p>

<p>Implemented in <a class="el" href="classDynExp_1_1QSerialCommunicationHardwareAdapter.html#aa3ab9efa6f94ef79d52bb265aa99b738">DynExp::QSerialCommunicationHardwareAdapter</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a854223ba2f88d4c5babe73be150a1b1a" name="a854223ba2f88d4c5babe73be150a1b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854223ba2f88d4c5babe73be150a1b1a">&#9670;&#160;</a></span>LineEnding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34be">SerialCommunicationHardwareAdapterParams::LineEndingType</a>&gt; DynExp::SerialCommunicationHardwareAdapter::LineEnding = <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a1c8a8e8243e3e2ac24af5569e28f34bead9f6ee53899960277b1353135edb73c0">SerialCommunicationHardwareAdapterParams::LineEndingType::LF</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy of <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html#a8c1e0102030743a24ec5aeee76bb9295" title="Parameter storing the line ending type for serial communication.">SerialCommunicationHardwareAdapterParams::LineEnding</a> to avoid locking the corresponding <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapterParams.html" title="Parameter class for SerialCommunicationHardwareAdapter.">SerialCommunicationHardwareAdapterParams</a></code> instance every time data is read or sent. Refer to <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#acf72d37b2ea8553fceec4139d73a1a41" title="Getter for LineEnding. Thread-safe since LineEnding only changes when Object::Reset() is called (itse...">GetLineEnding()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00493">493</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="a1f456279e9da90be4149f4fb1ecf556b" name="a1f456279e9da90be4149f4fb1ecf556b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f456279e9da90be4149f4fb1ecf556b">&#9670;&#160;</a></span>LineEndingString</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DynExp::SerialCommunicationHardwareAdapter::LineEndingString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String corresponding to <a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a854223ba2f88d4c5babe73be150a1b1a" title="Copy of SerialCommunicationHardwareAdapterParams::LineEnding to avoid locking the corresponding Seria...">LineEnding</a>. Refer to <code><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html#a3e5e181196a2f145148839bae1590e23" title="Converts SerialCommunicationHardwareAdapterParams::LineEndingType to two characters being used as the...">LineEndingToChar()</a></code> </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00495">495</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<a id="ad6621341e6f4361fa4c2694a1a5c3d84" name="ad6621341e6f4361fa4c2694a1a5c3d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6621341e6f4361fa4c2694a1a5c3d84">&#9670;&#160;</a></span>ReadBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream DynExp::SerialCommunicationHardwareAdapter::ReadBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer storing data read from the underlying physical hardware. </p>

<p class="definition">Definition at line <a class="el" href="HardwareAdapter_8h_source.html#l00496">496</a> of file <a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="HardwareAdapter_8h_source.html">HardwareAdapter.h</a></li>
<li><a class="el" href="HardwareAdapter_8cpp_source.html">HardwareAdapter.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceDynExp.html">DynExp</a></li><li class="navelem"><a class="el" href="classDynExp_1_1SerialCommunicationHardwareAdapter.html">SerialCommunicationHardwareAdapter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
